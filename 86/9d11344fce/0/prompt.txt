Implement the following plan:

# Fix: Update version check cache on fetch failure

## Problem

In `CheckAndNotify()` (`versioncheck.go:51-58`), when `fetchLatestVersion()` fails, the function returns early **without** updating `cache.LastCheckTime`. The cache remains expired, so every subsequent CLI invocation re-attempts the HTTP request, blocking for up to `httpTimeout` (2s) each time. For offline users or those behind firewalls, this adds a 2-second penalty to every command.

## Fix

**File:** `cmd/entire/cli/versioncheck/versioncheck.go`

Move the cache update to happen **immediately after** `fetchLatestVersion()`, regardless of success or failure. This ensures we record the check attempt and don't retry for another 24 hours.

Current flow (lines 51-65):
```go
latestVersion, err := fetchLatestVersion()
if err != nil {
    // BUG: returns without updating cache
    return
}
cache.LastCheckTime = time.Now()
saveCache(cache)
```

New flow:
```go
latestVersion, err := fetchLatestVersion()

// Always update cache to avoid retrying on every CLI invocation
cache.LastCheckTime = time.Now()
if saveErr := saveCache(cache); saveErr != nil {
    logging.Debug(ctx, "version check: failed to save cache", "error", saveErr.Error())
}

if err != nil {
    logging.Debug(ctx, "version check: failed to fetch latest version", "error", err.Error())
    return
}
```

## Verification

1. `go test ./cmd/entire/cli/versioncheck/ -v -count=1` — all existing tests pass
2. No new tests needed — this is a control flow fix in the untestable `CheckAndNotify` orchestrator (it depends on real filesystem/home dir). The existing `TestFetchLatestVersionServerError` already confirms error propagation from fetch failures.


If you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/gtrrz-victor/.REDACTED.jsonl

---

The comment on line 197 states "limit to prevent large reads" but io.ReadAll is used without any size limit. This could allow a malicious or compromised GitHub API to send an arbitrarily large response, potentially causing memory exhaustion. Consider using io.LimitReader to enforce a reasonable maximum size for the JSON response (e.g., 1MB).

---

fix :
amd64:/home/runner/.local/share/mise/bin:/snap/bin:/home/runner/.local/bin:/opt/pipx_bin:/home/runner/.cargo/bin:/home/runner/.config/composer/vendor/bin:/usr/local/.ghcup/bin:/home/runner/.dotnet/tools:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
The following files need gofmt formatting:
cmd/entire/cli/versioncheck/versioncheck_test.go

---

The main entry point CheckAndNotify lacks test coverage. Critical behaviors that should be tested include: skipping checks for hidden commands, skipping checks for dev/empty versions, respecting the 24-hour check interval, and proper integration of all components (cache loading, version fetching, comparison, notification). Consider adding tests for these scenarios to ensure the function behaves correctly in production.

---

The main entry point CheckAndNotify lacks test coverage. Critical behaviors that should be tested include: skipping checks for hidden commands, skipping checks for dev/empty versions, respecting the 24-hour check interval, and proper integration of all components (cache loading, version fetching, comparison, notification). Consider adding tests for these scenarios to ensure the function behaves correctly in production.