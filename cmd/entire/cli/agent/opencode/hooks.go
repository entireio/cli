package opencode

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/entireio/cli/cmd/entire/cli/agent"
	"github.com/entireio/cli/cmd/entire/cli/paths"
)

// Ensure OpenCodeAgent implements HookSupport and HookHandler
var (
	_ agent.HookSupport = (*OpenCodeAgent)(nil)
	_ agent.HookHandler = (*OpenCodeAgent)(nil)
)

// OpenCode hook names - these become subcommands under `entire hooks opencode`
const (
	HookNameSessionCreated = "session-created"
	HookNameSessionIdle    = "session-idle"
)

// EntirePluginFileName is the TypeScript plugin file installed by Entire.
const EntirePluginFileName = "entire.ts"

// entirePluginMarker identifies Entire-generated plugin files.
const entirePluginMarker = "// Generated by Entire CLI — do not edit manually"

// GetHookNames returns the hook verbs OpenCode supports via the plugin system.
// These become subcommands: entire hooks opencode <verb>
func (o *OpenCodeAgent) GetHookNames() []string {
	return []string{
		HookNameSessionCreated,
		HookNameSessionIdle,
	}
}

// InstallHooks installs the Entire plugin in .opencode/plugins/entire.ts.
// OpenCode auto-discovers TypeScript plugins from .opencode/plugins/*.{ts,js}.
// If force is true, removes existing plugin before installing.
// Returns the number of hooks installed.
func (o *OpenCodeAgent) InstallHooks(localDev bool, force bool) (int, error) {
	repoRoot, err := paths.RepoRoot()
	if err != nil {
		repoRoot, err = os.Getwd() //nolint:forbidigo // Intentional fallback when RepoRoot() fails (tests run outside git repos)
		if err != nil {
			return 0, fmt.Errorf("failed to get current directory: %w", err)
		}
	}

	pluginPath := filepath.Join(repoRoot, ".opencode", "plugins", EntirePluginFileName)

	// Check for idempotency (unless force)
	if !force {
		if data, readErr := os.ReadFile(pluginPath); readErr == nil { //nolint:gosec // path is constructed from repo root + fixed path
			content := string(data)
			if strings.Contains(content, entirePluginMarker) {
				// Already installed — check if mode matches
				if localDev && strings.Contains(content, "go run") {
					return 0, nil
				}
				if !localDev && !strings.Contains(content, "go run") {
					return 0, nil
				}
			}
		}
	}

	// Generate plugin content
	content := entirePluginContent(localDev)

	// Ensure plugin directory exists
	if err := os.MkdirAll(filepath.Dir(pluginPath), 0o750); err != nil {
		return 0, fmt.Errorf("failed to create plugins directory: %w", err)
	}

	if err := os.WriteFile(pluginPath, []byte(content), 0o600); err != nil {
		return 0, fmt.Errorf("failed to write plugin file: %w", err)
	}

	// 2 hooks: session-created and session-idle
	return 2, nil
}

// UninstallHooks removes the Entire plugin from OpenCode's plugins directory.
func (o *OpenCodeAgent) UninstallHooks() error {
	repoRoot, err := paths.RepoRoot()
	if err != nil {
		repoRoot = "." // Fallback to CWD if not in a git repo
	}

	pluginPath := filepath.Join(repoRoot, ".opencode", "plugins", EntirePluginFileName)

	// Only remove if it's our plugin (contains marker)
	data, err := os.ReadFile(pluginPath) //nolint:gosec // path is constructed from repo root + fixed path
	if err != nil {
		return nil //nolint:nilerr // No plugin file means nothing to uninstall
	}

	if !strings.Contains(string(data), entirePluginMarker) {
		return nil // Not our plugin, don't remove
	}

	if err := os.Remove(pluginPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove plugin file: %w", err)
	}
	return nil
}

// AreHooksInstalled checks if the Entire plugin is installed.
func (o *OpenCodeAgent) AreHooksInstalled() bool {
	repoRoot, err := paths.RepoRoot()
	if err != nil {
		repoRoot = "." // Fallback to CWD if not in a git repo
	}

	pluginPath := filepath.Join(repoRoot, ".opencode", "plugins", EntirePluginFileName)
	data, err := os.ReadFile(pluginPath) //nolint:gosec // path is constructed from repo root + fixed path
	if err != nil {
		return false
	}

	return strings.Contains(string(data), entirePluginMarker)
}

// GetSupportedHooks returns the hook types OpenCode supports via its plugin system.
func (o *OpenCodeAgent) GetSupportedHooks() []agent.HookType {
	return []agent.HookType{
		agent.HookSessionStart, // session.created maps to SessionStart
		agent.HookStop,         // session.status idle maps to Stop
	}
}

// entirePluginContent generates the TypeScript plugin source for the Entire integration.
// The plugin subscribes to OpenCode events and pipes JSON payloads to Entire CLI hooks.
func entirePluginContent(localDev bool) string {
	var cmdPrefix string
	if localDev {
		// Use process.env for local development path resolution
		cmdPrefix = "go run ${process.env.OPENCODE_PROJECT_DIR || \".\"}/cmd/entire/main.go"
	} else {
		cmdPrefix = "entire"
	}

	// Backticks can't appear in Go raw string literals, so we build the
	// TypeScript BunShell template-literal lines via string concatenation.
	bt := "`" // backtick

	var sb strings.Builder
	sb.WriteString(entirePluginMarker + "\n")
	sb.WriteString("//\n")
	sb.WriteString("// This plugin integrates OpenCode with Entire for session checkpointing.\n")
	sb.WriteString("// It listens for session lifecycle events and notifies Entire CLI.\n\n")
	sb.WriteString("export default async function entirePlugin(input) {\n")
	sb.WriteString("  const { $ } = input;\n\n")
	sb.WriteString("  return {\n")
	sb.WriteString("    event: async ({ event }) => {\n")
	sb.WriteString("      if (event.type === \"session.created\") {\n")
	sb.WriteString("        const payload = JSON.stringify({\n")
	sb.WriteString("          type: \"session-created\",\n")
	sb.WriteString("          sessionID: event.properties?.info?.id || \"\",\n")
	sb.WriteString("        });\n")
	sb.WriteString("        try {\n")
	sb.WriteString("          await $" + bt + "echo ${payload} | " + cmdPrefix + " hooks opencode session-created" + bt + ".quiet().nothrow();\n")
	sb.WriteString("        } catch {\n")
	sb.WriteString("          // Silently ignore hook failures to avoid disrupting the session\n")
	sb.WriteString("        }\n")
	sb.WriteString("      }\n\n")
	sb.WriteString("      if (event.type === \"session.status\") {\n")
	sb.WriteString("        const status = event.properties?.status;\n")
	sb.WriteString("        if (status?.type === \"idle\") {\n")
	sb.WriteString("          const payload = JSON.stringify({\n")
	sb.WriteString("            type: \"session-idle\",\n")
	sb.WriteString("            sessionID: event.properties?.sessionID || \"\",\n")
	sb.WriteString("          });\n")
	sb.WriteString("          try {\n")
	sb.WriteString("            await $" + bt + "echo ${payload} | " + cmdPrefix + " hooks opencode session-idle" + bt + ".quiet().nothrow();\n")
	sb.WriteString("          } catch {\n")
	sb.WriteString("            // Silently ignore hook failures to avoid disrupting the session\n")
	sb.WriteString("          }\n")
	sb.WriteString("        }\n")
	sb.WriteString("      }\n")
	sb.WriteString("    },\n")
	sb.WriteString("  };\n")
	sb.WriteString("}\n")

	return sb.String()
}
