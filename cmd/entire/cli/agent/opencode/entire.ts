// Entire integration plugin for OpenCode.
// This file is auto-generated by `entire enable` — do not edit manually.
// It hooks into OpenCode's plugin system to notify Entire of session lifecycle events.

import { execSync, execFileSync } from "child_process";
import { writeFileSync, mkdirSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";

interface HookPayload {
  session_id: string;
  session_ref: string;
  timestamp: string;
  transcript_path: string;
  tool_name?: string;
  tool_use_id?: string;
  tool_input?: Record<string, unknown>;
  tool_response?: Record<string, unknown>;
  subagent_transcript_path?: string;
}

// Resolve the entire binary path once at load time.
// Supports ENTIRE_BIN env var override for development/testing.
function resolveBinary(): string {
  const envBin = process.env.ENTIRE_BIN;
  if (envBin) return envBin;
  try {
    return execSync("which entire", { encoding: "utf-8" }).trim();
  } catch {
    return "entire";
  }
}

const entireBin = resolveBinary();

function callEntire(
  log: (msg: string) => void,
  verb: string,
  payload: HookPayload,
): void {
  try {
    const input = JSON.stringify(payload);
    log(`calling: ${entireBin} hooks opencode ${verb}`);
    execFileSync(entireBin, ["hooks", "opencode", verb], {
      input,
      stdio: ["pipe", "pipe", "pipe"],
      timeout: 30_000,
    });
    log(`hook ${verb} completed`);
  } catch (e: any) {
    log(`hook ${verb} failed: ${e?.message ?? e}`);
  }
}

async function exportTranscript(
  client: any,
  log: (msg: string) => void,
  sessionId: string,
): Promise<string> {
  const dir = join(tmpdir(), "entire-opencode");
  mkdirSync(dir, { recursive: true });
  const filePath = join(dir, `${sessionId}.jsonl`);
  try {
    log(`exporting transcript for session ${sessionId}`);
    const response = await client.session.messages({
      path: { id: sessionId },
    });
    const messages: any[] = response.data ?? response ?? [];
    const lines = messages.map((m: any) => JSON.stringify(m));
    writeFileSync(filePath, lines.join("\n") + "\n");
    log(`transcript exported: ${messages.length} messages → ${filePath}`);
  } catch (e: any) {
    log(`transcript export failed: ${e?.message ?? e}`);
    // Write empty file so hook handler still runs
    writeFileSync(filePath, "");
  }
  return filePath;
}

export const EntirePlugin = async (ctx: {
  project: any;
  client: any;
  $: any;
  directory: string;
  worktree: string;
}) => {
  // Structured logging via OpenCode SDK
  const log = (message: string) => {
    ctx.client.app
      .log({
        body: {
          service: "entire",
          level: "info",
          message,
        },
      })
      .catch(() => {});
  };

  log(`plugin loaded, binary: ${entireBin}`);

  return {
    event: async ({ event }: { event: { type: string; properties: any } }) => {
      if (event.type === "session.created") {
        const sessionId = event.properties.info?.id;
        log(`session.created event, sessionId=${sessionId}`);
        if (!sessionId) return;
        const payload: HookPayload = {
          session_id: sessionId,
          session_ref: sessionId,
          timestamp: new Date().toISOString(),
          transcript_path: "",
        };
        callEntire(log, "session-start", payload);
      }

      if (event.type === "session.idle") {
        const sessionId = event.properties.sessionID;
        log(`session.idle event, sessionId=${sessionId}`);
        if (!sessionId) return;
        const transcriptPath = await exportTranscript(
          ctx.client,
          log,
          sessionId,
        );
        const payload: HookPayload = {
          session_id: sessionId,
          session_ref: sessionId,
          timestamp: new Date().toISOString(),
          transcript_path: transcriptPath,
        };
        callEntire(log, "stop", payload);
      }
    },

    "tool.execute.before": async (
      input: { tool: string; sessionID: string; callID: string },
      output: { args: Record<string, unknown> },
    ) => {
      if (input.tool !== "task") return;
      log(`tool.execute.before: task ${input.callID}`);
      const payload: HookPayload = {
        session_id: input.sessionID,
        session_ref: input.sessionID,
        timestamp: new Date().toISOString(),
        transcript_path: "",
        tool_name: input.tool,
        tool_use_id: input.callID,
        tool_input: output.args,
      };
      callEntire(log, "task-start", payload);
    },

    "tool.execute.after": async (
      input: { tool: string; sessionID: string; callID: string },
      output: { title: string; output: string; metadata: any },
    ) => {
      if (input.tool !== "task") return;
      log(`tool.execute.after: task ${input.callID}`);
      const transcriptPath = await exportTranscript(
        ctx.client,
        log,
        input.sessionID,
      );
      const payload: HookPayload = {
        session_id: input.sessionID,
        session_ref: input.sessionID,
        timestamp: new Date().toISOString(),
        transcript_path: transcriptPath,
        tool_name: input.tool,
        tool_use_id: input.callID,
        tool_response: { output: output.output },
        subagent_transcript_path: transcriptPath,
      };
      callEntire(log, "task-complete", payload);
    },
  };
};
