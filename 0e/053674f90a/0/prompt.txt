Implement the following plan:

# Consolidate logging to single file per worktree

## Context

Currently `logging.Init(sessionID)` creates a separate log file per session at `.entire/logs/{session-id}.log`. This makes debugging harder because:
- You can't `tail -f` before a session starts (file doesn't exist yet)
- Concurrent sessions produce separate files you'd need to watch in parallel
- Git hooks need to look up the session ID just to find the right log file

## Change

Write all logs to a single fixed file: `.entire/logs/entire.log`

The `session_id` slog attribute already appears on every log line, so filtering by session is still possible with `jq`.

## Files to modify

### 1. `cmd/entire/cli/logging/logger.go`
- Change `Init()` to use fixed filename `"entire.log"` instead of `sessionID+".log"` (line 124)
- Update doc comment (line 74-75)
- Session ID validation is no longer needed for the file path, but keep it since it's used for the `currentSessionID` attribute â€” actually, `Init()` should still accept a session ID for the slog attribute. But the validation was only there to prevent path traversal in the filename. Since the filename is now fixed, the validation can be relaxed. However, keeping it is harmless and protects against misuse of `currentSessionID`. Leave it.

### 2. `cmd/entire/cli/logging/logger_test.go`
- `TestInit_CreatesLogFile` (line 72): expect `entire.log` not `{sessionID}.log`
- `TestInit_WritesJSONLogs` (line 90): read from `entire.log`
- `TestInit_RespectsLogLevel` (line 136): read from `entire.log`
- `TestInit_FallsBackToStderrOnError` (line 219): block `entire.log` not `{sessionID}.log`
- `TestLogging_IncludesContextValues` (line 301): read from `entire.log`
- `TestLogging_ParentSessionID` (line 354): read from `entire.log`
- `TestLogging_AdditionalAttrs` (line 399): read from `entire.log`
- `TestLogDuration` (line 450): read from `entire.log`
- Extract a `logFilePath(tmpDir)` test helper to DRY up the repeated path construction

### 3. `cmd/entire/cli/hooks_git_cmd.go` (line 63-77)
- `initHookLogging()` currently reads session ID from `paths.ReadCurrentSession()` and passes it to `Init()`. It can still do this (session ID is used for the slog attribute), but it should no longer bail out when there's no session â€” the log file is fixed, so we can always initialize logging. Pass empty string for session ID when unknown.

### 4. `docs/architecture/logging.md`
- Update the file path description from `.entire/logs/<session-id>.log` to `.entire/logs/entire.log`
- Update jq examples to use `entire.log` instead of `*.log`

## Verification

```bash
mise run fmt && mise run lint && mise run test
```


If you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/alex/.claude/projects/-Users-alex-workspace-cli--worktrees-2/7aa4110c-2d3c-4ebc-ab8d-3171d3469440.jsonl

---

commit this, push, open draft PR

---

minor PR nitpick /github-pr-review

---

Base directory for this skill: /Users/alex/.claude/skills/github-pr-review

# GitHub PR Review

## Overview

Technical mechanics for GitHub PR review workflows via `gh` CLI. Covers fetching review comments, replying to threads, creating/updating PRs.

**Companion skill:** For *how to evaluate* feedback, see `superpowers:receiving-code-review`. This skill covers *how to interact* with GitHub.

**Security:** Use fine-grained PAT with minimal permissions.

## Setup (One-Time)

### Fine-Grained PAT

Create at github.com -> Settings -> Developer settings -> Personal access tokens -> Fine-grained tokens:

| Permission | Level |
|------------|-------|
| Pull requests | Read & Write |
| Contents | Read |

**Can't:** Delete repos, push code, delete branches, manage settings.

### Configure & Allowlist

```bash
export GH_TOKEN="github_pat_xxxx"
```

Add to `.claude/settings.json`:
```json
{
  "permissions": {
    "allow": [
      "Bash(gh repo view:*)",
      "Bash(gh pr view:*)",
      "Bash(gh pr create:*)",
      "Bash(gh pr ready:*)",
      "Bash(gh pr edit:*)",
      "Bash(gh api repos/*/*/pulls/*/comments:*)",
      "Bash(gh api repos/*/*/pulls/*/comments/*/replies:*)"
    ]
  }
}
```

## Quick Reference

| Operation | Command |
|-----------|---------|
| Get owner/repo | `gh repo view --json owner,name -q '"\(.owner.login)/\(.name)"'` |
| Get PR number | `gh pr view --json number -q .number` |
| Get PR author | `gh pr view --json author -q .author.login` |
| Fetch all review comments | `gh api repos/{owner}/{repo}/pulls/{pr}/comments --paginate` |
| Get single comment | `gh api repos/{owner}/{repo}/pulls/comments/{comment_id}` |
| Reply to comment | `gh api repos/{owner}/{repo}/pulls/{pr}/comments/{comment_id}/replies -f body="msg"` |
| Create PR | `gh pr create --title "T" --body "B" [--draft]` |
| Mark ready | `gh pr ready [number]` |
| Convert to draft | `gh pr ready --undo [number]` |
| Edit PR | `gh pr edit [number] --title "T" --body "B"` |

## Workflow: Respond to PR Review

### 1. Get repo info and PR details

```bash
owner_repo=$(gh repo view --json owner,name -q '"\(.owner.login)/\(.name)"')
pr_number=$(gh pr view --json number -q .number)
pr_author=$(gh pr view --json author -q .author.login)
```

### 2. Fetch and analyze threads

```bash
# Fetch all comments and group into threads, showing last author per thread
gh api repos/${owner_repo}/pulls/${pr_number}/comments --paginate | jq 'sort_by([.in_reply_to_id // .id, .created_at]) | group_by(.in_reply_to_id // .id) | map({thread_id: (.[0].in_reply_to_id // .[0].id), path: .[0].path, line: (.[0].line // .[0].original_line), last_author: .[-1].user.login, last_body: .[-1].body[0:100], count: length})'
```

### 3. Filter to threads needing response

```bash
# Filter to threads where last_author != PR author
# Note: Use '| not' instead of '!=' to avoid shell escaping issues with !
... | jq --arg author "$pr_author" '[.[] | select(.last_author == $author | not)]'
```

For each thread needing response:
- Read the comment + file/line context
- Apply `superpowers:receiving-code-review` skill for evaluation
- Fix code and/or reply to thread

### 4. Commit fixes and push
- run the build, tests, linting as required
- commit the changes, noting the commit sha
- push the changes so they're visible
- We need to do this FIRST so we have the commit shas to put into the replies to the pr review

### 5. Re-fetch comment IDs (if rebased)

**Important:** If you rebased or force-pushed, comment IDs may have changed. Re-fetch the comment threads before replying:

```bash
gh api repos/${owner_repo}/pulls/${pr_number}/comments --paginate | jq '...'
```

### 6. Reply to a thread

```bash
gh api repos/${owner_repo}/pulls/${pr_number}/comments/{comment_id}/replies \
  -f body="Fixed in commit abc123. [description of fix]"
```

### 7. Summarize and finish

After all threads addressed, ask if ready to mark PR ready for review.

**Note:** REST API doesn't expose "resolved" status. We infer "done" when PR author made last comment in thread.

## Common Mistakes

| Mistake | Fix |
|---------|-----|
| Broad PAT permissions | Use fine-grained PAT with only Pull requests + Contents |
| Missing pagination | Always use `--paginate` for comment fetching |
| Top-level reply | Use `/comments/{id}/replies` endpoint, not `/comments` |
| Re-responding to threads | Skip threads where PR author made last comment |
| Forgetting to reply after fix | Always reply to confirm the fix was made |
| jq `!=` fails with shell error | Use `select(.x == "y" \| not)` instead of `select(.x != "y")` |
| 404 on reply after rebase | Comment IDs change after force-push/rebase. Re-fetch comments before replying |

ARGUMENTS: 185

---

did we fix the logger.go comment?

---

we fail build ðŸ˜­