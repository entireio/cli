{"type":"file-history-snapshot","messageId":"4ad5c823-ce61-4d09-8d9e-8f1752f2c634","snapshot":{"messageId":"4ad5c823-ce61-4d09-8d9e-8f1752f2c634","trackedFileBackups":{},"timestamp":"2026-02-09T05:36:50.466Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:startup","command":"bash ${CLAUDE_PROJECT_DIR}/.claude/scripts/remote-setup.sh"},"parentToolUseID":"a97e91ba-b66a-48b7-a5c9-a779950f9978","toolUseID":"a97e91ba-b66a-48b7-a5c9-a779950f9978","timestamp":"2026-02-09T05:36:12.934Z","uuid":"c2c367f9-1ee9-4db0-8f15-45411732bffc"}
{"parentUuid":"c2c367f9-1ee9-4db0-8f15-45411732bffc","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:startup","command":"entire hooks claude-code session-start"},"parentToolUseID":"a97e91ba-b66a-48b7-a5c9-a779950f9978","toolUseID":"a97e91ba-b66a-48b7-a5c9-a779950f9978","timestamp":"2026-02-09T05:36:12.936Z","uuid":"4941c275-a9a7-4870-9d0c-57882b893e0a"}
{"parentUuid":"4941c275-a9a7-4870-9d0c-57882b893e0a","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","type":"user","message":{"role":"user","content":"I'm rebasing my single commit onto another branch.  That's already in progress.  The conflict resolution shouldn't be too hard, please take a look"},"uuid":"4ad5c823-ce61-4d09-8d9e-8f1752f2c634","timestamp":"2026-02-09T05:36:50.297Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"4ad5c823-ce61-4d09-8d9e-8f1752f2c634","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","message":{"model":"claude-opus-4-6","id":"msg_01DHfQgpa3KJ7g2zbUoHtfKi","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":8214,"cache_read_input_tokens":18338,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8214},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxHgMmqyTXuHd4E71Tp","type":"assistant","uuid":"3dcc952e-225e-4c3a-9267-9cfa6a643e23","timestamp":"2026-02-09T05:36:56.047Z"}
{"parentUuid":"3dcc952e-225e-4c3a-9267-9cfa6a643e23","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","message":{"model":"claude-opus-4-6","id":"msg_01DHfQgpa3KJ7g2zbUoHtfKi","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user is in the middle of a rebase and has a merge conflict in `cmd/entire/cli/setup.go`. Let me look at the current state of the files to understand the conflict.","signature":"Es8CCkYICxgCKkA7dbOD3LNN9TYx6B7D4wDlkgorEbDTh7BzmSD9kv+MzikRscybeQioxAMXVOn42wC00TZ/Flm8WIPpaDhQK+agEgw6YYShBQSZB+iX93oaDBxA8+fzE0XyinUJ4iIw3ff/2NmSsVOHIzuN2NKZygM7rITXurOjWUQ0IA5ZaedeP5pESo24uCwPpPF9025FKrYBAdUAxga/XrYuKJqf7QB+bntbZUOgbMiVSDcE5gToXNpOeOeV5rfbd9QOqI8yiAeaLv5uMgNyCVvICsgVDRKDFkgVZS/8ysbQtSyKhv+ukVDCK/3Zv48KQfKHXuVO6PZDh4h4lLPaQ1Gp3A+bmEcKsMbHQ5qYKShVTGzCcNFMIcxVTmCiPlmrpeLJtAkrR1yuSGCgNhOOJpUv6Rmbijyh0wbVY1g8CiWujl++axVknD586YiGEl0YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":8214,"cache_read_input_tokens":18338,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8214},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxHgMmqyTXuHd4E71Tp","type":"assistant","uuid":"975f2165-4aae-4c44-8aea-6d801d5e8953","timestamp":"2026-02-09T05:36:56.944Z"}
{"parentUuid":"975f2165-4aae-4c44-8aea-6d801d5e8953","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","message":{"model":"claude-opus-4-6","id":"msg_01DHfQgpa3KJ7g2zbUoHtfKi","type":"message","role":"assistant","content":[{"type":"text","text":"Let me look at the conflict and the current state of the files."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":8214,"cache_read_input_tokens":18338,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8214},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxHgMmqyTXuHd4E71Tp","type":"assistant","uuid":"97a1ff7c-66b5-48b8-bff5-85a3b0538843","timestamp":"2026-02-09T05:36:57.361Z"}
{"parentUuid":"97a1ff7c-66b5-48b8-bff5-85a3b0538843","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","message":{"model":"claude-opus-4-6","id":"msg_01DHfQgpa3KJ7g2zbUoHtfKi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F6WP8RhVpQKC1vo9EfYGoF","name":"Bash","input":{"command":"git status","description":"Check git status during rebase"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":8214,"cache_read_input_tokens":18338,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8214},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxHgMmqyTXuHd4E71Tp","type":"assistant","uuid":"62c84c68-825b-4220-ae02-61d36ea485cf","timestamp":"2026-02-09T05:36:58.604Z"}
{"parentUuid":"62c84c68-825b-4220-ae02-61d36ea485cf","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01DHfQgpa3KJ7g2zbUoHtfKi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DAuR64F1HzVz9yAR3uRofA","name":"Read","input":{"file_path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":8214,"cache_read_input_tokens":18338,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":8214},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxHgMmqyTXuHd4E71Tp","type":"assistant","uuid":"6f7ac7a4-23cc-4103-bdd6-69b36b5dddbc","timestamp":"2026-02-09T05:36:59.135Z"}
{"parentUuid":"62c84c68-825b-4220-ae02-61d36ea485cf","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F6WP8RhVpQKC1vo9EfYGoF","type":"tool_result","content":"interactive rebase in progress; onto 50cf262\nLast command done (1 command done):\n   pick b6ff09d # Add versioned stanza management for shell completion\nNo commands remaining.\nYou are currently rebasing branch 'cli-completion-updater' on '50cf262'.\n  (fix conflicts and then run \"git rebase --continue\")\n  (use \"git rebase --skip\" to skip this patch)\n  (use \"git rebase --abort\" to check out the original branch)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   cmd/entire/cli/setup_test.go\n\nUnmerged paths:\n  (use \"git restore --staged <file>...\" to unstage)\n  (use \"git add <file>...\" to mark resolution)\n\tboth modified:   cmd/entire/cli/setup.go","is_error":false}]},"uuid":"d5cead52-9d4a-4323-80c8-f569e96be036","timestamp":"2026-02-09T05:36:59.208Z","toolUseResult":{"stdout":"interactive rebase in progress; onto 50cf262\nLast command done (1 command done):\n   pick b6ff09d # Add versioned stanza management for shell completion\nNo commands remaining.\nYou are currently rebasing branch 'cli-completion-updater' on '50cf262'.\n  (fix conflicts and then run \"git rebase --continue\")\n  (use \"git rebase --skip\" to skip this patch)\n  (use \"git rebase --abort\" to check out the original branch)\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   cmd/entire/cli/setup_test.go\n\nUnmerged paths:\n  (use \"git restore --staged <file>...\" to unstage)\n  (use \"git add <file>...\" to mark resolution)\n\tboth modified:   cmd/entire/cli/setup.go","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"62c84c68-825b-4220-ae02-61d36ea485cf"}
{"parentUuid":"d5cead52-9d4a-4323-80c8-f569e96be036","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01DAuR64F1HzVz9yAR3uRofA","toolUseID":"toolu_01DAuR64F1HzVz9yAR3uRofA","timestamp":"2026-02-09T05:36:59.598Z","uuid":"482822e9-c61f-429c-ad6a-96a7fa82eb49"}
{"parentUuid":"6f7ac7a4-23cc-4103-bdd6-69b36b5dddbc","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DAuR64F1HzVz9yAR3uRofA","type":"tool_result","content":"     1→package cli\n     2→\n     3→import (\n     4→\t\"context\"\n     5→\t\"errors\"\n     6→\t\"fmt\"\n     7→\t\"io\"\n     8→\t\"os\"\n     9→\t\"path/filepath\"\n    10→\t\"strings\"\n    11→\n    12→\t\"github.com/entireio/cli/cmd/entire/cli/agent\"\n    13→\t\"github.com/entireio/cli/cmd/entire/cli/paths\"\n    14→\t\"github.com/entireio/cli/cmd/entire/cli/session\"\n    15→\t\"github.com/entireio/cli/cmd/entire/cli/strategy\"\n    16→\n    17→\t\"github.com/charmbracelet/huh\"\n    18→\t\"github.com/spf13/cobra\"\n    19→)\n    20→\n    21→// Strategy display names for user-friendly selection\n    22→const (\n    23→\tstrategyDisplayManualCommit = \"manual-commit\"\n    24→\tstrategyDisplayAutoCommit   = \"auto-commit\"\n    25→)\n    26→\n    27→// strategyDisplayToInternal maps user-friendly names to internal strategy names\n    28→var strategyDisplayToInternal = map[string]string{\n    29→\tstrategyDisplayManualCommit: strategy.StrategyNameManualCommit,\n    30→\tstrategyDisplayAutoCommit:   strategy.StrategyNameAutoCommit,\n    31→}\n    32→\n    33→// strategyInternalToDisplay maps internal strategy names to user-friendly names\n    34→var strategyInternalToDisplay = map[string]string{\n    35→\tstrategy.StrategyNameManualCommit: strategyDisplayManualCommit,\n    36→\tstrategy.StrategyNameAutoCommit:   strategyDisplayAutoCommit,\n    37→}\n    38→\n    39→func newEnableCmd() *cobra.Command {\n    40→\tvar localDev bool\n    41→\tvar ignoreUntracked bool\n    42→\tvar useLocalSettings bool\n    43→\tvar useProjectSettings bool\n    44→\tvar agentName string\n    45→\tvar strategyFlag string\n    46→\tvar forceHooks bool\n    47→\tvar skipPushSessions bool\n    48→\tvar telemetry bool\n    49→\n    50→\tcmd := &cobra.Command{\n    51→\t\tUse:   \"enable\",\n    52→\t\tShort: \"Enable Entire\",\n    53→\t\tLong: `Enable Entire with session tracking for your AI agent workflows.\n    54→\n    55→Uses the manual-commit strategy by default. To use a different strategy:\n    56→\n    57→  entire enable --strategy auto-commit\n    58→\n    59→Strategies: manual-commit (default), auto-commit`,\n    60→\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n    61→\t\t\t// Check if we're in a git repository first - this is a prerequisite error,\n    62→\t\t\t// not a usage error, so we silence Cobra's output and use SilentError\n    63→\t\t\t// to prevent duplicate error output in main.go\n    64→\t\t\tif _, err := paths.RepoRoot(); err != nil {\n    65→\t\t\t\tcmd.SilenceUsage = true\n    66→\t\t\t\tcmd.SilenceErrors = true\n    67→\t\t\t\tfmt.Fprintln(cmd.ErrOrStderr(), \"Not a git repository. Please run 'entire enable' from within a git repository.\")\n    68→\t\t\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n    69→\t\t\t}\n    70→\n    71→\t\t\tif err := validateSetupFlags(useLocalSettings, useProjectSettings); err != nil {\n    72→\t\t\t\treturn err\n    73→\t\t\t}\n    74→\t\t\t// Non-interactive mode if --agent flag is provided\n    75→\t\t\tif agentName != \"\" {\n    76→\t\t\t\treturn setupAgentHooksNonInteractive(agent.AgentName(agentName), strategyFlag, localDev, forceHooks, skipPushSessions, telemetry)\n    77→\t\t\t}\n    78→\t\t\t// If strategy is specified via flag, skip interactive selection\n    79→\t\t\tif strategyFlag != \"\" {\n    80→\t\t\t\treturn runEnableWithStrategy(cmd.OutOrStdout(), strategyFlag, localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n    81→\t\t\t}\n    82→\t\t\treturn runEnableInteractive(cmd.OutOrStdout(), localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n    83→\t\t},\n    84→\t}\n    85→\n    86→\tcmd.Flags().BoolVar(&localDev, \"local-dev\", false, \"Use go run instead of entire binary for hooks\")\n    87→\tcmd.Flags().MarkHidden(\"local-dev\") //nolint:errcheck,gosec // flag is defined above\n    88→\tcmd.Flags().BoolVar(&ignoreUntracked, \"ignore-untracked\", false, \"Commit all new files without tracking pre-existing untracked files\")\n    89→\tcmd.Flags().MarkHidden(\"ignore-untracked\") //nolint:errcheck,gosec // flag is defined above\n    90→\tcmd.Flags().BoolVar(&useLocalSettings, \"local\", false, \"Write settings to settings.local.json instead of settings.json\")\n    91→\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Write settings to settings.json even if it already exists\")\n    92→\tcmd.Flags().StringVar(&agentName, \"agent\", \"\", \"Agent to setup hooks for (e.g., claude-code). Enables non-interactive mode.\")\n    93→\tcmd.Flags().StringVar(&strategyFlag, \"strategy\", \"\", \"Strategy to use (manual-commit or auto-commit)\")\n    94→\tcmd.Flags().BoolVarP(&forceHooks, \"force\", \"f\", false, \"Force reinstall hooks (removes existing Entire hooks first)\")\n    95→\tcmd.Flags().BoolVar(&skipPushSessions, \"skip-push-sessions\", false, \"Disable automatic pushing of session logs on git push\")\n    96→\tcmd.Flags().BoolVar(&telemetry, \"telemetry\", true, \"Enable anonymous usage analytics\")\n    97→\t//nolint:errcheck,gosec // completion is optional, flag is defined above\n    98→\tcmd.RegisterFlagCompletionFunc(\"strategy\", func(_ *cobra.Command, _ []string, _ string) ([]string, cobra.ShellCompDirective) {\n    99→\t\treturn []string{strategyDisplayManualCommit, strategyDisplayAutoCommit}, cobra.ShellCompDirectiveNoFileComp\n   100→\t})\n   101→\n   102→\t// Add subcommands for automation/testing\n   103→\tcmd.AddCommand(newSetupGitHookCmd())\n   104→\n   105→\treturn cmd\n   106→}\n   107→\n   108→func newDisableCmd() *cobra.Command {\n   109→\tvar useProjectSettings bool\n   110→\tvar uninstall bool\n   111→\tvar force bool\n   112→\n   113→\tcmd := &cobra.Command{\n   114→\t\tUse:   \"disable\",\n   115→\t\tShort: \"Disable Entire\",\n   116→\t\tLong: `Disable Entire temporarily. Hooks will exit silently and commands will show a disabled message.\n   117→\n   118→Use --uninstall to completely remove Entire from this repository, including:\n   119→  - .entire/ directory (settings, logs, metadata)\n   120→  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\n   121→  - Session state files (.git/entire-sessions/)\n   122→  - Shadow branches (entire/<hash>)\n   123→  - Agent hooks (Claude Code, Gemini CLI)`,\n   124→\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n   125→\t\t\tif uninstall {\n   126→\t\t\t\treturn runUninstall(cmd.OutOrStdout(), cmd.ErrOrStderr(), force)\n   127→\t\t\t}\n   128→\t\t\treturn runDisable(cmd.OutOrStdout(), useProjectSettings)\n   129→\t\t},\n   130→\t}\n   131→\n   132→\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Update settings.json instead of settings.local.json\")\n   133→\tcmd.Flags().BoolVar(&uninstall, \"uninstall\", false, \"Completely remove Entire from this repository\")\n   134→\tcmd.Flags().BoolVar(&force, \"force\", false, \"Skip confirmation prompt (use with --uninstall)\")\n   135→\n   136→\treturn cmd\n   137→}\n   138→\n   139→// runEnableWithStrategy enables Entire with a specified strategy (non-interactive).\n   140→// The selectedStrategy can be either a display name (manual-commit, auto-commit)\n   141→// or an internal name (manual-commit, auto-commit).\n   142→func runEnableWithStrategy(w io.Writer, selectedStrategy string, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n   143→\t// Map the strategy to internal name if it's a display name\n   144→\tinternalStrategy := selectedStrategy\n   145→\tif mapped, ok := strategyDisplayToInternal[selectedStrategy]; ok {\n   146→\t\tinternalStrategy = mapped\n   147→\t}\n   148→\n   149→\t// Validate the strategy exists\n   150→\tstrat, err := strategy.Get(internalStrategy)\n   151→\tif err != nil {\n   152→\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", selectedStrategy)\n   153→\t}\n   154→\n   155→\t// Setup Claude Code hooks\n   156→\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n   157→\tif err != nil {\n   158→\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n   159→\t}\n   160→\tif hooksInstalled > 0 {\n   161→\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n   162→\t} else {\n   163→\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n   164→\t}\n   165→\n   166→\t// Setup .entire directory\n   167→\tdirCreated, err := setupEntireDirectory()\n   168→\tif err != nil {\n   169→\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n   170→\t}\n   171→\tif dirCreated {\n   172→\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n   173→\t}\n   174→\n   175→\t// Load existing settings to preserve other options (like strategy_options.push)\n   176→\tsettings, err := LoadEntireSettings()\n   177→\tif err != nil {\n   178→\t\t// If we can't load, start with defaults\n   179→\t\tsettings = &EntireSettings{}\n   180→\t}\n   181→\t// Update the specific fields\n   182→\tsettings.Strategy = internalStrategy\n   183→\tsettings.LocalDev = localDev\n   184→\tsettings.Enabled = true\n   185→\n   186→\t// Set push_sessions option if --skip-push-sessions flag was provided\n   187→\tif skipPushSessions {\n   188→\t\tif settings.StrategyOptions == nil {\n   189→\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n   190→\t\t}\n   191→\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n   192→\t}\n   193→\n   194→\t// Handle telemetry for non-interactive mode\n   195→\t// Note: if telemetry is nil (not configured), it defaults to disabled\n   196→\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n   197→\t\tf := false\n   198→\t\tsettings.Telemetry = &f\n   199→\t}\n   200→\n   201→\t// Determine which settings file to write to\n   202→\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n   203→\tif err != nil {\n   204→\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n   205→\t}\n   206→\tshouldUseLocal, showNotification := determineSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n   207→\n   208→\tif showNotification {\n   209→\t\tfmt.Fprintln(w, \"Info: Project settings exist. Saving to settings.local.json instead.\")\n   210→\t\tfmt.Fprintln(w, \"  Use --project to update the project settings file.\")\n   211→\t}\n   212→\n   213→\tif shouldUseLocal {\n   214→\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n   215→\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n   216→\t\t}\n   217→\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n   218→\t} else {\n   219→\t\tif err := SaveEntireSettings(settings); err != nil {\n   220→\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n   221→\t\t}\n   222→\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n   223→\t}\n   224→\n   225→\t// Install git hooks (always reinstall to ensure they're up-to-date)\n   226→\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n   227→\tif err != nil {\n   228→\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n   229→\t}\n   230→\tif gitHooksInstalled > 0 {\n   231→\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n   232→\t} else {\n   233→\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n   234→\t}\n   235→\n   236→\t// Let the strategy handle its own setup requirements\n   237→\tif err := strat.EnsureSetup(); err != nil {\n   238→\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n   239→\t}\n   240→\n   241→\t// Show success message with display name\n   242→\tdisplayName := selectedStrategy\n   243→\tif dn, ok := strategyInternalToDisplay[internalStrategy]; ok {\n   244→\t\tdisplayName = dn\n   245→\t}\n   246→\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", displayName)\n   247→\n   248→\treturn nil\n   249→}\n   250→\n   251→// runEnableInteractive runs the interactive enable flow.\n   252→func runEnableInteractive(w io.Writer, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n   253→\t// Use the default strategy (manual-commit)\n   254→\tinternalStrategy := strategy.DefaultStrategyName\n   255→\tfmt.Fprintf(w, \"Using %s strategy (use --strategy to change)\\n\\n\", strategyInternalToDisplay[internalStrategy])\n   256→\n   257→\t// Setup Claude Code hooks\n   258→\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n   259→\tif err != nil {\n   260→\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n   261→\t}\n   262→\tif hooksInstalled > 0 {\n   263→\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n   264→\t} else {\n   265→\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n   266→\t}\n   267→\n   268→\t// Setup .entire directory\n   269→\tdirCreated, err := setupEntireDirectory()\n   270→\tif err != nil {\n   271→\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n   272→\t}\n   273→\tif dirCreated {\n   274→\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n   275→\t}\n   276→\n   277→\t// Load existing settings to preserve other options (like strategy_options.push)\n   278→\tsettings, err := LoadEntireSettings()\n   279→\tif err != nil {\n   280→\t\t// If we can't load, start with defaults\n   281→\t\tsettings = &EntireSettings{}\n   282→\t}\n   283→\t// Update the specific fields\n   284→\tsettings.Strategy = internalStrategy\n   285→\tsettings.LocalDev = localDev\n   286→\tsettings.Enabled = true\n   287→\n   288→\t// Set push_sessions option if --skip-push-sessions flag was provided\n   289→\tif skipPushSessions {\n   290→\t\tif settings.StrategyOptions == nil {\n   291→\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n   292→\t\t}\n   293→\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n   294→\t}\n   295→\n   296→\t// Ask about telemetry consent (only if not already asked)\n   297→\tif err := promptTelemetryConsent(settings, telemetry); err != nil {\n   298→\t\treturn fmt.Errorf(\"telemetry consent: %w\", err)\n   299→\t}\n   300→\n   301→\t// Determine which settings file to write to (interactive prompt if settings.json exists)\n   302→\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n   303→\tif err != nil {\n   304→\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n   305→\t}\n   306→\tshouldUseLocal, err := promptSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n   307→\tif err != nil {\n   308→\t\treturn err\n   309→\t}\n   310→\n   311→\tif shouldUseLocal {\n   312→\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n   313→\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n   314→\t\t}\n   315→\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n   316→\t} else {\n   317→\t\tif err := SaveEntireSettings(settings); err != nil {\n   318→\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n   319→\t\t}\n   320→\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n   321→\t}\n   322→\n   323→\t// Install git hooks (always reinstall to ensure they're up-to-date)\n   324→\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n   325→\tif err != nil {\n   326→\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n   327→\t}\n   328→\tif gitHooksInstalled > 0 {\n   329→\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n   330→\t} else {\n   331→\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n   332→\t}\n   333→\n   334→\t// Let the strategy handle its own setup requirements\n   335→\tstrat, err := strategy.Get(internalStrategy)\n   336→\tif err != nil {\n   337→\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n   338→\t}\n   339→\tif err := strat.EnsureSetup(); err != nil {\n   340→\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n   341→\t}\n   342→\n   343→\t// Show success message with display name\n   344→\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", strategyInternalToDisplay[internalStrategy])\n   345→\n   346→\treturn nil\n   347→}\n   348→\n   349→// runEnable is a simple enable that just sets the enabled flag (for programmatic use).\n   350→func runEnable(w io.Writer) error {\n   351→\tsettings, err := LoadEntireSettings()\n   352→\tif err != nil {\n   353→\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n   354→\t}\n   355→\n   356→\tsettings.Enabled = true\n   357→\tif err := SaveEntireSettings(settings); err != nil {\n   358→\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n   359→\t}\n   360→\n   361→\tfmt.Fprintln(w, \"Entire is now enabled.\")\n   362→\treturn nil\n   363→}\n   364→\n   365→func runDisable(w io.Writer, useProjectSettings bool) error {\n   366→\tsettings, err := LoadEntireSettings()\n   367→\tif err != nil {\n   368→\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n   369→\t}\n   370→\n   371→\tsettings.Enabled = false\n   372→\n   373→\t// If --project flag is specified, always write to project settings\n   374→\tif useProjectSettings {\n   375→\t\tif err := SaveEntireSettings(settings); err != nil {\n   376→\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n   377→\t\t}\n   378→\t} else {\n   379→\t\t// Always write to local settings file (create if doesn't exist)\n   380→\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n   381→\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n   382→\t\t}\n   383→\t}\n   384→\n   385→\tfmt.Fprintln(w, \"Entire is now disabled.\")\n   386→\treturn nil\n   387→}\n   388→\n   389→// DisabledMessage is the message shown when Entire is disabled\n   390→const DisabledMessage = \"Entire is disabled. Run `entire enable` to re-enable.\"\n   391→\n   392→// checkDisabledGuard checks if Entire is disabled and prints a message if so.\n   393→// Returns true if the caller should exit (i.e., Entire is disabled).\n   394→// On error reading settings, defaults to enabled (returns false).\n   395→func checkDisabledGuard(w io.Writer) bool {\n   396→\tenabled, err := IsEnabled()\n   397→\tif err != nil {\n   398→\t\t// Default to enabled on error\n   399→\t\treturn false\n   400→\t}\n   401→\tif !enabled {\n   402→\t\tfmt.Fprintln(w, DisabledMessage)\n   403→\t\treturn true\n   404→\t}\n   405→\treturn false\n   406→}\n   407→\n   408→// setupClaudeCodeHook sets up Claude Code hooks.\n   409→// This is a convenience wrapper that uses the agent package.\n   410→// Returns the number of hooks installed (0 if already installed).\n   411→func setupClaudeCodeHook(localDev, forceHooks bool) (int, error) {\n   412→\tag, err := agent.Get(agent.AgentNameClaudeCode)\n   413→\tif err != nil {\n   414→\t\treturn 0, fmt.Errorf(\"failed to get claude-code agent: %w\", err)\n   415→\t}\n   416→\n   417→\thookAgent, ok := ag.(agent.HookSupport)\n   418→\tif !ok {\n   419→\t\treturn 0, errors.New(\"claude-code agent does not support hooks\")\n   420→\t}\n   421→\n   422→\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n   423→\tif err != nil {\n   424→\t\treturn 0, fmt.Errorf(\"failed to install claude-code hooks: %w\", err)\n   425→\t}\n   426→\n   427→\treturn count, nil\n   428→}\n   429→\n   430→// setupAgentHooksNonInteractive sets up hooks for a specific agent non-interactively.\n   431→// If strategyName is provided, it sets the strategy; otherwise uses default.\n   432→func setupAgentHooksNonInteractive(agentName agent.AgentName, strategyName string, localDev, forceHooks, skipPushSessions, telemetry bool) error {\n   433→\tag, err := agent.Get(agentName)\n   434→\tif err != nil {\n   435→\t\treturn fmt.Errorf(\"unknown agent: %s\", agentName)\n   436→\t}\n   437→\n   438→\t// Check if agent supports hooks\n   439→\thookAgent, ok := ag.(agent.HookSupport)\n   440→\tif !ok {\n   441→\t\treturn fmt.Errorf(\"agent %s does not support hooks\", agentName)\n   442→\t}\n   443→\n   444→\t// Install hooks\n   445→\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n   446→\tif err != nil {\n   447→\t\treturn fmt.Errorf(\"failed to install hooks for %s: %w\", agentName, err)\n   448→\t}\n   449→\n   450→\tif count == 0 {\n   451→\t\tmsg := fmt.Sprintf(\"Hooks for %s already installed\", ag.Description())\n   452→\t\tif agentName == agent.AgentNameGemini {\n   453→\t\t\tmsg += \" - This is a work in progress\"\n   454→\t\t}\n   455→\t\tfmt.Println(msg)\n   456→\t} else {\n   457→\t\tmsg := fmt.Sprintf(\"Installed %d hooks for %s\", count, ag.Description())\n   458→\t\tif agentName == agent.AgentNameGemini {\n   459→\t\t\tmsg += \" - This is a work in progress\"\n   460→\t\t}\n   461→\t\tfmt.Println(msg)\n   462→\t}\n   463→\n   464→\t// Update settings to store the strategy\n   465→\tsettings, _ := LoadEntireSettings() //nolint:errcheck // settings defaults are fine\n   466→\tsettings.Enabled = true\n   467→\tif localDev {\n   468→\t\tsettings.LocalDev = localDev\n   469→\t}\n   470→\n   471→\t// Set push_sessions option if --skip-push-sessions flag was provided\n   472→\tif skipPushSessions {\n   473→\t\tif settings.StrategyOptions == nil {\n   474→\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n   475→\t\t}\n   476→\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n   477→\t}\n   478→\n   479→\t// Set strategy if provided\n   480→\tif strategyName != \"\" {\n   481→\t\t// Map display name to internal name if needed\n   482→\t\tinternalStrategy := strategyName\n   483→\t\tif mapped, ok := strategyDisplayToInternal[strategyName]; ok {\n   484→\t\t\tinternalStrategy = mapped\n   485→\t\t}\n   486→\t\t// Validate the strategy exists\n   487→\t\tif _, err := strategy.Get(internalStrategy); err != nil {\n   488→\t\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", strategyName)\n   489→\t\t}\n   490→\t\tsettings.Strategy = internalStrategy\n   491→\t}\n   492→\n   493→\t// Handle telemetry for non-interactive mode\n   494→\t// Note: if telemetry is nil (not configured), it defaults to disabled\n   495→\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n   496→\t\tf := false\n   497→\t\tsettings.Telemetry = &f\n   498→\t}\n   499→\n   500→\tif err := SaveEntireSettings(settings); err != nil {\n   501→\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n   502→\t}\n   503→\n   504→\t// Install git hooks (always reinstall to ensure they're up-to-date)\n   505→\tif _, err := strategy.InstallGitHook(true); err != nil {\n   506→\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n   507→\t}\n   508→\n   509→\t// Let the strategy handle its own setup requirements (creates entire/sessions branch, etc.)\n   510→\tstrat, err := strategy.Get(settings.Strategy)\n   511→\tif err != nil {\n   512→\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n   513→\t}\n   514→\tif err := strat.EnsureSetup(); err != nil {\n   515→\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n   516→\t}\n   517→\n   518→\treturn nil\n   519→}\n   520→\n   521→// validateSetupFlags checks that --local and --project flags are not both specified.\n   522→func validateSetupFlags(useLocal, useProject bool) error {\n   523→\tif useLocal && useProject {\n   524→\t\treturn errors.New(\"cannot specify both --project and --local\")\n   525→\t}\n   526→\treturn nil\n   527→}\n   528→\n   529→// determineSettingsTarget decides whether to write to settings.local.json based on:\n   530→// - Whether settings.json already exists\n   531→// - The --local and --project flags\n   532→// Returns (useLocal, showNotification).\n   533→func determineSettingsTarget(entireDir string, useLocal, useProject bool) (bool, bool) {\n   534→\t// Explicit --local flag always uses local settings\n   535→\tif useLocal {\n   536→\t\treturn true, false\n   537→\t}\n   538→\n   539→\t// Explicit --project flag always uses project settings\n   540→\tif useProject {\n   541→\t\treturn false, false\n   542→\t}\n   543→\n   544→\t// No flags specified - check if settings file exists\n   545→\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n   546→\tif _, err := os.Stat(settingsPath); err == nil {\n   547→\t\t// Settings file exists - auto-redirect to local with notification\n   548→\t\treturn true, true\n   549→\t}\n   550→\n   551→\t// Settings file doesn't exist - create it\n   552→\treturn false, false\n   553→}\n   554→\n   555→// Settings target options for interactive prompt\n   556→const (\n   557→\tsettingsTargetProject = \"project\"\n   558→\tsettingsTargetLocal   = \"local\"\n   559→)\n   560→\n   561→// promptSettingsTarget interactively asks the user where to save settings\n   562→// when settings.json already exists and no flags were provided.\n   563→// Returns (useLocal, error).\n   564→func promptSettingsTarget(entireDir string, useLocal, useProject bool) (bool, error) {\n   565→\t// Explicit --local flag always uses local settings\n   566→\tif useLocal {\n   567→\t\treturn true, nil\n   568→\t}\n   569→\n   570→\t// Explicit --project flag always uses project settings\n   571→\tif useProject {\n   572→\t\treturn false, nil\n   573→\t}\n   574→\n   575→\t// Check if settings file exists\n   576→\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n   577→\tif _, err := os.Stat(settingsPath); os.IsNotExist(err) {\n   578→\t\t// Settings file doesn't exist - create it (no prompt needed)\n   579→\t\treturn false, nil\n   580→\t}\n   581→\n   582→\t// Settings file exists - prompt user\n   583→\tvar selected string\n   584→\tform := NewAccessibleForm(\n   585→\t\thuh.NewGroup(\n   586→\t\t\thuh.NewSelect[string]().\n   587→\t\t\t\tTitle(\"Project settings already exist. Where should settings be saved?\").\n   588→\t\t\t\tOptions(\n   589→\t\t\t\t\thuh.NewOption(\"Update project settings (settings.json)\", settingsTargetProject),\n   590→\t\t\t\t\thuh.NewOption(\"Use local settings (settings.local.json, gitignored)\", settingsTargetLocal),\n   591→\t\t\t\t).\n   592→\t\t\t\tValue(&selected),\n   593→\t\t),\n   594→\t)\n   595→\n   596→\tif err := form.Run(); err != nil {\n   597→\t\treturn false, fmt.Errorf(\"selection cancelled: %w\", err)\n   598→\t}\n   599→\n   600→\treturn selected == settingsTargetLocal, nil\n   601→}\n   602→\n   603→// setupEntireDirectory creates the .entire directory and gitignore.\n   604→// Returns true if the directory was created, false if it already existed.\n   605→func setupEntireDirectory() (bool, error) {\n   606→\t// Get absolute path for the .entire directory\n   607→\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n   608→\tif err != nil {\n   609→\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n   610→\t}\n   611→\n   612→\t// Check if directory already exists\n   613→\tcreated := false\n   614→\tif _, err := os.Stat(entireDirAbs); os.IsNotExist(err) {\n   615→\t\tcreated = true\n   616→\t}\n   617→\n   618→\t// Create .entire directory\n   619→\t//nolint:gosec // G301: Project directory needs standard permissions for git\n   620→\tif err := os.MkdirAll(entireDirAbs, 0o755); err != nil {\n   621→\t\treturn false, fmt.Errorf(\"failed to create .entire directory: %w\", err)\n   622→\t}\n   623→\n   624→\t// Create/update .gitignore with all required entries\n   625→\tif err := strategy.EnsureEntireGitignore(); err != nil {\n   626→\t\treturn false, fmt.Errorf(\"failed to setup .gitignore: %w\", err)\n   627→\t}\n   628→\n   629→\treturn created, nil\n   630→}\n   631→\n   632→// setupGitHook installs the prepare-commit-msg hook for context trailers.\n   633→func setupGitHook() error {\n   634→\t// Use shared implementation from strategy package\n   635→\t// The localDev setting is read from settings.json\n   636→\t_, err := strategy.InstallGitHook(false) // not silent - show output during setup\n   637→\tif err != nil {\n   638→\t\treturn fmt.Errorf(\"failed to install git hook: %w\", err)\n   639→\t}\n   640→\treturn nil\n   641→}\n   642→\n   643→// newSetupGitHookCmd creates the standalone git-hook setup command\n   644→func newSetupGitHookCmd() *cobra.Command {\n   645→\tcmd := &cobra.Command{\n   646→\t\tUse:    \"git-hook\",\n   647→\t\tShort:  \"Install git hook for session context trailers\",\n   648→\t\tHidden: true, // Hidden as it's mainly for testing\n   649→\t\tRunE: func(_ *cobra.Command, _ []string) error {\n   650→\t\t\treturn setupGitHook()\n   651→\t\t},\n   652→\t}\n   653→\n   654→\treturn cmd\n   655→}\n   656→\n   657→func newCurlBashPostInstallCmd() *cobra.Command {\n   658→\treturn &cobra.Command{\n   659→\t\tUse:    \"curl-bash-post-install\",\n   660→\t\tShort:  \"Post-install tasks for curl|bash installer\",\n   661→\t\tHidden: true,\n   662→\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n   663→\t\t\tw := cmd.OutOrStdout()\n   664→\t\t\tif err := promptShellCompletion(w); err != nil {\n   665→\t\t\t\tfmt.Fprintf(w, \"Note: Shell completion setup skipped: %v\\n\", err)\n   666→\t\t\t}\n   667→\t\t\treturn nil\n   668→\t\t},\n   669→\t}\n   670→}\n   671→\n   672→// Shell completion stanza management.\n   673→// The stanza is a versioned, delimited block written to ~/.zshrc or ~/.bashrc:\n   674→//\n   675→//\t# Entire CLI completions (v1) {{{\n   676→//\tautoload -Uz compinit && compinit && source <(entire completion zsh)\n   677→//\t# }}}\n   678→const (\n   679→\tshellCompletionStanzaVersion = 1\n   680→\tshellCompletionOpenFormat    = \"# Entire CLI completions (v%d) {{{\"\n   681→\tshellCompletionClose         = \"# }}}\"\n   682→\tshellCompletionLegacyComment = \"# Entire CLI shell completion\" // old format for migration\n   683→)\n   684→\n   685→type stanzaStatus int\n   686→\n   687→const (\n   688→\tstanzaNotFound stanzaStatus = iota\n   689→\tstanzaCurrent\n   690→\tstanzaOutdated\n   691→\tstanzaLegacy\n   692→)\n   693→\n   694→var (\n   695→\terrStanzaCorrupted = errors.New(\"shell completion block is corrupted (missing closing marker)\")\n   696→\terrMultipleStanzas = errors.New(\"found multiple shell completion blocks\")\n   697→)\n   698→\n   699→// findStanzaVersion scans content for the opening stanza marker and returns\n   700→// the version number. Returns 0 if no stanza is found.\n   701→func findStanzaVersion(content string) int {\n   702→\tfor line := range strings.SplitSeq(content, \"\\n\") {\n   703→\t\ttrimmed := strings.TrimSpace(line)\n   704→\t\tvar version int\n   705→\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n   706→\t\t\treturn version\n   707→\t\t}\n   708→\t}\n   709→\treturn 0\n   710→}\n   711→\n   712→// checkStanzaStatus determines the status of the shell completion stanza in content.\n   713→func checkStanzaStatus(content string, currentVersion int) stanzaStatus {\n   714→\tversion := findStanzaVersion(content)\n   715→\tif version > 0 {\n   716→\t\tif version >= currentVersion {\n   717→\t\t\treturn stanzaCurrent\n   718→\t\t}\n   719→\t\treturn stanzaOutdated\n   720→\t}\n   721→\tif strings.Contains(content, shellCompletionLegacyComment) {\n   722→\t\treturn stanzaLegacy\n   723→\t}\n   724→\treturn stanzaNotFound\n   725→}\n   726→\n   727→// buildStanza constructs the full stanza block for the given version and completion line.\n   728→func buildStanza(version int, completionLine string) string {\n   729→\treturn fmt.Sprintf(shellCompletionOpenFormat, version) + \"\\n\" + completionLine + \"\\n\" + shellCompletionClose\n   730→}\n   731→\n   732→// countStanzaOpeners counts how many opening stanza markers exist in content.\n   733→func countStanzaOpeners(content string) int {\n   734→\tcount := 0\n   735→\tfor line := range strings.SplitSeq(content, \"\\n\") {\n   736→\t\ttrimmed := strings.TrimSpace(line)\n   737→\t\tvar version int\n   738→\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n   739→\t\t\tcount++\n   740→\t\t}\n   741→\t}\n   742→\treturn count\n   743→}\n   744→\n   745→// replaceStanza finds the open+close markers in content and replaces the block\n   746→// with a new stanza. Returns errStanzaCorrupted if open found without close,\n   747→// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n   748→// no stanza found.\n   749→func replaceStanza(content string, version int, completionLine string) (string, error) {\n   750→\topenerCount := countStanzaOpeners(content)\n   751→\tif openerCount == 0 {\n   752→\t\treturn content, nil\n   753→\t}\n   754→\tif openerCount > 1 {\n   755→\t\treturn content, errMultipleStanzas\n   756→\t}\n   757→\n   758→\tlines := strings.Split(content, \"\\n\")\n   759→\topenIdx := -1\n   760→\tcloseIdx := -1\n   761→\tfor i, line := range lines {\n   762→\t\ttrimmed := strings.TrimSpace(line)\n   763→\t\tvar v int\n   764→\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n   765→\t\t\topenIdx = i\n   766→\t\t}\n   767→\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n   768→\t\t\tcloseIdx = i\n   769→\t\t\tbreak\n   770→\t\t}\n   771→\t}\n   772→\n   773→\tif openIdx >= 0 && closeIdx < 0 {\n   774→\t\treturn content, errStanzaCorrupted\n   775→\t}\n   776→\n   777→\tnewStanza := buildStanza(version, completionLine)\n   778→\tvar result []string\n   779→\tresult = append(result, lines[:openIdx]...)\n   780→\tresult = append(result, newStanza)\n   781→\tresult = append(result, lines[closeIdx+1:]...)\n   782→\treturn strings.Join(result, \"\\n\"), nil\n   783→}\n   784→\n   785→// removeStanza finds and removes the stanza block from content.\n   786→// Returns errStanzaCorrupted if open found without close,\n   787→// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n   788→// no stanza found.\n   789→func removeStanza(content string) (string, error) {\n   790→\topenerCount := countStanzaOpeners(content)\n   791→\tif openerCount == 0 {\n   792→\t\treturn content, nil\n   793→\t}\n   794→\tif openerCount > 1 {\n   795→\t\treturn content, errMultipleStanzas\n   796→\t}\n   797→\n   798→\tlines := strings.Split(content, \"\\n\")\n   799→\topenIdx := -1\n   800→\tcloseIdx := -1\n   801→\tfor i, line := range lines {\n   802→\t\ttrimmed := strings.TrimSpace(line)\n   803→\t\tvar v int\n   804→\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n   805→\t\t\topenIdx = i\n   806→\t\t}\n   807→\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n   808→\t\t\tcloseIdx = i\n   809→\t\t\tbreak\n   810→\t\t}\n   811→\t}\n   812→\n   813→\tif openIdx >= 0 && closeIdx < 0 {\n   814→\t\treturn content, errStanzaCorrupted\n   815→\t}\n   816→\n   817→\tvar result []string\n   818→\tresult = append(result, lines[:openIdx]...)\n   819→\t// Skip blank line immediately after stanza if present\n   820→\ttail := lines[closeIdx+1:]\n   821→\tif len(tail) > 0 && strings.TrimSpace(tail[0]) == \"\" {\n   822→\t\ttail = tail[1:]\n   823→\t}\n   824→\tresult = append(result, tail...)\n   825→\treturn strings.Join(result, \"\\n\"), nil\n   826→}\n   827→\n   828→// removeLegacyCompletion removes the old-format comment and its following\n   829→// completion line from content. Returns the modified content and whether\n   830→// anything was removed.\n   831→func removeLegacyCompletion(content, completionLine string) (string, bool) {\n   832→\tlines := strings.Split(content, \"\\n\")\n   833→\tvar result []string\n   834→\tremoved := false\n   835→\tfor i := 0; i < len(lines); i++ {\n   836→\t\tif strings.TrimSpace(lines[i]) == shellCompletionLegacyComment {\n   837→\t\t\t// Remove the comment line and the next line if it matches the completion line\n   838→\t\t\tif i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == completionLine {\n   839→\t\t\t\ti++ // skip next line too\n   840→\t\t\t}\n   841→\t\t\tremoved = true\n   842→\t\t\tcontinue\n   843→\t\t}\n   844→\t\tresult = append(result, lines[i])\n   845→\t}\n   846→\tif !removed {\n   847→\t\treturn content, false\n   848→\t}\n   849→\treturn strings.Join(result, \"\\n\"), true\n   850→}\n   851→\n   852→// errUnsupportedShell is returned when the user's shell is not supported for completion.\n   853→var errUnsupportedShell = errors.New(\"unsupported shell\")\n   854→\n   855→// shellCompletionTarget returns the rc file path and completion lines for the\n   856→// user's current shell.\n   857→func shellCompletionTarget() (shellName, rcFile, completionLine string, err error) {\n   858→\thome, err := os.UserHomeDir()\n   859→\tif err != nil {\n   860→\t\treturn \"\", \"\", \"\", fmt.Errorf(\"cannot determine home directory: %w\", err)\n   861→\t}\n   862→\n   863→\tshell := os.Getenv(\"SHELL\")\n   864→\tswitch {\n   865→\tcase strings.Contains(shell, \"zsh\"):\n   866→\t\treturn \"Zsh\",\n   867→\t\t\tfilepath.Join(home, \".zshrc\"),\n   868→\t\t\t\"source <(entire completion zsh)\",\n   869→\t\t\tnil\n   870→\tcase strings.Contains(shell, \"bash\"):\n   871→\t\treturn \"Bash\",\n   872→\t\t\tfilepath.Join(home, \".bashrc\"),\n   873→\t\t\t\"source <(entire completion bash)\",\n   874→\t\t\tnil\n   875→\tcase strings.Contains(shell, \"fish\"):\n   876→\t\treturn \"Fish\",\n   877→\t\t\tfilepath.Join(home, \".config\", \"fish\", \"config.fish\"),\n   878→\t\t\t\"entire completion fish | source\",\n   879→\t\t\tnil\n   880→\tdefault:\n   881→\t\treturn \"\", \"\", \"\", errUnsupportedShell\n   882→\t}\n   883→}\n   884→\n   885→// promptShellCompletion offers to add shell completion to the user's rc file.\n   886→// Handles versioned stanza detection, updates, and legacy migration.\n   887→func promptShellCompletion(w io.Writer) error {\n   888→\tshellName, rcFile, completionLine, err := shellCompletionTarget()\n   889→\tif err != nil {\n   890→\t\tif errors.Is(err, errUnsupportedShell) {\n   891→\t\t\tfmt.Fprintf(w, \"Note: Shell completion not available for your shell. Supported: zsh, bash, fish.\\n\")\n   892→\t\t\treturn nil\n   893→\t\t}\n   894→\t\treturn fmt.Errorf(\"shell completion: %w\", err)\n   895→\t}\n   896→\n   897→<<<<<<< HEAD\n   898→\tif isCompletionConfigured(rcFile) {\n   899→\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n   900→\t\treturn nil\n   901→||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n   902→\tif isCompletionConfigured(rcFile, completionLine) {\n   903→\t\treturn nil\n   904→=======\n   905→\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n   906→\tcontent, err := os.ReadFile(rcFile)\n   907→\tif err != nil && !os.IsNotExist(err) {\n   908→\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n   909→>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n   910→\t}\n   911→\n   912→\tstatus := checkStanzaStatus(string(content), shellCompletionStanzaVersion)\n   913→\tswitch status {\n   914→\tcase stanzaCurrent:\n   915→\t\treturn nil\n   916→\n   917→\tcase stanzaOutdated:\n   918→\t\tif !promptYesNo(\"Shell completion is outdated. Update?\") {\n   919→\t\t\treturn nil\n   920→\t\t}\n   921→\t\t// Re-read in case file changed\n   922→\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n   923→\t\tcontent, err = os.ReadFile(rcFile)\n   924→\t\tif err != nil {\n   925→\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n   926→\t\t}\n   927→\t\tupdated, replaceErr := replaceStanza(string(content), shellCompletionStanzaVersion, completionLine)\n   928→\t\tif replaceErr != nil {\n   929→\t\t\tfmt.Fprintf(w, \"Warning: %v in %s. Please fix manually.\\n\", replaceErr, rcFile)\n   930→\t\t\treturn nil\n   931→\t\t}\n   932→\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n   933→\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n   934→\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n   935→\t\t}\n   936→\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n   937→\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n   938→\t\treturn nil\n   939→\n   940→\tcase stanzaLegacy:\n   941→\t\tif !promptYesNo(\"Shell completion uses old format. Update?\") {\n   942→\t\t\treturn nil\n   943→\t\t}\n   944→\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n   945→\t\tcontent, err = os.ReadFile(rcFile)\n   946→\t\tif err != nil {\n   947→\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n   948→\t\t}\n   949→\t\tupdated, _ := removeLegacyCompletion(string(content), completionLine)\n   950→\t\tupdated = updated + \"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\"\n   951→\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n   952→\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n   953→\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n   954→\t\t}\n   955→\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n   956→\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n   957→\t\treturn nil\n   958→\n   959→\tcase stanzaNotFound:\n   960→\t\tif !promptYesNo(\"Enable shell completion?\") {\n   961→\t\t\treturn nil\n   962→\t\t}\n   963→\t\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n   964→\t\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n   965→\t\t}\n   966→\t\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n   967→\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n   968→\t}\n   969→\n   970→\treturn nil\n   971→}\n   972→\n   973→// promptYesNo shows a yes/no selection prompt and returns whether the user chose yes.\n   974→func promptYesNo(title string) bool {\n   975→\tvar selected string\n   976→\tform := NewAccessibleForm(\n   977→\t\thuh.NewGroup(\n   978→\t\t\thuh.NewSelect[string]().\n   979→<<<<<<< HEAD\n   980→\t\t\t\tTitle(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)).\n   981→||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n   982→\t\t\t\tTitle(\"Enable shell completion?\").\n   983→=======\n   984→\t\t\t\tTitle(title).\n   985→>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n   986→\t\t\t\tOptions(\n   987→\t\t\t\t\thuh.NewOption(\"Yes\", \"yes\"),\n   988→\t\t\t\t\thuh.NewOption(\"No\", \"no\"),\n   989→\t\t\t\t).\n   990→\t\t\t\tValue(&selected),\n   991→\t\t),\n   992→\t)\n   993→\n   994→\tif err := form.Run(); err != nil {\n   995→\t\treturn false // User cancelled\n   996→\t}\n   997→<<<<<<< HEAD\n   998→\n   999→\tif selected != \"yes\" {\n  1000→\t\treturn nil\n  1001→\t}\n  1002→\n  1003→\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n  1004→\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n  1005→\t}\n  1006→\n  1007→\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n  1008→\tfmt.Fprintln(w, \"  Restart your shell to activate\")\n  1009→\n  1010→\treturn nil\n  1011→||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n  1012→\n  1013→\tif selected != \"yes\" {\n  1014→\t\treturn nil\n  1015→\t}\n  1016→\n  1017→\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n  1018→\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n  1019→\t}\n  1020→\n  1021→\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n  1022→\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n  1023→\n  1024→\treturn nil\n  1025→=======\n  1026→\treturn selected == \"yes\"\n  1027→>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n  1028→}\n  1029→\n  1030→<<<<<<< HEAD\n  1031→// isCompletionConfigured checks if shell completion is already in the rc file.\n  1032→func isCompletionConfigured(rcFile string) bool {\n  1033→\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n  1034→\tcontent, err := os.ReadFile(rcFile)\n  1035→\tif err != nil {\n  1036→\t\treturn false // File doesn't exist or can't read, treat as not configured\n  1037→\t}\n  1038→\treturn strings.Contains(string(content), \"entire completion\")\n  1039→}\n  1040→\n  1041→// appendShellCompletion adds the completion line to the rc file.\n  1042→||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n  1043→// isCompletionConfigured checks if shell completion is already in the rc file.\n  1044→func isCompletionConfigured(rcFile string, completionLine string) bool {\n  1045→\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n  1046→\tcontent, err := os.ReadFile(rcFile)\n  1047→\tif err != nil {\n  1048→\t\treturn false // File doesn't exist or can't read, treat as not configured\n  1049→\t}\n  1050→\treturn strings.Contains(string(content), completionLine)\n  1051→}\n  1052→\n  1053→// appendShellCompletion adds the completion line to the rc file.\n  1054→=======\n  1055→// appendShellCompletion adds the completion stanza to the rc file.\n  1056→>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n  1057→func appendShellCompletion(rcFile, completionLine string) error {\n  1058→\tif err := os.MkdirAll(filepath.Dir(rcFile), 0o755); err != nil {\n  1059→\t\treturn fmt.Errorf(\"creating directory: %w\", err)\n  1060→\t}\n  1061→\t//nolint:gosec // G302: Shell rc files need 0644 for user readability\n  1062→\tf, err := os.OpenFile(rcFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)\n  1063→\tif err != nil {\n  1064→\t\treturn fmt.Errorf(\"opening file: %w\", err)\n  1065→\t}\n  1066→\tdefer f.Close()\n  1067→\n  1068→\t_, err = f.WriteString(\"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\")\n  1069→\tif err != nil {\n  1070→\t\treturn fmt.Errorf(\"writing completion: %w\", err)\n  1071→\t}\n  1072→\treturn nil\n  1073→}\n  1074→\n  1075→// removeShellCompletion removes the shell completion stanza (or legacy format)\n  1076→// from the user's rc file. Used during uninstall.\n  1077→func removeShellCompletion() error {\n  1078→\trcFile, completionLine := shellCompletionTarget()\n  1079→\tif rcFile == \"\" {\n  1080→\t\treturn nil\n  1081→\t}\n  1082→\n  1083→\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n  1084→\tcontent, err := os.ReadFile(rcFile)\n  1085→\tif err != nil {\n  1086→\t\tif os.IsNotExist(err) {\n  1087→\t\t\treturn nil\n  1088→\t\t}\n  1089→\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n  1090→\t}\n  1091→\n  1092→\ttext := string(content)\n  1093→\tupdated, removeErr := removeStanza(text)\n  1094→\tif removeErr != nil {\n  1095→\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n  1096→\t}\n  1097→\n  1098→\tif updated != text {\n  1099→\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n  1100→\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n  1101→\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n  1102→\t\t}\n  1103→\t\treturn nil\n  1104→\t}\n  1105→\n  1106→\t// Fall back to legacy format removal\n  1107→\tupdated, removed := removeLegacyCompletion(text, completionLine)\n  1108→\tif removed {\n  1109→\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n  1110→\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n  1111→\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n  1112→\t\t}\n  1113→\t}\n  1114→\n  1115→\treturn nil\n  1116→}\n  1117→\n  1118→// promptTelemetryConsent asks the user if they want to enable telemetry.\n  1119→// It modifies settings.Telemetry based on the user's choice or flags.\n  1120→// The caller is responsible for saving settings.\n  1121→func promptTelemetryConsent(settings *EntireSettings, telemetryFlag bool) error {\n  1122→\t// Handle --telemetry=false flag first (always overrides existing setting)\n  1123→\tif !telemetryFlag {\n  1124→\t\tf := false\n  1125→\t\tsettings.Telemetry = &f\n  1126→\t\treturn nil\n  1127→\t}\n  1128→\n  1129→\t// Skip if already asked\n  1130→\tif settings.Telemetry != nil {\n  1131→\t\treturn nil\n  1132→\t}\n  1133→\n  1134→\t// Skip if env var disables telemetry (record as disabled)\n  1135→\tif os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n  1136→\t\tf := false\n  1137→\t\tsettings.Telemetry = &f\n  1138→\t\treturn nil\n  1139→\t}\n  1140→\n  1141→\tconsent := true // Default to Yes\n  1142→\tform := NewAccessibleForm(\n  1143→\t\thuh.NewGroup(\n  1144→\t\t\thuh.NewConfirm().\n  1145→\t\t\t\tTitle(\"Help improve Entire CLI?\").\n  1146→\t\t\t\tDescription(\"Share anonymous usage data. No code or personal info collected.\").\n  1147→\t\t\t\tAffirmative(\"Yes\").\n  1148→\t\t\t\tNegative(\"No\").\n  1149→\t\t\t\tValue(&consent),\n  1150→\t\t),\n  1151→\t)\n  1152→\n  1153→\tif err := form.Run(); err != nil {\n  1154→\t\treturn fmt.Errorf(\"telemetry prompt: %w\", err)\n  1155→\t}\n  1156→\n  1157→\tsettings.Telemetry = &consent\n  1158→\treturn nil\n  1159→}\n  1160→\n  1161→// runUninstall completely removes Entire from the repository.\n  1162→func runUninstall(w, errW io.Writer, force bool) error {\n  1163→\t// Check if we're in a git repository\n  1164→\tif _, err := paths.RepoRoot(); err != nil {\n  1165→\t\tfmt.Fprintln(errW, \"Not a git repository. Nothing to uninstall.\")\n  1166→\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n  1167→\t}\n  1168→\n  1169→\t// Gather counts for display\n  1170→\tsessionStateCount := countSessionStates()\n  1171→\tshadowBranchCount := countShadowBranches()\n  1172→\tgitHooksInstalled := strategy.IsGitHookInstalled()\n  1173→\tclaudeHooksInstalled := checkClaudeCodeHooksInstalled()\n  1174→\tgeminiHooksInstalled := checkGeminiCLIHooksInstalled()\n  1175→\tentireDirExists := checkEntireDirExists()\n  1176→\n  1177→\t// Check if there's anything to uninstall\n  1178→\tif !entireDirExists && !gitHooksInstalled && sessionStateCount == 0 &&\n  1179→\t\tshadowBranchCount == 0 && !claudeHooksInstalled && !geminiHooksInstalled {\n  1180→\t\tfmt.Fprintln(w, \"Entire is not installed in this repository.\")\n  1181→\t\treturn nil\n  1182→\t}\n  1183→\n  1184→\t// Show confirmation prompt unless --force\n  1185→\tif !force {\n  1186→\t\tfmt.Fprintln(w, \"\\nThis will completely remove Entire from this repository:\")\n  1187→\t\tif entireDirExists {\n  1188→\t\t\tfmt.Fprintln(w, \"  - .entire/ directory\")\n  1189→\t\t}\n  1190→\t\tif gitHooksInstalled {\n  1191→\t\t\tfmt.Fprintln(w, \"  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\")\n  1192→\t\t}\n  1193→\t\tif sessionStateCount > 0 {\n  1194→\t\t\tfmt.Fprintf(w, \"  - Session state files (%d)\\n\", sessionStateCount)\n  1195→\t\t}\n  1196→\t\tif shadowBranchCount > 0 {\n  1197→\t\t\tfmt.Fprintf(w, \"  - Shadow branches (%d)\\n\", shadowBranchCount)\n  1198→\t\t}\n  1199→\t\tswitch {\n  1200→\t\tcase claudeHooksInstalled && geminiHooksInstalled:\n  1201→\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code, Gemini CLI)\")\n  1202→\t\tcase claudeHooksInstalled:\n  1203→\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code)\")\n  1204→\t\tcase geminiHooksInstalled:\n  1205→\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Gemini CLI)\")\n  1206→\t\t}\n  1207→\t\tfmt.Fprintln(w)\n  1208→\n  1209→\t\tvar confirmed bool\n  1210→\t\tform := NewAccessibleForm(\n  1211→\t\t\thuh.NewGroup(\n  1212→\t\t\t\thuh.NewConfirm().\n  1213→\t\t\t\t\tTitle(\"Are you sure you want to uninstall Entire?\").\n  1214→\t\t\t\t\tAffirmative(\"Yes, uninstall\").\n  1215→\t\t\t\t\tNegative(\"Cancel\").\n  1216→\t\t\t\t\tValue(&confirmed),\n  1217→\t\t\t),\n  1218→\t\t)\n  1219→\n  1220→\t\tif err := form.Run(); err != nil {\n  1221→\t\t\treturn fmt.Errorf(\"confirmation cancelled: %w\", err)\n  1222→\t\t}\n  1223→\n  1224→\t\tif !confirmed {\n  1225→\t\t\tfmt.Fprintln(w, \"Uninstall cancelled.\")\n  1226→\t\t\treturn nil\n  1227→\t\t}\n  1228→\t}\n  1229→\n  1230→\tfmt.Fprintln(w, \"\\nUninstalling Entire CLI...\")\n  1231→\n  1232→\t// 0. Remove shell completion from rc file\n  1233→\tif err := removeShellCompletion(); err != nil {\n  1234→\t\tfmt.Fprintf(errW, \"Warning: failed to remove shell completion: %v\\n\", err)\n  1235→\t} else {\n  1236→\t\tfmt.Fprintln(w, \"  Removed shell completion\")\n  1237→\t}\n  1238→\n  1239→\t// 1. Remove agent hooks (lowest risk)\n  1240→\tif err := removeAgentHooks(w); err != nil {\n  1241→\t\tfmt.Fprintf(errW, \"Warning: failed to remove agent hooks: %v\\n\", err)\n  1242→\t}\n  1243→\n  1244→\t// 2. Remove git hooks\n  1245→\tremoved, err := strategy.RemoveGitHook()\n  1246→\tif err != nil {\n  1247→\t\tfmt.Fprintf(errW, \"Warning: failed to remove git hooks: %v\\n\", err)\n  1248→\t} else if removed > 0 {\n  1249→\t\tfmt.Fprintf(w, \"  Removed git hooks (%d)\\n\", removed)\n  1250→\t}\n  1251→\n  1252→\t// 3. Remove session state files\n  1253→\tstatesRemoved, err := removeAllSessionStates()\n  1254→\tif err != nil {\n  1255→\t\tfmt.Fprintf(errW, \"Warning: failed to remove session states: %v\\n\", err)\n  1256→\t} else if statesRemoved > 0 {\n  1257→\t\tfmt.Fprintf(w, \"  Removed session states (%d)\\n\", statesRemoved)\n  1258→\t}\n  1259→\n  1260→\t// 4. Remove .entire/ directory\n  1261→\tif err := removeEntireDirectory(); err != nil {\n  1262→\t\tfmt.Fprintf(errW, \"Warning: failed to remove .entire directory: %v\\n\", err)\n  1263→\t} else if entireDirExists {\n  1264→\t\tfmt.Fprintln(w, \"  Removed .entire directory\")\n  1265→\t}\n  1266→\n  1267→\t// 5. Remove shadow branches\n  1268→\tbranchesRemoved, err := removeAllShadowBranches()\n  1269→\tif err != nil {\n  1270→\t\tfmt.Fprintf(errW, \"Warning: failed to remove shadow branches: %v\\n\", err)\n  1271→\t} else if branchesRemoved > 0 {\n  1272→\t\tfmt.Fprintf(w, \"  Removed %d shadow branches\\n\", branchesRemoved)\n  1273→\t}\n  1274→\n  1275→\tfmt.Fprintln(w, \"\\nEntire CLI uninstalled successfully.\")\n  1276→\treturn nil\n  1277→}\n  1278→\n  1279→// countSessionStates returns the number of active session state files.\n  1280→func countSessionStates() int {\n  1281→\tstore, err := session.NewStateStore()\n  1282→\tif err != nil {\n  1283→\t\treturn 0\n  1284→\t}\n  1285→\tstates, err := store.List(context.Background())\n  1286→\tif err != nil {\n  1287→\t\treturn 0\n  1288→\t}\n  1289→\treturn len(states)\n  1290→}\n  1291→\n  1292→// countShadowBranches returns the number of shadow branches.\n  1293→func countShadowBranches() int {\n  1294→\tbranches, err := strategy.ListShadowBranches()\n  1295→\tif err != nil {\n  1296→\t\treturn 0\n  1297→\t}\n  1298→\treturn len(branches)\n  1299→}\n  1300→\n  1301→// checkClaudeCodeHooksInstalled checks if Claude Code hooks are installed.\n  1302→func checkClaudeCodeHooksInstalled() bool {\n  1303→\tag, err := agent.Get(agent.AgentNameClaudeCode)\n  1304→\tif err != nil {\n  1305→\t\treturn false\n  1306→\t}\n  1307→\thookAgent, ok := ag.(agent.HookSupport)\n  1308→\tif !ok {\n  1309→\t\treturn false\n  1310→\t}\n  1311→\treturn hookAgent.AreHooksInstalled()\n  1312→}\n  1313→\n  1314→// checkGeminiCLIHooksInstalled checks if Gemini CLI hooks are installed.\n  1315→func checkGeminiCLIHooksInstalled() bool {\n  1316→\tag, err := agent.Get(agent.AgentNameGemini)\n  1317→\tif err != nil {\n  1318→\t\treturn false\n  1319→\t}\n  1320→\thookAgent, ok := ag.(agent.HookSupport)\n  1321→\tif !ok {\n  1322→\t\treturn false\n  1323→\t}\n  1324→\treturn hookAgent.AreHooksInstalled()\n  1325→}\n  1326→\n  1327→// checkEntireDirExists checks if the .entire directory exists.\n  1328→func checkEntireDirExists() bool {\n  1329→\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n  1330→\tif err != nil {\n  1331→\t\tentireDirAbs = paths.EntireDir\n  1332→\t}\n  1333→\t_, err = os.Stat(entireDirAbs)\n  1334→\treturn err == nil\n  1335→}\n  1336→\n  1337→// removeAgentHooks removes hooks from all agents that support hooks.\n  1338→func removeAgentHooks(w io.Writer) error {\n  1339→\tvar errs []error\n  1340→\n  1341→\t// Remove Claude Code hooks\n  1342→\tclaudeAgent, err := agent.Get(agent.AgentNameClaudeCode)\n  1343→\tif err == nil {\n  1344→\t\tif hookAgent, ok := claudeAgent.(agent.HookSupport); ok {\n  1345→\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n  1346→\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n  1347→\t\t\t\terrs = append(errs, err)\n  1348→\t\t\t} else if wasInstalled {\n  1349→\t\t\t\tfmt.Fprintln(w, \"  Removed Claude Code hooks\")\n  1350→\t\t\t}\n  1351→\t\t}\n  1352→\t}\n  1353→\n  1354→\t// Remove Gemini CLI hooks\n  1355→\tgeminiAgent, err := agent.Get(agent.AgentNameGemini)\n  1356→\tif err == nil {\n  1357→\t\tif hookAgent, ok := geminiAgent.(agent.HookSupport); ok {\n  1358→\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n  1359→\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n  1360→\t\t\t\terrs = append(errs, err)\n  1361→\t\t\t} else if wasInstalled {\n  1362→\t\t\t\tfmt.Fprintln(w, \"  Removed Gemini CLI hooks\")\n  1363→\t\t\t}\n  1364→\t\t}\n  1365→\t}\n  1366→\n  1367→\treturn errors.Join(errs...)\n  1368→}\n  1369→\n  1370→// removeAllSessionStates removes all session state files and the directory.\n  1371→func removeAllSessionStates() (int, error) {\n  1372→\tstore, err := session.NewStateStore()\n  1373→\tif err != nil {\n  1374→\t\treturn 0, fmt.Errorf(\"failed to create state store: %w\", err)\n  1375→\t}\n  1376→\n  1377→\t// Count states before removing\n  1378→\tstates, err := store.List(context.Background())\n  1379→\tif err != nil {\n  1380→\t\treturn 0, fmt.Errorf(\"failed to list session states: %w\", err)\n  1381→\t}\n  1382→\tcount := len(states)\n  1383→\n  1384→\t// Remove the entire directory\n  1385→\tif err := store.RemoveAll(); err != nil {\n  1386→\t\treturn 0, fmt.Errorf(\"failed to remove session states: %w\", err)\n  1387→\t}\n  1388→\n  1389→\treturn count, nil\n  1390→}\n  1391→\n  1392→// removeEntireDirectory removes the .entire directory.\n  1393→func removeEntireDirectory() error {\n  1394→\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n  1395→\tif err != nil {\n  1396→\t\tentireDirAbs = paths.EntireDir\n  1397→\t}\n  1398→\tif err := os.RemoveAll(entireDirAbs); err != nil {\n  1399→\t\treturn fmt.Errorf(\"failed to remove .entire directory: %w\", err)\n  1400→\t}\n  1401→\treturn nil\n  1402→}\n  1403→\n  1404→// removeAllShadowBranches removes all shadow branches.\n  1405→func removeAllShadowBranches() (int, error) {\n  1406→\tbranches, err := strategy.ListShadowBranches()\n  1407→\tif err != nil {\n  1408→\t\treturn 0, fmt.Errorf(\"failed to list shadow branches: %w\", err)\n  1409→\t}\n  1410→\tif len(branches) == 0 {\n  1411→\t\treturn 0, nil\n  1412→\t}\n  1413→\tdeleted, _, err := strategy.DeleteShadowBranches(branches)\n  1414→\treturn len(deleted), err\n  1415→}\n  1416→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d7cf394f-4253-40c2-9be5-eeca53f7e6bc","timestamp":"2026-02-09T05:36:59.596Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","content":"package cli\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/entireio/cli/cmd/entire/cli/agent\"\n\t\"github.com/entireio/cli/cmd/entire/cli/paths\"\n\t\"github.com/entireio/cli/cmd/entire/cli/session\"\n\t\"github.com/entireio/cli/cmd/entire/cli/strategy\"\n\n\t\"github.com/charmbracelet/huh\"\n\t\"github.com/spf13/cobra\"\n)\n\n// Strategy display names for user-friendly selection\nconst (\n\tstrategyDisplayManualCommit = \"manual-commit\"\n\tstrategyDisplayAutoCommit   = \"auto-commit\"\n)\n\n// strategyDisplayToInternal maps user-friendly names to internal strategy names\nvar strategyDisplayToInternal = map[string]string{\n\tstrategyDisplayManualCommit: strategy.StrategyNameManualCommit,\n\tstrategyDisplayAutoCommit:   strategy.StrategyNameAutoCommit,\n}\n\n// strategyInternalToDisplay maps internal strategy names to user-friendly names\nvar strategyInternalToDisplay = map[string]string{\n\tstrategy.StrategyNameManualCommit: strategyDisplayManualCommit,\n\tstrategy.StrategyNameAutoCommit:   strategyDisplayAutoCommit,\n}\n\nfunc newEnableCmd() *cobra.Command {\n\tvar localDev bool\n\tvar ignoreUntracked bool\n\tvar useLocalSettings bool\n\tvar useProjectSettings bool\n\tvar agentName string\n\tvar strategyFlag string\n\tvar forceHooks bool\n\tvar skipPushSessions bool\n\tvar telemetry bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"enable\",\n\t\tShort: \"Enable Entire\",\n\t\tLong: `Enable Entire with session tracking for your AI agent workflows.\n\nUses the manual-commit strategy by default. To use a different strategy:\n\n  entire enable --strategy auto-commit\n\nStrategies: manual-commit (default), auto-commit`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\t// Check if we're in a git repository first - this is a prerequisite error,\n\t\t\t// not a usage error, so we silence Cobra's output and use SilentError\n\t\t\t// to prevent duplicate error output in main.go\n\t\t\tif _, err := paths.RepoRoot(); err != nil {\n\t\t\t\tcmd.SilenceUsage = true\n\t\t\t\tcmd.SilenceErrors = true\n\t\t\t\tfmt.Fprintln(cmd.ErrOrStderr(), \"Not a git repository. Please run 'entire enable' from within a git repository.\")\n\t\t\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t\t\t}\n\n\t\t\tif err := validateSetupFlags(useLocalSettings, useProjectSettings); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Non-interactive mode if --agent flag is provided\n\t\t\tif agentName != \"\" {\n\t\t\t\treturn setupAgentHooksNonInteractive(agent.AgentName(agentName), strategyFlag, localDev, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\t// If strategy is specified via flag, skip interactive selection\n\t\t\tif strategyFlag != \"\" {\n\t\t\t\treturn runEnableWithStrategy(cmd.OutOrStdout(), strategyFlag, localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\treturn runEnableInteractive(cmd.OutOrStdout(), localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&localDev, \"local-dev\", false, \"Use go run instead of entire binary for hooks\")\n\tcmd.Flags().MarkHidden(\"local-dev\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&ignoreUntracked, \"ignore-untracked\", false, \"Commit all new files without tracking pre-existing untracked files\")\n\tcmd.Flags().MarkHidden(\"ignore-untracked\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&useLocalSettings, \"local\", false, \"Write settings to settings.local.json instead of settings.json\")\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Write settings to settings.json even if it already exists\")\n\tcmd.Flags().StringVar(&agentName, \"agent\", \"\", \"Agent to setup hooks for (e.g., claude-code). Enables non-interactive mode.\")\n\tcmd.Flags().StringVar(&strategyFlag, \"strategy\", \"\", \"Strategy to use (manual-commit or auto-commit)\")\n\tcmd.Flags().BoolVarP(&forceHooks, \"force\", \"f\", false, \"Force reinstall hooks (removes existing Entire hooks first)\")\n\tcmd.Flags().BoolVar(&skipPushSessions, \"skip-push-sessions\", false, \"Disable automatic pushing of session logs on git push\")\n\tcmd.Flags().BoolVar(&telemetry, \"telemetry\", true, \"Enable anonymous usage analytics\")\n\t//nolint:errcheck,gosec // completion is optional, flag is defined above\n\tcmd.RegisterFlagCompletionFunc(\"strategy\", func(_ *cobra.Command, _ []string, _ string) ([]string, cobra.ShellCompDirective) {\n\t\treturn []string{strategyDisplayManualCommit, strategyDisplayAutoCommit}, cobra.ShellCompDirectiveNoFileComp\n\t})\n\n\t// Add subcommands for automation/testing\n\tcmd.AddCommand(newSetupGitHookCmd())\n\n\treturn cmd\n}\n\nfunc newDisableCmd() *cobra.Command {\n\tvar useProjectSettings bool\n\tvar uninstall bool\n\tvar force bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"disable\",\n\t\tShort: \"Disable Entire\",\n\t\tLong: `Disable Entire temporarily. Hooks will exit silently and commands will show a disabled message.\n\nUse --uninstall to completely remove Entire from this repository, including:\n  - .entire/ directory (settings, logs, metadata)\n  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\n  - Session state files (.git/entire-sessions/)\n  - Shadow branches (entire/<hash>)\n  - Agent hooks (Claude Code, Gemini CLI)`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tif uninstall {\n\t\t\t\treturn runUninstall(cmd.OutOrStdout(), cmd.ErrOrStderr(), force)\n\t\t\t}\n\t\t\treturn runDisable(cmd.OutOrStdout(), useProjectSettings)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Update settings.json instead of settings.local.json\")\n\tcmd.Flags().BoolVar(&uninstall, \"uninstall\", false, \"Completely remove Entire from this repository\")\n\tcmd.Flags().BoolVar(&force, \"force\", false, \"Skip confirmation prompt (use with --uninstall)\")\n\n\treturn cmd\n}\n\n// runEnableWithStrategy enables Entire with a specified strategy (non-interactive).\n// The selectedStrategy can be either a display name (manual-commit, auto-commit)\n// or an internal name (manual-commit, auto-commit).\nfunc runEnableWithStrategy(w io.Writer, selectedStrategy string, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Map the strategy to internal name if it's a display name\n\tinternalStrategy := selectedStrategy\n\tif mapped, ok := strategyDisplayToInternal[selectedStrategy]; ok {\n\t\tinternalStrategy = mapped\n\t}\n\n\t// Validate the strategy exists\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", selectedStrategy)\n\t}\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\t// Determine which settings file to write to\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, showNotification := determineSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\n\tif showNotification {\n\t\tfmt.Fprintln(w, \"Info: Project settings exist. Saving to settings.local.json instead.\")\n\t\tfmt.Fprintln(w, \"  Use --project to update the project settings file.\")\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tdisplayName := selectedStrategy\n\tif dn, ok := strategyInternalToDisplay[internalStrategy]; ok {\n\t\tdisplayName = dn\n\t}\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", displayName)\n\n\treturn nil\n}\n\n// runEnableInteractive runs the interactive enable flow.\nfunc runEnableInteractive(w io.Writer, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Use the default strategy (manual-commit)\n\tinternalStrategy := strategy.DefaultStrategyName\n\tfmt.Fprintf(w, \"Using %s strategy (use --strategy to change)\\n\\n\", strategyInternalToDisplay[internalStrategy])\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Ask about telemetry consent (only if not already asked)\n\tif err := promptTelemetryConsent(settings, telemetry); err != nil {\n\t\treturn fmt.Errorf(\"telemetry consent: %w\", err)\n\t}\n\n\t// Determine which settings file to write to (interactive prompt if settings.json exists)\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, err := promptSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", strategyInternalToDisplay[internalStrategy])\n\n\treturn nil\n}\n\n// runEnable is a simple enable that just sets the enabled flag (for programmatic use).\nfunc runEnable(w io.Writer) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = true\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now enabled.\")\n\treturn nil\n}\n\nfunc runDisable(w io.Writer, useProjectSettings bool) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = false\n\n\t// If --project flag is specified, always write to project settings\n\tif useProjectSettings {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t} else {\n\t\t// Always write to local settings file (create if doesn't exist)\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now disabled.\")\n\treturn nil\n}\n\n// DisabledMessage is the message shown when Entire is disabled\nconst DisabledMessage = \"Entire is disabled. Run `entire enable` to re-enable.\"\n\n// checkDisabledGuard checks if Entire is disabled and prints a message if so.\n// Returns true if the caller should exit (i.e., Entire is disabled).\n// On error reading settings, defaults to enabled (returns false).\nfunc checkDisabledGuard(w io.Writer) bool {\n\tenabled, err := IsEnabled()\n\tif err != nil {\n\t\t// Default to enabled on error\n\t\treturn false\n\t}\n\tif !enabled {\n\t\tfmt.Fprintln(w, DisabledMessage)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// setupClaudeCodeHook sets up Claude Code hooks.\n// This is a convenience wrapper that uses the agent package.\n// Returns the number of hooks installed (0 if already installed).\nfunc setupClaudeCodeHook(localDev, forceHooks bool) (int, error) {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get claude-code agent: %w\", err)\n\t}\n\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn 0, errors.New(\"claude-code agent does not support hooks\")\n\t}\n\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to install claude-code hooks: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// setupAgentHooksNonInteractive sets up hooks for a specific agent non-interactively.\n// If strategyName is provided, it sets the strategy; otherwise uses default.\nfunc setupAgentHooksNonInteractive(agentName agent.AgentName, strategyName string, localDev, forceHooks, skipPushSessions, telemetry bool) error {\n\tag, err := agent.Get(agentName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown agent: %s\", agentName)\n\t}\n\n\t// Check if agent supports hooks\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn fmt.Errorf(\"agent %s does not support hooks\", agentName)\n\t}\n\n\t// Install hooks\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install hooks for %s: %w\", agentName, err)\n\t}\n\n\tif count == 0 {\n\t\tmsg := fmt.Sprintf(\"Hooks for %s already installed\", ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t} else {\n\t\tmsg := fmt.Sprintf(\"Installed %d hooks for %s\", count, ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\n\t// Update settings to store the strategy\n\tsettings, _ := LoadEntireSettings() //nolint:errcheck // settings defaults are fine\n\tsettings.Enabled = true\n\tif localDev {\n\t\tsettings.LocalDev = localDev\n\t}\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Set strategy if provided\n\tif strategyName != \"\" {\n\t\t// Map display name to internal name if needed\n\t\tinternalStrategy := strategyName\n\t\tif mapped, ok := strategyDisplayToInternal[strategyName]; ok {\n\t\t\tinternalStrategy = mapped\n\t\t}\n\t\t// Validate the strategy exists\n\t\tif _, err := strategy.Get(internalStrategy); err != nil {\n\t\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", strategyName)\n\t\t}\n\t\tsettings.Strategy = internalStrategy\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tif _, err := strategy.InstallGitHook(true); err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\n\t// Let the strategy handle its own setup requirements (creates entire/sessions branch, etc.)\n\tstrat, err := strategy.Get(settings.Strategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// validateSetupFlags checks that --local and --project flags are not both specified.\nfunc validateSetupFlags(useLocal, useProject bool) error {\n\tif useLocal && useProject {\n\t\treturn errors.New(\"cannot specify both --project and --local\")\n\t}\n\treturn nil\n}\n\n// determineSettingsTarget decides whether to write to settings.local.json based on:\n// - Whether settings.json already exists\n// - The --local and --project flags\n// Returns (useLocal, showNotification).\nfunc determineSettingsTarget(entireDir string, useLocal, useProject bool) (bool, bool) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, false\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, false\n\t}\n\n\t// No flags specified - check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); err == nil {\n\t\t// Settings file exists - auto-redirect to local with notification\n\t\treturn true, true\n\t}\n\n\t// Settings file doesn't exist - create it\n\treturn false, false\n}\n\n// Settings target options for interactive prompt\nconst (\n\tsettingsTargetProject = \"project\"\n\tsettingsTargetLocal   = \"local\"\n)\n\n// promptSettingsTarget interactively asks the user where to save settings\n// when settings.json already exists and no flags were provided.\n// Returns (useLocal, error).\nfunc promptSettingsTarget(entireDir string, useLocal, useProject bool) (bool, error) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, nil\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, nil\n\t}\n\n\t// Check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); os.IsNotExist(err) {\n\t\t// Settings file doesn't exist - create it (no prompt needed)\n\t\treturn false, nil\n\t}\n\n\t// Settings file exists - prompt user\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(\"Project settings already exist. Where should settings be saved?\").\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Update project settings (settings.json)\", settingsTargetProject),\n\t\t\t\t\thuh.NewOption(\"Use local settings (settings.local.json, gitignored)\", settingsTargetLocal),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false, fmt.Errorf(\"selection cancelled: %w\", err)\n\t}\n\n\treturn selected == settingsTargetLocal, nil\n}\n\n// setupEntireDirectory creates the .entire directory and gitignore.\n// Returns true if the directory was created, false if it already existed.\nfunc setupEntireDirectory() (bool, error) {\n\t// Get absolute path for the .entire directory\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\n\t// Check if directory already exists\n\tcreated := false\n\tif _, err := os.Stat(entireDirAbs); os.IsNotExist(err) {\n\t\tcreated = true\n\t}\n\n\t// Create .entire directory\n\t//nolint:gosec // G301: Project directory needs standard permissions for git\n\tif err := os.MkdirAll(entireDirAbs, 0o755); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to create .entire directory: %w\", err)\n\t}\n\n\t// Create/update .gitignore with all required entries\n\tif err := strategy.EnsureEntireGitignore(); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to setup .gitignore: %w\", err)\n\t}\n\n\treturn created, nil\n}\n\n// setupGitHook installs the prepare-commit-msg hook for context trailers.\nfunc setupGitHook() error {\n\t// Use shared implementation from strategy package\n\t// The localDev setting is read from settings.json\n\t_, err := strategy.InstallGitHook(false) // not silent - show output during setup\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hook: %w\", err)\n\t}\n\treturn nil\n}\n\n// newSetupGitHookCmd creates the standalone git-hook setup command\nfunc newSetupGitHookCmd() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:    \"git-hook\",\n\t\tShort:  \"Install git hook for session context trailers\",\n\t\tHidden: true, // Hidden as it's mainly for testing\n\t\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\treturn setupGitHook()\n\t\t},\n\t}\n\n\treturn cmd\n}\n\nfunc newCurlBashPostInstallCmd() *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:    \"curl-bash-post-install\",\n\t\tShort:  \"Post-install tasks for curl|bash installer\",\n\t\tHidden: true,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tw := cmd.OutOrStdout()\n\t\t\tif err := promptShellCompletion(w); err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Note: Shell completion setup skipped: %v\\n\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n}\n\n// Shell completion stanza management.\n// The stanza is a versioned, delimited block written to ~/.zshrc or ~/.bashrc:\n//\n//\t# Entire CLI completions (v1) {{{\n//\tautoload -Uz compinit && compinit && source <(entire completion zsh)\n//\t# }}}\nconst (\n\tshellCompletionStanzaVersion = 1\n\tshellCompletionOpenFormat    = \"# Entire CLI completions (v%d) {{{\"\n\tshellCompletionClose         = \"# }}}\"\n\tshellCompletionLegacyComment = \"# Entire CLI shell completion\" // old format for migration\n)\n\ntype stanzaStatus int\n\nconst (\n\tstanzaNotFound stanzaStatus = iota\n\tstanzaCurrent\n\tstanzaOutdated\n\tstanzaLegacy\n)\n\nvar (\n\terrStanzaCorrupted = errors.New(\"shell completion block is corrupted (missing closing marker)\")\n\terrMultipleStanzas = errors.New(\"found multiple shell completion blocks\")\n)\n\n// findStanzaVersion scans content for the opening stanza marker and returns\n// the version number. Returns 0 if no stanza is found.\nfunc findStanzaVersion(content string) int {\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\treturn version\n\t\t}\n\t}\n\treturn 0\n}\n\n// checkStanzaStatus determines the status of the shell completion stanza in content.\nfunc checkStanzaStatus(content string, currentVersion int) stanzaStatus {\n\tversion := findStanzaVersion(content)\n\tif version > 0 {\n\t\tif version >= currentVersion {\n\t\t\treturn stanzaCurrent\n\t\t}\n\t\treturn stanzaOutdated\n\t}\n\tif strings.Contains(content, shellCompletionLegacyComment) {\n\t\treturn stanzaLegacy\n\t}\n\treturn stanzaNotFound\n}\n\n// buildStanza constructs the full stanza block for the given version and completion line.\nfunc buildStanza(version int, completionLine string) string {\n\treturn fmt.Sprintf(shellCompletionOpenFormat, version) + \"\\n\" + completionLine + \"\\n\" + shellCompletionClose\n}\n\n// countStanzaOpeners counts how many opening stanza markers exist in content.\nfunc countStanzaOpeners(content string) int {\n\tcount := 0\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n// replaceStanza finds the open+close markers in content and replaces the block\n// with a new stanza. Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc replaceStanza(content string, version int, completionLine string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tnewStanza := buildStanza(version, completionLine)\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\tresult = append(result, newStanza)\n\tresult = append(result, lines[closeIdx+1:]...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeStanza finds and removes the stanza block from content.\n// Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc removeStanza(content string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\t// Skip blank line immediately after stanza if present\n\ttail := lines[closeIdx+1:]\n\tif len(tail) > 0 && strings.TrimSpace(tail[0]) == \"\" {\n\t\ttail = tail[1:]\n\t}\n\tresult = append(result, tail...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeLegacyCompletion removes the old-format comment and its following\n// completion line from content. Returns the modified content and whether\n// anything was removed.\nfunc removeLegacyCompletion(content, completionLine string) (string, bool) {\n\tlines := strings.Split(content, \"\\n\")\n\tvar result []string\n\tremoved := false\n\tfor i := 0; i < len(lines); i++ {\n\t\tif strings.TrimSpace(lines[i]) == shellCompletionLegacyComment {\n\t\t\t// Remove the comment line and the next line if it matches the completion line\n\t\t\tif i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == completionLine {\n\t\t\t\ti++ // skip next line too\n\t\t\t}\n\t\t\tremoved = true\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, lines[i])\n\t}\n\tif !removed {\n\t\treturn content, false\n\t}\n\treturn strings.Join(result, \"\\n\"), true\n}\n\n// errUnsupportedShell is returned when the user's shell is not supported for completion.\nvar errUnsupportedShell = errors.New(\"unsupported shell\")\n\n// shellCompletionTarget returns the rc file path and completion lines for the\n// user's current shell.\nfunc shellCompletionTarget() (shellName, rcFile, completionLine string, err error) {\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", fmt.Errorf(\"cannot determine home directory: %w\", err)\n\t}\n\n\tshell := os.Getenv(\"SHELL\")\n\tswitch {\n\tcase strings.Contains(shell, \"zsh\"):\n\t\treturn \"Zsh\",\n\t\t\tfilepath.Join(home, \".zshrc\"),\n\t\t\t\"source <(entire completion zsh)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"bash\"):\n\t\treturn \"Bash\",\n\t\t\tfilepath.Join(home, \".bashrc\"),\n\t\t\t\"source <(entire completion bash)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"fish\"):\n\t\treturn \"Fish\",\n\t\t\tfilepath.Join(home, \".config\", \"fish\", \"config.fish\"),\n\t\t\t\"entire completion fish | source\",\n\t\t\tnil\n\tdefault:\n\t\treturn \"\", \"\", \"\", errUnsupportedShell\n\t}\n}\n\n// promptShellCompletion offers to add shell completion to the user's rc file.\n// Handles versioned stanza detection, updates, and legacy migration.\nfunc promptShellCompletion(w io.Writer) error {\n\tshellName, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\tif errors.Is(err, errUnsupportedShell) {\n\t\t\tfmt.Fprintf(w, \"Note: Shell completion not available for your shell. Supported: zsh, bash, fish.\\n\")\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"shell completion: %w\", err)\n\t}\n\n<<<<<<< HEAD\n\tif isCompletionConfigured(rcFile) {\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\tif isCompletionConfigured(rcFile, completionLine) {\n\t\treturn nil\n=======\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n\t}\n\n\tstatus := checkStanzaStatus(string(content), shellCompletionStanzaVersion)\n\tswitch status {\n\tcase stanzaCurrent:\n\t\treturn nil\n\n\tcase stanzaOutdated:\n\t\tif !promptYesNo(\"Shell completion is outdated. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t// Re-read in case file changed\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, replaceErr := replaceStanza(string(content), shellCompletionStanzaVersion, completionLine)\n\t\tif replaceErr != nil {\n\t\t\tfmt.Fprintf(w, \"Warning: %v in %s. Please fix manually.\\n\", replaceErr, rcFile)\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaLegacy:\n\t\tif !promptYesNo(\"Shell completion uses old format. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, _ := removeLegacyCompletion(string(content), completionLine)\n\t\tupdated = updated + \"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\"\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaNotFound:\n\t\tif !promptYesNo(\"Enable shell completion?\") {\n\t\t\treturn nil\n\t\t}\n\t\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t}\n\n\treturn nil\n}\n\n// promptYesNo shows a yes/no selection prompt and returns whether the user chose yes.\nfunc promptYesNo(title string) bool {\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n<<<<<<< HEAD\n\t\t\t\tTitle(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)).\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tTitle(\"Enable shell completion?\").\n=======\n\t\t\t\tTitle(title).\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Yes\", \"yes\"),\n\t\t\t\t\thuh.NewOption(\"No\", \"no\"),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n<<<<<<< HEAD\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Restart your shell to activate\")\n\n\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\n\treturn nil\n=======\n\treturn selected == \"yes\"\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n}\n\n<<<<<<< HEAD\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), \"entire completion\")\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string, completionLine string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), completionLine)\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n=======\n// appendShellCompletion adds the completion stanza to the rc file.\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\nfunc appendShellCompletion(rcFile, completionLine string) error {\n\tif err := os.MkdirAll(filepath.Dir(rcFile), 0o755); err != nil {\n\t\treturn fmt.Errorf(\"creating directory: %w\", err)\n\t}\n\t//nolint:gosec // G302: Shell rc files need 0644 for user readability\n\tf, err := os.OpenFile(rcFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(\"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing completion: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeShellCompletion removes the shell completion stanza (or legacy format)\n// from the user's rc file. Used during uninstall.\nfunc removeShellCompletion() error {\n\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\ttext := string(content)\n\tupdated, removeErr := removeStanza(text)\n\tif removeErr != nil {\n\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n\t}\n\n\tif updated != text {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Fall back to legacy format removal\n\tupdated, removed := removeLegacyCompletion(text, completionLine)\n\tif removed {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// promptTelemetryConsent asks the user if they want to enable telemetry.\n// It modifies settings.Telemetry based on the user's choice or flags.\n// The caller is responsible for saving settings.\nfunc promptTelemetryConsent(settings *EntireSettings, telemetryFlag bool) error {\n\t// Handle --telemetry=false flag first (always overrides existing setting)\n\tif !telemetryFlag {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\t// Skip if already asked\n\tif settings.Telemetry != nil {\n\t\treturn nil\n\t}\n\n\t// Skip if env var disables telemetry (record as disabled)\n\tif os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\tconsent := true // Default to Yes\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewConfirm().\n\t\t\t\tTitle(\"Help improve Entire CLI?\").\n\t\t\t\tDescription(\"Share anonymous usage data. No code or personal info collected.\").\n\t\t\t\tAffirmative(\"Yes\").\n\t\t\t\tNegative(\"No\").\n\t\t\t\tValue(&consent),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn fmt.Errorf(\"telemetry prompt: %w\", err)\n\t}\n\n\tsettings.Telemetry = &consent\n\treturn nil\n}\n\n// runUninstall completely removes Entire from the repository.\nfunc runUninstall(w, errW io.Writer, force bool) error {\n\t// Check if we're in a git repository\n\tif _, err := paths.RepoRoot(); err != nil {\n\t\tfmt.Fprintln(errW, \"Not a git repository. Nothing to uninstall.\")\n\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t}\n\n\t// Gather counts for display\n\tsessionStateCount := countSessionStates()\n\tshadowBranchCount := countShadowBranches()\n\tgitHooksInstalled := strategy.IsGitHookInstalled()\n\tclaudeHooksInstalled := checkClaudeCodeHooksInstalled()\n\tgeminiHooksInstalled := checkGeminiCLIHooksInstalled()\n\tentireDirExists := checkEntireDirExists()\n\n\t// Check if there's anything to uninstall\n\tif !entireDirExists && !gitHooksInstalled && sessionStateCount == 0 &&\n\t\tshadowBranchCount == 0 && !claudeHooksInstalled && !geminiHooksInstalled {\n\t\tfmt.Fprintln(w, \"Entire is not installed in this repository.\")\n\t\treturn nil\n\t}\n\n\t// Show confirmation prompt unless --force\n\tif !force {\n\t\tfmt.Fprintln(w, \"\\nThis will completely remove Entire from this repository:\")\n\t\tif entireDirExists {\n\t\t\tfmt.Fprintln(w, \"  - .entire/ directory\")\n\t\t}\n\t\tif gitHooksInstalled {\n\t\t\tfmt.Fprintln(w, \"  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\")\n\t\t}\n\t\tif sessionStateCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Session state files (%d)\\n\", sessionStateCount)\n\t\t}\n\t\tif shadowBranchCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Shadow branches (%d)\\n\", shadowBranchCount)\n\t\t}\n\t\tswitch {\n\t\tcase claudeHooksInstalled && geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code, Gemini CLI)\")\n\t\tcase claudeHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code)\")\n\t\tcase geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Gemini CLI)\")\n\t\t}\n\t\tfmt.Fprintln(w)\n\n\t\tvar confirmed bool\n\t\tform := NewAccessibleForm(\n\t\t\thuh.NewGroup(\n\t\t\t\thuh.NewConfirm().\n\t\t\t\t\tTitle(\"Are you sure you want to uninstall Entire?\").\n\t\t\t\t\tAffirmative(\"Yes, uninstall\").\n\t\t\t\t\tNegative(\"Cancel\").\n\t\t\t\t\tValue(&confirmed),\n\t\t\t),\n\t\t)\n\n\t\tif err := form.Run(); err != nil {\n\t\t\treturn fmt.Errorf(\"confirmation cancelled: %w\", err)\n\t\t}\n\n\t\tif !confirmed {\n\t\t\tfmt.Fprintln(w, \"Uninstall cancelled.\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"\\nUninstalling Entire CLI...\")\n\n\t// 0. Remove shell completion from rc file\n\tif err := removeShellCompletion(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shell completion: %v\\n\", err)\n\t} else {\n\t\tfmt.Fprintln(w, \"  Removed shell completion\")\n\t}\n\n\t// 1. Remove agent hooks (lowest risk)\n\tif err := removeAgentHooks(w); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove agent hooks: %v\\n\", err)\n\t}\n\n\t// 2. Remove git hooks\n\tremoved, err := strategy.RemoveGitHook()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove git hooks: %v\\n\", err)\n\t} else if removed > 0 {\n\t\tfmt.Fprintf(w, \"  Removed git hooks (%d)\\n\", removed)\n\t}\n\n\t// 3. Remove session state files\n\tstatesRemoved, err := removeAllSessionStates()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove session states: %v\\n\", err)\n\t} else if statesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed session states (%d)\\n\", statesRemoved)\n\t}\n\n\t// 4. Remove .entire/ directory\n\tif err := removeEntireDirectory(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove .entire directory: %v\\n\", err)\n\t} else if entireDirExists {\n\t\tfmt.Fprintln(w, \"  Removed .entire directory\")\n\t}\n\n\t// 5. Remove shadow branches\n\tbranchesRemoved, err := removeAllShadowBranches()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shadow branches: %v\\n\", err)\n\t} else if branchesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed %d shadow branches\\n\", branchesRemoved)\n\t}\n\n\tfmt.Fprintln(w, \"\\nEntire CLI uninstalled successfully.\")\n\treturn nil\n}\n\n// countSessionStates returns the number of active session state files.\nfunc countSessionStates() int {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0\n\t}\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(states)\n}\n\n// countShadowBranches returns the number of shadow branches.\nfunc countShadowBranches() int {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(branches)\n}\n\n// checkClaudeCodeHooksInstalled checks if Claude Code hooks are installed.\nfunc checkClaudeCodeHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkGeminiCLIHooksInstalled checks if Gemini CLI hooks are installed.\nfunc checkGeminiCLIHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameGemini)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkEntireDirExists checks if the .entire directory exists.\nfunc checkEntireDirExists() bool {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\t_, err = os.Stat(entireDirAbs)\n\treturn err == nil\n}\n\n// removeAgentHooks removes hooks from all agents that support hooks.\nfunc removeAgentHooks(w io.Writer) error {\n\tvar errs []error\n\n\t// Remove Claude Code hooks\n\tclaudeAgent, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err == nil {\n\t\tif hookAgent, ok := claudeAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Claude Code hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove Gemini CLI hooks\n\tgeminiAgent, err := agent.Get(agent.AgentNameGemini)\n\tif err == nil {\n\t\tif hookAgent, ok := geminiAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Gemini CLI hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errors.Join(errs...)\n}\n\n// removeAllSessionStates removes all session state files and the directory.\nfunc removeAllSessionStates() (int, error) {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to create state store: %w\", err)\n\t}\n\n\t// Count states before removing\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list session states: %w\", err)\n\t}\n\tcount := len(states)\n\n\t// Remove the entire directory\n\tif err := store.RemoveAll(); err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to remove session states: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// removeEntireDirectory removes the .entire directory.\nfunc removeEntireDirectory() error {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\tif err := os.RemoveAll(entireDirAbs); err != nil {\n\t\treturn fmt.Errorf(\"failed to remove .entire directory: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeAllShadowBranches removes all shadow branches.\nfunc removeAllShadowBranches() (int, error) {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list shadow branches: %w\", err)\n\t}\n\tif len(branches) == 0 {\n\t\treturn 0, nil\n\t}\n\tdeleted, _, err := strategy.DeleteShadowBranches(branches)\n\treturn len(deleted), err\n}\n","numLines":1416,"startLine":1,"totalLines":1416}},"sourceToolAssistantUUID":"6f7ac7a4-23cc-4103-bdd6-69b36b5dddbc"}
{"parentUuid":"d7cf394f-4253-40c2-9be5-eeca53f7e6bc","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_018YU4sNjenndaabGUvmshHz","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Let me understand the conflict. There are 3 conflict regions in the file:\n\n**Conflict 1** (lines 897-910): In `promptShellCompletion`\n- HEAD: Uses `isCompletionConfigured(rcFile)` (takes only rcFile, no completionLine) and prints a message\n- Incoming (b6ff09d): Reads the file content and checks stanza status instead of using `isCompletionConfigured`\n\n**Conflict 2** (lines 979-1027): In the prompt area\n- HEAD: Has the title as `fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)` and the full `promptShellCompletion` continuation\n\n\n- Incoming (b6ff09d): Extracts the yes/no prompt into a generic `promptYesNo(title string)` function, moving the shell completion logic to the caller\n\n**Conflict 3** (lines 1030-1056): `isCompletionConfigured` and `appendShellCompletion`\n- HEAD: Has `isCompletionConfigured(rcFile string)` that checks for \"entire completion\" and the old comment for `appendShellCompletion`\n- Incoming (b6ff09d): Removes `isCompletionConfigured` entirely (replaced by stanza checking) and has new comment for `appendShellCompletion`\n\nThe incoming branch's versioned stanza approach is the right direction, but I should merge in HEAD's improvements: the shell name in the prompt title and the success message when completion is already configured. I also need to check `removeShellCompletion` on line 1078—it's calling `shellCompletionTarget()` with only 2 return values, but the current HEAD version returns 4.\n\nMy resolution strategy is to take the incoming version's stanza-checking logic for `promptShellCompletion`, but incorporate the shell name in prompts and add the \"already configured\" message. For `promptYesNo`, I'll use the incoming version's signature and let callers pass the shell name in the title. I should remove `isCompletionConfigured` entirely since the stanza checking replaces it, and fix the `removeShellCompletion` call to handle all 4 return values. I'm working through the merge conflict resolutions now. For the first conflict, I need to read the RC file and check if the completion stanza is already there, then show the appropriate message. For the second conflict, I'll use the incoming version of `promptYesNo` with a generic title parameter, but I need to update the callers to pass in the shell name. The third conflict involves removing the `isCompletionConfigured` function entirely and using the incoming comment instead. Finally, I need to fix the `removeShellCompletion` function to unpack all 4 return values from `shellCompletionTarget` instead of just 2. I'm going to apply these edits sequentially to resolve the merge conflicts. I'll start with the first conflict around the stanzaCurrent case, then move through updating the prompts to include the shell name, removing the isCompletionConfigured check, and finally fixing the removeShellCompletion function to handle errors properly.","signature":"EocxCkYICxgCKkAKLhplAiwIHujVzuuhDeIOJuzZYNuABMae+1iXeQAx7dcnpk+YTlbXnfpqbC2IP94C36D0ngSXZEIu0iXo2rUiEgwnzAtOD6hPNR+efLcaDGSvimpdONNk2fNmDiIwzO742G/ulFtMKzPAp67zifkbIwVunxUognSWpxfL+vZoGAgWsEOh7RSioLpTPYQKKu4vgSMMOsAY2PV+h4Jpi+ufOCJoTk+1lQXhat2xVfp5tc+WUNnsIIS7WVstygc0Yna60vWmF6o9QZeSOJP32GOL3HobiN/vyZFU6FU2tF7nis7DdW4bYV/lOCs4CZRgSX1vnJVVGAOlAHVgqA41wCZMiun3tfhYt62USeGsEQlhBufaIEGlQF0Xk8F1ZinjFWwYdlv8R4t7Ilu47wYkspZW6ZayFAwzeLD4seDoYaNu85IHEF3wlP2lrl6S9NMWcRLnTZNRhkOmDASblHjtsV/6axUT7qgCrwH47QtpGZN8hY4970WLMj5royLm/LHghOSEpy4gPILcwxcAtMnRTzEPInt6d4zC1jpW+UBKKZiniPx++ic8xcdSHZTAlm9Cmk6/NQU541eBxVTECrn1Qi7MgrQRlmtw2Q0eeZL3TEc32EbvYxxrwRn3nf23Hldet3yqCzqWpPgrhe70IFM4XLf/cDdymq5BK9hT4oWy5Vr3TbzicjLZnoyNSh9VTTEGow7uPerSug0nmAjw5cgM3nrBfE/3BByBrjqER56LQfpGDiIL25Ok1Ou421Q3y4z30nzcZ6apsbFi0tv/orz+f7SLRCVJ7DE1R/G0lgqcPl40Zpg4zktcijR46dDV0OcbE+e9hFAWzbGP4xdnw/psUMaOkbeDUBcSlU1sAbXJNUVuYsUoekD4dh686FUhAmbYGFbHjG/9AfVayIHTXH7qGSA+Zcv7wBz/8nSK8FDHIqYa7OF9/tm2UktHaZ1cUdUJCsvuJDYVtxf/Hy6pyr2QWNHupNrfPT/Brxs26OS745aUuboDwWAB98/eKhnxzcqZKuPHADeXGLUJAc7NSqlV0TVagKLaUvvUO0+H/K05301TFY3tq4JYyhtIbmwMnGhqU/2G3VKGrc2QvdSGLPWdenPk51cO4yFELKLNEUzKzlnFBJ7dT6W18chb0dWk3Gz4lNjai6h+lNFFeNxCqlgFvjDJ/oBKalGMKgZukwWoKMmljQxp9vcTGD90DMIgBoftfi/Q/bj3RCs1B7sM70h1DEYBpWp+EU5JUtfxkWfJ2Wn2A+fSOGmUitn7felAiJo4CC44GbNaWVXUJIa7/oylDuqnoDo3X1AwwfezLYtb1SZtW2HadQObT47AHbWc7fsQI4S0BCj+kOBg9qiyEnw5ThDdRRaJBnmRDBATJdIm2FCcdyf2MVZqP3PesWtFlt+0KiiwrfDonIyWjtXhFypJekrNVfKRTfoYoJL/zawmWOwee2Gf5b2inJ2MxQXqrJ5xBldVA6TnWL3Pg+SgrJGA/EU7aSd5sMIPsp9dBdXnf6ZWMBKxaurxsrN4xH9zpV9hyAgSswUq1CblsXSkb808dB1ufuo514P0F2u9qu3P2mneCzYoYnF3qs9uFPf/IuN2NXP9qpjYTnalXE65dqTt0JhjK9/zpzWi8F6sSaoRH7Q8gqTPoCtQPli6sfAUmMK4ymH1tM+31Vo2fsqWFk8TAPg9WoSSKNajXsQUx3M9CPO4ZFyjFDON+nQ8R6XpZ9F92pMt5iXNktCf8c02fiEWHgtqqhnrdjX46jT78qECFJYy9EtfUtd+ieBiZY1KUv66hfuXIukVRfDqNLMScfX1P7NZJB2MKWeGFyO2Hu19D9KHfFLlWnJWYecS9tP00t9j00xyot4gNvZaZqbVBZe0jZhmfrYBXN3Sll8eYYsbwxnAlb0oQrQ87o91iDNKZYxoFlkQ9UyZa+UJY5XLjUH7Hzo/8wGz9tIsLxabEXpFZsmTAcW/vP78xGC0WzWhSTu3tTBXMzLD5W+1HHFf4WFlvg9XlF8/t4M4MvCJIGWUWrDosg9Tsx6M0Ct6raeQm7VIZ2gk04b7u/m5YoutXb8PDpLVu4mO+V+8mGfONJLEZ0uBydTLexShDCebG8SiVFEScvGKKwpoyx9QcYd5PjMtzGFurEJQrri789YlSKC9G7JpY7ARTEVZ/PXnhrHlmzhKdKdIKXGNyidQt9zDJL4MNelyKGqe8S6sr4872mTqWuzVF4SPXSBViF7Tp+SPHNN7PWUYXJ3iuGZxndGj4MwxlRG4pX2d4+MryiRgj0dR8g1/drZp5VpW5PwOxYzGqtsvnUmEjsZKbOLKMFC+ooE7lPC8CQ2tC7+TtFgVJQWWoDoD3COnemF8KcHROibK+pcW+4FoXG5hn6dfXVmjaO3/v6bMrv/t7D7N7TKcM9lWPHzKX3bRxTiFfWCMxT9zRKhL9ZJZ5XdRL/9Oy5e1bg1FdTrqX092lmlO2dIVeHNhhh5A0Gb3Ju9LxRDaJ7Uzu5alATSv1R2fXNdAf7+K3k87gPfFH/enhdLmhWNgZQEC3wfJpiBf4frEkPkJTRcj9h9M7G5QPjX2TBsU2Rj0MieMarnv4JN4l8cLkujo5ZBnV1KvEuwe+I8ChgJ5iDakQ2asQpYzU4P9gOSmOLkab6rBYEt2CvWbCXUnln4bkCNOJ4Ve2SC1Lxh0kB914ghkx0kEPdHzZN58o2tG6JL/xJLs3NjR8BSZJlWlOkUnnBfQt9adC0OWq1TH3COJk4RkCb9k836x77ckPfHYB63PoH9JbTIp+eULtlGleB0pa7vlJN90mG3e1aUTUIyMaj1WAs6m6pcQ94uqUoUzEeEyhCPmbjpYG7EiP6NV/8GTX2IaNxU7jDd4amfsusULeQdGWYdbUgMjj8Qd47xMqsszw2y5vm4cv6rt08fTEi9fNwE3ncMzKPXc70EWROaugmUxvIRhS8HV9C/05hVljzT0XrRz6dfqczMQpedAEzL/8riqmu/+/KvERR1AsX1dp4wB8VhZBE3but3SRhMo3erULUh3J0iP6xHJfSgwGSJyldg+uKGO89xDNjfID3JCR2EVXcePfThuGZt/EhP+diD8qFcoRftiFaY5E0aY8/b0usMlyCPml4ucNbf/uUIT90ib/mS8PxVQmT+7JDmLr9SDfVQv8W6boyYUKT6+cYEkma4u58GIKy68+HEwTNDAghDqfI70z4WaBQ1jodB4xoTHX7E/dvC1qwk2Hbv3D/SfritAgTlFd5aarHC5BInUSUHlZkjL5E2zrgCAWtIddHAwgyxKpZlpQ1vkf9WDnKn7+t1f7JIxdf7Ms/BFesiHWs8ny1va+xA61FI3kve7RvH41k5O7ZodVA5KI2D4UEwLKjikxLweJY5AKBmno0GzgOfgwY7a33qtjgj8qB8i8Fpq9Rq0PymnYxHWLPaM53pVsmlnBULjkBuHi1N0pMBBTSv36GvyhBEzF5LSx+nEnqsb83Ngh0I2ax+/RpSXGSLYgluQVSLG/8FB9dVj6B2VTVTxIuNbwlZGSSvgHJaEyJfufyRMTPlEoBFeVPpzVegKzbLuxuC3s9gwKkbVQvW8fCBfMZDKDalbK9RCjZpPRLcxk0KHV4+ADbvr7vHMNtqbIk6a26BUoMEkdh+VYUQK4Ld+njA4FS1C+OqDbMXfypyFE2O4sI71zuLBMSSZkBReNWQi8wJ0qgEEO72VPlhcRI6RiII5JCcr6bYLcIdMk8nwD6Lq5jmpR8QKjUp5T1wdxxzDbSK+XXAdRdp/To9Pe40UwcsIU7Loc8IXI1rhSFJAK1+g1WDuXAisoao847eHOYT3/fxvYd6isQ5fgKEYViAlZGk5xJjb3yLoXzwxAxGn8ZI2Yffx7kMJLWEd0HXi8GdKT90rVOjHVQkdmhTmUQ8ihmiLf7cU13kCLEHQTm3SnXk8PhZsGEwzFWtXqronIF1HSRNg6sajDnNVLOZj2Bh2upPWBWNJujRSVj5Brxd1npXDRVgY8j0vEj35JD6fCfkBrlEx/lPMjzR35lgyoTKcYyeLpgr55pjZvOy+KKUHVnGQpgdZgnkOJSj371cicsXDW1gxcAn4Z2i4igHG/1DJHmQ/XBGUlEzh70deq4mTvk6ZpbgoM3jWUOMdYu8AMOHJtBESe1naYChsLIAJ9x3nv5IhXM+2f4yjqzHb0KXb1KUf7zJudKMiHymMIy4cY64k1jq8jL7tgyQrwcFS/AvGBWU70cCKNsv/6XcTyeNyOoPyZcOOtggpJsAsOEhkrt0cDvPYCnnUNaLb0zL5isoq12h5BLSJQrfP/BXnBgqnEvRY6Vd6ANebO2FtOzRGJojGETJ+0gcG+DX0xrDuq2nPRQVq+vnO3RtWUdxPe9YG2Ybr9znOcMjWILzJKUx6vjh2P+LHicOy0xFwi73PedQ/Lx85oTKFw3f6RTD+RiojLNZa1/b0GBjvTYGqyw3/v4hibgynE9B7TnIa5ZmXmd0BpP4y3UbxEHXw4nEJFROHiM81Xr73F+M0QwSVEGCyYgUjqJIeN92tcXvPVrecODyLA2ur8uIGEvfMiFK72IaCXq/HsVmfLyb5GHPWhMhDlBWT7Sf21hVYrxB3JOuUvyc2EaU+CPjc4Hsi5LexOTbFGZ+hWKAumlzJWrVgSaNs0W2FFPG9fq87CLzB0OdDhq9Y2HtzURlUvcpRGB04IO0R7jfRXEPZg4bfeD8JcjYBywVN5PE7uaoS3fMqJeMEmAyERSmis732JKLFDUTVHd/gPuINWlEWt8SCmsae2H1rQ+dbtLj4qJogh8WMNm/jmI08+eFMbq2oQwPQKKuXA1BzvJwj/4W33X9Sft2aYjBsavkpjvTQ72C+lQWRo+Un4+WJZmURQn2gqHbS90XhoVt+mb0aw8LfnsDS9uyQrqSULPXwAx8s980vu734yHHJzFvMiptBtOONxnQk02NBG6CJ/XOz96pyltlbwSSCGvrH35y+lCt5d8DDAinG6+CATgmhfLxBj0ftS2wB8zKvwf8kmW7TlHh/A7AsTIG9p1s47Yrp65gfq9b9cxdPpVHo3hv0rO2yPQbXc5/mDqRtOWT6EEmntY/HPUNO4U5m/eLeswIq8ITTNRbni2N07AR82Hys3xN7fVimLTUPVouDxwqtUSF5RsGYl46/pg0XbZfEJ7IrVkiy0ZDAk8q7t44FQtxgNrccWcAQwf5lNNfRAdzeC2xsEuB5VUBOqgBN+9+4IZ6VPj9JZv+SrrJs38Kva7TCLH/Sie0l4wLLdEXcvbQxME8vyMzFzP3vg+raqItF+9Ts+9G4uArTGUUGwJUyyykWnxPVLnIcqqPYkPQVldB0S6UmFGETayMzFsDAe9PuqoxiZrBwVhehHTbggJrOfrV1Cx4vf/0GKdGfHf9JNaksxXL7fVtBaQFh7sEBrGPCnb+MVNQSF1n0gSZ60mgyXB+tx6ypckgcP4cgDh2pP23asJ6Uhw4JD+0sLkTfvRM8Kfgi1zehvEm41524H8q+5y2+kNUHXL3xNY8GZ51bTC6W6VzcUGIoE7R/XO95IixyoeUFmNJ3jeivvvhFjDh9lN0e/jYd3AZiDEUm88oPY5cE/eTTluYSjDSXDjQw+muIAcru489OKJlaotO5QYbnbUJRJr+K1R882cTjNKx/AQfK3t8EQi9wSjkEy/jyLxECR1J0IlpO8Fy4+nJ2ei66kiLKzUuFTjPH/siYo5cBvoZm+r68xL7tK4o2UsmMV3WnwC42YrDDK+wVI0voby3pzoPVe6NQzVJvFXyCQEKM370hmXgQQQscp5Z//YrAXnTflRxuA1X/1uwO2VTwqvbXJUDSIwpWnqTj+ZxHLDrhvRTOU5jPVwR+JhaiVONr8udhVyLKhNCLpK1h3zkY5RaEgBY7C3eS6jdCI0PbQYicf5LpFfnkdpZk/L1yiviGXfVbWPFAQpQ+221YCKszhsxZSFkMSEjIjNZaXFycBMil8qt21Bc6cJckHL8D8InMVuo91Ir2EC9qwSVhZyaQ9JrRnrLJFyGEhiNd6saT34ismsgV9IK1agIghUwgZASmtfI1HmNex3E6RxgPnPPsqqaYlgEyMQYcc/2i/HAjkHF+lftqsEgSCHB0XIBnm73KsOTpQJFfe4E/DCpRzrfdoC5qn7/qbWqLYgPpyk0LYLO8+IcZix9tJbwS9sg7lSu5v0VqvwSIZSvT6JfvQJGepUaeu2Gngldaae+X7vtMHe27RK5xtRJsJOZxUfdqrzVS9DWK81PNmpb/4ESOifPvVXkjp2W9pTzUefVTMx48Hs+nm/R1ewHln4igOtkUdoj9mcG670/3tRm+LP5/b53eHZlAFI5nMZNURaEQOrz4qQFX/lAThCTntDd7cUh4VNnwpIruYXPbhLD6Y2Nj6y0E8ujHJK/gbkVF5bQ+x/HrLslglHSUfetAGn1u153pFhCGXzuy+2vU4CvOm6D5mtdotMtRg8Hu6lKCkr0uJcpq/ZJ+stBpJjqBGrZ/SwX+NApGiHsxBXZGLFKdGva5Xmw65a0W+ZjqMnR6ZTyDg/1ksNFhSpNHaAC68nlAg+5wVSLb0QxnbYSRlmEQ6KEc1iMtkKNDxiKS7v22cBSGMZC1i1TYsSm92zDRwojstcMgoHHqhZItXYBA51AJFDMu4RRSVNwavPm2SJGKbW608TehDkyQeUEmkrlTgHvK4nfICgZDQSpJWshzSUWvB2duNDn9H8Ekwf7yB8Tok8EuNc3dQ0A0fcw6ppd/94ezKUTxaRSrnfx3u20Yk/ehmH39OclOY1Kl6XEb/2fIr67idUMDdwm+UHUP3kVeCztDDz75b5yz1oD3t8pNKsBQ20w/RyJekn9Wj4VFiFfeIlGUjh5xm40dPvN9WrHH+XTgFZh/48Df3Z5F0pJ1tRUL7+cRb4YgGfJRQEAxxNvAO4B8qn7/3OiBeZu8NMjotEPYFIXLjUKtbTLhQbzJ2bWfJnLc2pX5VkwydSrPD+8rrpxSXvyMz0KI1vAazyRa7iHsy4hmxuaSADibfs4ybo63wE8rVLlTPTSw6mh5Id+9I02TleWyFegKVmD78ClMvmBV83zAg9kCeDnhRM4/JcLlCml3q3HJhNBmxwqzdzVfEbC4u/IqHhCRrJdfHACSYDT0kdMk+Ra3XOoC11a9hOwWBrbrXxU7OwiNvKqip7mWaEpvkOzhg8mAkVPIZtFqAg4fQpS5xbbf7z3qGFR1qu2HfIJOYivii6/7VS1+OXds5g0cAKWIUENz4UnjQg7COo+d65CTgb+wzFUtVBrm5egwI5BViwPD7WmXOPbl6S54UALu9V0ifqsUefSv4B5lDnL58oYsftHZiU5dNCEozf9IONIjSnhjhHgYuEWl7CC7Oxhg4a0YX82uM6JZEBDCXF8fEQ+TDDJ1FLE9fng9pvxtbpWw9gkxcwXknrUiSP315rZjftoJUm9LiRL4TRpzE45Zmax5x3bk6QQdV0tlbdYbeWTPD1MSP4kMBXpQcQAEtEUK1MYUtwJe4EqCRKjNAFwPruGJrZ1zGAUBU+X2AK/Y95sM2nPsM0Cg5lMAU8ufXKKlzICbMwwDJwtPjt6YGyQuybw025rQS6+fiAx2ctwnWSkakDhoS7667lP/I61LJic1S4evDN6qeMv31E6NM3E5D7GsyQoZMCft6IBEUhCGpgisMNAcssBFHBotQVQLRItX2k3MIEVBZD5C33wpnFMgBBHvXXRG5LHK21glKBfH0Azkr0v58gIWolxXai0cizXceCQ4PNzTKiP93a6hiFRFbpekOnEdEheDwEzuI27wo/Tdp/n4AIU3F+izYdBAWBGluKtTC3UTIMMLAiLycbRscq24OA5fuY/AV/d1kWbQ9RyWSIvRQdKy1zhTM1xK9E7nqNUhoZtSgtTVNt4/ZHi2xeqbG293B5g3XEIk0r4UP4mjpBu4sS1fnmbRpFZF1P5OFyc2p7sJSS3msF42i0dv6ube5RLI89LbMbp2BcGXtzou2Lu7+N3JJBxdLKGMOa0OSpMJoZJIiPwNlJa2O/JEFmVTccstWuo4fyLkEmEpCP6oQsB9MXyoNOxqJTv+b5Fd5qeOT0ikNcZwn4YXwndACIiMvVYaxkCTpsLf1V8Jm8B9aGIc+cAVU/I4/3VWrUJ4hNg6lazTspTFW1Iez6RB9ounsCALtsgOhdwKl/DSmyTBuKxmr0AJRefwTz8NukHBOjdGT6nujhXpg5mKEZgtNS3xhliMu9ZendqAUAkjHseRh/sGzjM4HPPXNfjpfe+svxD2lj0gc6XGwHuMUJEZGAwM/14+Kno07MTzRjxTsA7TjMma5Q52WUF/28lhja8j3AVMQud3Kj8fsa/Sulw3kyvhK2mhURF5sekPpBsNGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":20315,"cache_read_input_tokens":26552,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":20315},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxJMFrLhd9TAa5SheUA","type":"assistant","uuid":"a08ed746-de9f-4aa9-a491-25599ca5d60b","timestamp":"2026-02-09T05:37:44.108Z"}
{"parentUuid":"a08ed746-de9f-4aa9-a491-25599ca5d60b","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_018YU4sNjenndaabGUvmshHz","type":"message","role":"assistant","content":[{"type":"text","text":"I can see 3 conflict regions plus a compile error in `removeShellCompletion`. Let me understand the situation:\n\n- **HEAD** (50cf262): Simplified `isCompletionConfigured`, added shell name to prompt, added \"already configured\" message\n- **Incoming** (b6ff09d): Versioned stanza management replacing the simple check, extracted `promptYesNo` helper\n\nThe resolution should take the incoming stanza approach but keep HEAD's UX improvements (shell name in prompt, \"already configured\" message). Let me also fix `removeShellCompletion` which calls `shellCompletionTarget()` expecting 2 returns but it now returns 4."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":20315,"cache_read_input_tokens":26552,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":20315},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxJMFrLhd9TAa5SheUA","type":"assistant","uuid":"b489cefd-741f-47a7-a132-08a7b9721c9e","timestamp":"2026-02-09T05:37:44.179Z"}
{"parentUuid":"b489cefd-741f-47a7-a132-08a7b9721c9e","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_018YU4sNjenndaabGUvmshHz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HmeZ3LxqQpozLXfHzsPuTT","name":"Edit","input":{"replace_all":false,"file_path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","old_string":"<<<<<<< HEAD\n\tif isCompletionConfigured(rcFile) {\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\tif isCompletionConfigured(rcFile, completionLine) {\n\t\treturn nil\n=======\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n\t}","new_string":"\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":20315,"cache_read_input_tokens":26552,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":20315},"output_tokens":9,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxJMFrLhd9TAa5SheUA","type":"assistant","uuid":"b2856d12-40c8-4aef-bc3a-fd65e1ae0335","timestamp":"2026-02-09T05:37:47.048Z"}
{"type":"file-history-snapshot","messageId":"b2856d12-40c8-4aef-bc3a-fd65e1ae0335","snapshot":{"messageId":"4ad5c823-ce61-4d09-8d9e-8f1752f2c634","trackedFileBackups":{"cmd/entire/cli/setup.go":{"backupFileName":"4186cf26e6fd31ce@v1","version":1,"backupTime":"2026-02-09T05:39:47.701Z"}},"timestamp":"2026-02-09T05:36:50.466Z"},"isSnapshotUpdate":true}
{"parentUuid":"b2856d12-40c8-4aef-bc3a-fd65e1ae0335","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01HmeZ3LxqQpozLXfHzsPuTT","toolUseID":"toolu_01HmeZ3LxqQpozLXfHzsPuTT","timestamp":"2026-02-09T05:39:47.708Z","uuid":"484e0d88-75ae-4cf2-9601-d674a9ecb20f"}
{"parentUuid":"b2856d12-40c8-4aef-bc3a-fd65e1ae0335","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HmeZ3LxqQpozLXfHzsPuTT","type":"tool_result","content":"The file /Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go has been updated successfully."}]},"uuid":"fae59592-b4f9-4b30-95ae-8d9d237c7ede","timestamp":"2026-02-09T05:39:47.707Z","toolUseResult":{"filePath":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","oldString":"<<<<<<< HEAD\n\tif isCompletionConfigured(rcFile) {\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\tif isCompletionConfigured(rcFile, completionLine) {\n\t\treturn nil\n=======\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n\t}","newString":"\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}","originalFile":"package cli\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/entireio/cli/cmd/entire/cli/agent\"\n\t\"github.com/entireio/cli/cmd/entire/cli/paths\"\n\t\"github.com/entireio/cli/cmd/entire/cli/session\"\n\t\"github.com/entireio/cli/cmd/entire/cli/strategy\"\n\n\t\"github.com/charmbracelet/huh\"\n\t\"github.com/spf13/cobra\"\n)\n\n// Strategy display names for user-friendly selection\nconst (\n\tstrategyDisplayManualCommit = \"manual-commit\"\n\tstrategyDisplayAutoCommit   = \"auto-commit\"\n)\n\n// strategyDisplayToInternal maps user-friendly names to internal strategy names\nvar strategyDisplayToInternal = map[string]string{\n\tstrategyDisplayManualCommit: strategy.StrategyNameManualCommit,\n\tstrategyDisplayAutoCommit:   strategy.StrategyNameAutoCommit,\n}\n\n// strategyInternalToDisplay maps internal strategy names to user-friendly names\nvar strategyInternalToDisplay = map[string]string{\n\tstrategy.StrategyNameManualCommit: strategyDisplayManualCommit,\n\tstrategy.StrategyNameAutoCommit:   strategyDisplayAutoCommit,\n}\n\nfunc newEnableCmd() *cobra.Command {\n\tvar localDev bool\n\tvar ignoreUntracked bool\n\tvar useLocalSettings bool\n\tvar useProjectSettings bool\n\tvar agentName string\n\tvar strategyFlag string\n\tvar forceHooks bool\n\tvar skipPushSessions bool\n\tvar telemetry bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"enable\",\n\t\tShort: \"Enable Entire\",\n\t\tLong: `Enable Entire with session tracking for your AI agent workflows.\n\nUses the manual-commit strategy by default. To use a different strategy:\n\n  entire enable --strategy auto-commit\n\nStrategies: manual-commit (default), auto-commit`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\t// Check if we're in a git repository first - this is a prerequisite error,\n\t\t\t// not a usage error, so we silence Cobra's output and use SilentError\n\t\t\t// to prevent duplicate error output in main.go\n\t\t\tif _, err := paths.RepoRoot(); err != nil {\n\t\t\t\tcmd.SilenceUsage = true\n\t\t\t\tcmd.SilenceErrors = true\n\t\t\t\tfmt.Fprintln(cmd.ErrOrStderr(), \"Not a git repository. Please run 'entire enable' from within a git repository.\")\n\t\t\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t\t\t}\n\n\t\t\tif err := validateSetupFlags(useLocalSettings, useProjectSettings); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Non-interactive mode if --agent flag is provided\n\t\t\tif agentName != \"\" {\n\t\t\t\treturn setupAgentHooksNonInteractive(agent.AgentName(agentName), strategyFlag, localDev, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\t// If strategy is specified via flag, skip interactive selection\n\t\t\tif strategyFlag != \"\" {\n\t\t\t\treturn runEnableWithStrategy(cmd.OutOrStdout(), strategyFlag, localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\treturn runEnableInteractive(cmd.OutOrStdout(), localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&localDev, \"local-dev\", false, \"Use go run instead of entire binary for hooks\")\n\tcmd.Flags().MarkHidden(\"local-dev\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&ignoreUntracked, \"ignore-untracked\", false, \"Commit all new files without tracking pre-existing untracked files\")\n\tcmd.Flags().MarkHidden(\"ignore-untracked\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&useLocalSettings, \"local\", false, \"Write settings to settings.local.json instead of settings.json\")\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Write settings to settings.json even if it already exists\")\n\tcmd.Flags().StringVar(&agentName, \"agent\", \"\", \"Agent to setup hooks for (e.g., claude-code). Enables non-interactive mode.\")\n\tcmd.Flags().StringVar(&strategyFlag, \"strategy\", \"\", \"Strategy to use (manual-commit or auto-commit)\")\n\tcmd.Flags().BoolVarP(&forceHooks, \"force\", \"f\", false, \"Force reinstall hooks (removes existing Entire hooks first)\")\n\tcmd.Flags().BoolVar(&skipPushSessions, \"skip-push-sessions\", false, \"Disable automatic pushing of session logs on git push\")\n\tcmd.Flags().BoolVar(&telemetry, \"telemetry\", true, \"Enable anonymous usage analytics\")\n\t//nolint:errcheck,gosec // completion is optional, flag is defined above\n\tcmd.RegisterFlagCompletionFunc(\"strategy\", func(_ *cobra.Command, _ []string, _ string) ([]string, cobra.ShellCompDirective) {\n\t\treturn []string{strategyDisplayManualCommit, strategyDisplayAutoCommit}, cobra.ShellCompDirectiveNoFileComp\n\t})\n\n\t// Add subcommands for automation/testing\n\tcmd.AddCommand(newSetupGitHookCmd())\n\n\treturn cmd\n}\n\nfunc newDisableCmd() *cobra.Command {\n\tvar useProjectSettings bool\n\tvar uninstall bool\n\tvar force bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"disable\",\n\t\tShort: \"Disable Entire\",\n\t\tLong: `Disable Entire temporarily. Hooks will exit silently and commands will show a disabled message.\n\nUse --uninstall to completely remove Entire from this repository, including:\n  - .entire/ directory (settings, logs, metadata)\n  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\n  - Session state files (.git/entire-sessions/)\n  - Shadow branches (entire/<hash>)\n  - Agent hooks (Claude Code, Gemini CLI)`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tif uninstall {\n\t\t\t\treturn runUninstall(cmd.OutOrStdout(), cmd.ErrOrStderr(), force)\n\t\t\t}\n\t\t\treturn runDisable(cmd.OutOrStdout(), useProjectSettings)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Update settings.json instead of settings.local.json\")\n\tcmd.Flags().BoolVar(&uninstall, \"uninstall\", false, \"Completely remove Entire from this repository\")\n\tcmd.Flags().BoolVar(&force, \"force\", false, \"Skip confirmation prompt (use with --uninstall)\")\n\n\treturn cmd\n}\n\n// runEnableWithStrategy enables Entire with a specified strategy (non-interactive).\n// The selectedStrategy can be either a display name (manual-commit, auto-commit)\n// or an internal name (manual-commit, auto-commit).\nfunc runEnableWithStrategy(w io.Writer, selectedStrategy string, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Map the strategy to internal name if it's a display name\n\tinternalStrategy := selectedStrategy\n\tif mapped, ok := strategyDisplayToInternal[selectedStrategy]; ok {\n\t\tinternalStrategy = mapped\n\t}\n\n\t// Validate the strategy exists\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", selectedStrategy)\n\t}\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\t// Determine which settings file to write to\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, showNotification := determineSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\n\tif showNotification {\n\t\tfmt.Fprintln(w, \"Info: Project settings exist. Saving to settings.local.json instead.\")\n\t\tfmt.Fprintln(w, \"  Use --project to update the project settings file.\")\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tdisplayName := selectedStrategy\n\tif dn, ok := strategyInternalToDisplay[internalStrategy]; ok {\n\t\tdisplayName = dn\n\t}\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", displayName)\n\n\treturn nil\n}\n\n// runEnableInteractive runs the interactive enable flow.\nfunc runEnableInteractive(w io.Writer, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Use the default strategy (manual-commit)\n\tinternalStrategy := strategy.DefaultStrategyName\n\tfmt.Fprintf(w, \"Using %s strategy (use --strategy to change)\\n\\n\", strategyInternalToDisplay[internalStrategy])\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Ask about telemetry consent (only if not already asked)\n\tif err := promptTelemetryConsent(settings, telemetry); err != nil {\n\t\treturn fmt.Errorf(\"telemetry consent: %w\", err)\n\t}\n\n\t// Determine which settings file to write to (interactive prompt if settings.json exists)\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, err := promptSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", strategyInternalToDisplay[internalStrategy])\n\n\treturn nil\n}\n\n// runEnable is a simple enable that just sets the enabled flag (for programmatic use).\nfunc runEnable(w io.Writer) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = true\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now enabled.\")\n\treturn nil\n}\n\nfunc runDisable(w io.Writer, useProjectSettings bool) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = false\n\n\t// If --project flag is specified, always write to project settings\n\tif useProjectSettings {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t} else {\n\t\t// Always write to local settings file (create if doesn't exist)\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now disabled.\")\n\treturn nil\n}\n\n// DisabledMessage is the message shown when Entire is disabled\nconst DisabledMessage = \"Entire is disabled. Run `entire enable` to re-enable.\"\n\n// checkDisabledGuard checks if Entire is disabled and prints a message if so.\n// Returns true if the caller should exit (i.e., Entire is disabled).\n// On error reading settings, defaults to enabled (returns false).\nfunc checkDisabledGuard(w io.Writer) bool {\n\tenabled, err := IsEnabled()\n\tif err != nil {\n\t\t// Default to enabled on error\n\t\treturn false\n\t}\n\tif !enabled {\n\t\tfmt.Fprintln(w, DisabledMessage)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// setupClaudeCodeHook sets up Claude Code hooks.\n// This is a convenience wrapper that uses the agent package.\n// Returns the number of hooks installed (0 if already installed).\nfunc setupClaudeCodeHook(localDev, forceHooks bool) (int, error) {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get claude-code agent: %w\", err)\n\t}\n\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn 0, errors.New(\"claude-code agent does not support hooks\")\n\t}\n\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to install claude-code hooks: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// setupAgentHooksNonInteractive sets up hooks for a specific agent non-interactively.\n// If strategyName is provided, it sets the strategy; otherwise uses default.\nfunc setupAgentHooksNonInteractive(agentName agent.AgentName, strategyName string, localDev, forceHooks, skipPushSessions, telemetry bool) error {\n\tag, err := agent.Get(agentName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown agent: %s\", agentName)\n\t}\n\n\t// Check if agent supports hooks\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn fmt.Errorf(\"agent %s does not support hooks\", agentName)\n\t}\n\n\t// Install hooks\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install hooks for %s: %w\", agentName, err)\n\t}\n\n\tif count == 0 {\n\t\tmsg := fmt.Sprintf(\"Hooks for %s already installed\", ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t} else {\n\t\tmsg := fmt.Sprintf(\"Installed %d hooks for %s\", count, ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\n\t// Update settings to store the strategy\n\tsettings, _ := LoadEntireSettings() //nolint:errcheck // settings defaults are fine\n\tsettings.Enabled = true\n\tif localDev {\n\t\tsettings.LocalDev = localDev\n\t}\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Set strategy if provided\n\tif strategyName != \"\" {\n\t\t// Map display name to internal name if needed\n\t\tinternalStrategy := strategyName\n\t\tif mapped, ok := strategyDisplayToInternal[strategyName]; ok {\n\t\t\tinternalStrategy = mapped\n\t\t}\n\t\t// Validate the strategy exists\n\t\tif _, err := strategy.Get(internalStrategy); err != nil {\n\t\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", strategyName)\n\t\t}\n\t\tsettings.Strategy = internalStrategy\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tif _, err := strategy.InstallGitHook(true); err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\n\t// Let the strategy handle its own setup requirements (creates entire/sessions branch, etc.)\n\tstrat, err := strategy.Get(settings.Strategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// validateSetupFlags checks that --local and --project flags are not both specified.\nfunc validateSetupFlags(useLocal, useProject bool) error {\n\tif useLocal && useProject {\n\t\treturn errors.New(\"cannot specify both --project and --local\")\n\t}\n\treturn nil\n}\n\n// determineSettingsTarget decides whether to write to settings.local.json based on:\n// - Whether settings.json already exists\n// - The --local and --project flags\n// Returns (useLocal, showNotification).\nfunc determineSettingsTarget(entireDir string, useLocal, useProject bool) (bool, bool) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, false\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, false\n\t}\n\n\t// No flags specified - check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); err == nil {\n\t\t// Settings file exists - auto-redirect to local with notification\n\t\treturn true, true\n\t}\n\n\t// Settings file doesn't exist - create it\n\treturn false, false\n}\n\n// Settings target options for interactive prompt\nconst (\n\tsettingsTargetProject = \"project\"\n\tsettingsTargetLocal   = \"local\"\n)\n\n// promptSettingsTarget interactively asks the user where to save settings\n// when settings.json already exists and no flags were provided.\n// Returns (useLocal, error).\nfunc promptSettingsTarget(entireDir string, useLocal, useProject bool) (bool, error) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, nil\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, nil\n\t}\n\n\t// Check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); os.IsNotExist(err) {\n\t\t// Settings file doesn't exist - create it (no prompt needed)\n\t\treturn false, nil\n\t}\n\n\t// Settings file exists - prompt user\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(\"Project settings already exist. Where should settings be saved?\").\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Update project settings (settings.json)\", settingsTargetProject),\n\t\t\t\t\thuh.NewOption(\"Use local settings (settings.local.json, gitignored)\", settingsTargetLocal),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false, fmt.Errorf(\"selection cancelled: %w\", err)\n\t}\n\n\treturn selected == settingsTargetLocal, nil\n}\n\n// setupEntireDirectory creates the .entire directory and gitignore.\n// Returns true if the directory was created, false if it already existed.\nfunc setupEntireDirectory() (bool, error) {\n\t// Get absolute path for the .entire directory\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\n\t// Check if directory already exists\n\tcreated := false\n\tif _, err := os.Stat(entireDirAbs); os.IsNotExist(err) {\n\t\tcreated = true\n\t}\n\n\t// Create .entire directory\n\t//nolint:gosec // G301: Project directory needs standard permissions for git\n\tif err := os.MkdirAll(entireDirAbs, 0o755); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to create .entire directory: %w\", err)\n\t}\n\n\t// Create/update .gitignore with all required entries\n\tif err := strategy.EnsureEntireGitignore(); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to setup .gitignore: %w\", err)\n\t}\n\n\treturn created, nil\n}\n\n// setupGitHook installs the prepare-commit-msg hook for context trailers.\nfunc setupGitHook() error {\n\t// Use shared implementation from strategy package\n\t// The localDev setting is read from settings.json\n\t_, err := strategy.InstallGitHook(false) // not silent - show output during setup\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hook: %w\", err)\n\t}\n\treturn nil\n}\n\n// newSetupGitHookCmd creates the standalone git-hook setup command\nfunc newSetupGitHookCmd() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:    \"git-hook\",\n\t\tShort:  \"Install git hook for session context trailers\",\n\t\tHidden: true, // Hidden as it's mainly for testing\n\t\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\treturn setupGitHook()\n\t\t},\n\t}\n\n\treturn cmd\n}\n\nfunc newCurlBashPostInstallCmd() *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:    \"curl-bash-post-install\",\n\t\tShort:  \"Post-install tasks for curl|bash installer\",\n\t\tHidden: true,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tw := cmd.OutOrStdout()\n\t\t\tif err := promptShellCompletion(w); err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Note: Shell completion setup skipped: %v\\n\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n}\n\n// Shell completion stanza management.\n// The stanza is a versioned, delimited block written to ~/.zshrc or ~/.bashrc:\n//\n//\t# Entire CLI completions (v1) {{{\n//\tautoload -Uz compinit && compinit && source <(entire completion zsh)\n//\t# }}}\nconst (\n\tshellCompletionStanzaVersion = 1\n\tshellCompletionOpenFormat    = \"# Entire CLI completions (v%d) {{{\"\n\tshellCompletionClose         = \"# }}}\"\n\tshellCompletionLegacyComment = \"# Entire CLI shell completion\" // old format for migration\n)\n\ntype stanzaStatus int\n\nconst (\n\tstanzaNotFound stanzaStatus = iota\n\tstanzaCurrent\n\tstanzaOutdated\n\tstanzaLegacy\n)\n\nvar (\n\terrStanzaCorrupted = errors.New(\"shell completion block is corrupted (missing closing marker)\")\n\terrMultipleStanzas = errors.New(\"found multiple shell completion blocks\")\n)\n\n// findStanzaVersion scans content for the opening stanza marker and returns\n// the version number. Returns 0 if no stanza is found.\nfunc findStanzaVersion(content string) int {\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\treturn version\n\t\t}\n\t}\n\treturn 0\n}\n\n// checkStanzaStatus determines the status of the shell completion stanza in content.\nfunc checkStanzaStatus(content string, currentVersion int) stanzaStatus {\n\tversion := findStanzaVersion(content)\n\tif version > 0 {\n\t\tif version >= currentVersion {\n\t\t\treturn stanzaCurrent\n\t\t}\n\t\treturn stanzaOutdated\n\t}\n\tif strings.Contains(content, shellCompletionLegacyComment) {\n\t\treturn stanzaLegacy\n\t}\n\treturn stanzaNotFound\n}\n\n// buildStanza constructs the full stanza block for the given version and completion line.\nfunc buildStanza(version int, completionLine string) string {\n\treturn fmt.Sprintf(shellCompletionOpenFormat, version) + \"\\n\" + completionLine + \"\\n\" + shellCompletionClose\n}\n\n// countStanzaOpeners counts how many opening stanza markers exist in content.\nfunc countStanzaOpeners(content string) int {\n\tcount := 0\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n// replaceStanza finds the open+close markers in content and replaces the block\n// with a new stanza. Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc replaceStanza(content string, version int, completionLine string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tnewStanza := buildStanza(version, completionLine)\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\tresult = append(result, newStanza)\n\tresult = append(result, lines[closeIdx+1:]...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeStanza finds and removes the stanza block from content.\n// Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc removeStanza(content string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\t// Skip blank line immediately after stanza if present\n\ttail := lines[closeIdx+1:]\n\tif len(tail) > 0 && strings.TrimSpace(tail[0]) == \"\" {\n\t\ttail = tail[1:]\n\t}\n\tresult = append(result, tail...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeLegacyCompletion removes the old-format comment and its following\n// completion line from content. Returns the modified content and whether\n// anything was removed.\nfunc removeLegacyCompletion(content, completionLine string) (string, bool) {\n\tlines := strings.Split(content, \"\\n\")\n\tvar result []string\n\tremoved := false\n\tfor i := 0; i < len(lines); i++ {\n\t\tif strings.TrimSpace(lines[i]) == shellCompletionLegacyComment {\n\t\t\t// Remove the comment line and the next line if it matches the completion line\n\t\t\tif i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == completionLine {\n\t\t\t\ti++ // skip next line too\n\t\t\t}\n\t\t\tremoved = true\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, lines[i])\n\t}\n\tif !removed {\n\t\treturn content, false\n\t}\n\treturn strings.Join(result, \"\\n\"), true\n}\n\n// errUnsupportedShell is returned when the user's shell is not supported for completion.\nvar errUnsupportedShell = errors.New(\"unsupported shell\")\n\n// shellCompletionTarget returns the rc file path and completion lines for the\n// user's current shell.\nfunc shellCompletionTarget() (shellName, rcFile, completionLine string, err error) {\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", fmt.Errorf(\"cannot determine home directory: %w\", err)\n\t}\n\n\tshell := os.Getenv(\"SHELL\")\n\tswitch {\n\tcase strings.Contains(shell, \"zsh\"):\n\t\treturn \"Zsh\",\n\t\t\tfilepath.Join(home, \".zshrc\"),\n\t\t\t\"source <(entire completion zsh)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"bash\"):\n\t\treturn \"Bash\",\n\t\t\tfilepath.Join(home, \".bashrc\"),\n\t\t\t\"source <(entire completion bash)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"fish\"):\n\t\treturn \"Fish\",\n\t\t\tfilepath.Join(home, \".config\", \"fish\", \"config.fish\"),\n\t\t\t\"entire completion fish | source\",\n\t\t\tnil\n\tdefault:\n\t\treturn \"\", \"\", \"\", errUnsupportedShell\n\t}\n}\n\n// promptShellCompletion offers to add shell completion to the user's rc file.\n// Handles versioned stanza detection, updates, and legacy migration.\nfunc promptShellCompletion(w io.Writer) error {\n\tshellName, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\tif errors.Is(err, errUnsupportedShell) {\n\t\t\tfmt.Fprintf(w, \"Note: Shell completion not available for your shell. Supported: zsh, bash, fish.\\n\")\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"shell completion: %w\", err)\n\t}\n\n<<<<<<< HEAD\n\tif isCompletionConfigured(rcFile) {\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\tif isCompletionConfigured(rcFile, completionLine) {\n\t\treturn nil\n=======\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n\t}\n\n\tstatus := checkStanzaStatus(string(content), shellCompletionStanzaVersion)\n\tswitch status {\n\tcase stanzaCurrent:\n\t\treturn nil\n\n\tcase stanzaOutdated:\n\t\tif !promptYesNo(\"Shell completion is outdated. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t// Re-read in case file changed\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, replaceErr := replaceStanza(string(content), shellCompletionStanzaVersion, completionLine)\n\t\tif replaceErr != nil {\n\t\t\tfmt.Fprintf(w, \"Warning: %v in %s. Please fix manually.\\n\", replaceErr, rcFile)\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaLegacy:\n\t\tif !promptYesNo(\"Shell completion uses old format. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, _ := removeLegacyCompletion(string(content), completionLine)\n\t\tupdated = updated + \"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\"\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaNotFound:\n\t\tif !promptYesNo(\"Enable shell completion?\") {\n\t\t\treturn nil\n\t\t}\n\t\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t}\n\n\treturn nil\n}\n\n// promptYesNo shows a yes/no selection prompt and returns whether the user chose yes.\nfunc promptYesNo(title string) bool {\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n<<<<<<< HEAD\n\t\t\t\tTitle(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)).\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tTitle(\"Enable shell completion?\").\n=======\n\t\t\t\tTitle(title).\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Yes\", \"yes\"),\n\t\t\t\t\thuh.NewOption(\"No\", \"no\"),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n<<<<<<< HEAD\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Restart your shell to activate\")\n\n\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\n\treturn nil\n=======\n\treturn selected == \"yes\"\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n}\n\n<<<<<<< HEAD\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), \"entire completion\")\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string, completionLine string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), completionLine)\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n=======\n// appendShellCompletion adds the completion stanza to the rc file.\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\nfunc appendShellCompletion(rcFile, completionLine string) error {\n\tif err := os.MkdirAll(filepath.Dir(rcFile), 0o755); err != nil {\n\t\treturn fmt.Errorf(\"creating directory: %w\", err)\n\t}\n\t//nolint:gosec // G302: Shell rc files need 0644 for user readability\n\tf, err := os.OpenFile(rcFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(\"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing completion: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeShellCompletion removes the shell completion stanza (or legacy format)\n// from the user's rc file. Used during uninstall.\nfunc removeShellCompletion() error {\n\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\ttext := string(content)\n\tupdated, removeErr := removeStanza(text)\n\tif removeErr != nil {\n\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n\t}\n\n\tif updated != text {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Fall back to legacy format removal\n\tupdated, removed := removeLegacyCompletion(text, completionLine)\n\tif removed {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// promptTelemetryConsent asks the user if they want to enable telemetry.\n// It modifies settings.Telemetry based on the user's choice or flags.\n// The caller is responsible for saving settings.\nfunc promptTelemetryConsent(settings *EntireSettings, telemetryFlag bool) error {\n\t// Handle --telemetry=false flag first (always overrides existing setting)\n\tif !telemetryFlag {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\t// Skip if already asked\n\tif settings.Telemetry != nil {\n\t\treturn nil\n\t}\n\n\t// Skip if env var disables telemetry (record as disabled)\n\tif os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\tconsent := true // Default to Yes\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewConfirm().\n\t\t\t\tTitle(\"Help improve Entire CLI?\").\n\t\t\t\tDescription(\"Share anonymous usage data. No code or personal info collected.\").\n\t\t\t\tAffirmative(\"Yes\").\n\t\t\t\tNegative(\"No\").\n\t\t\t\tValue(&consent),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn fmt.Errorf(\"telemetry prompt: %w\", err)\n\t}\n\n\tsettings.Telemetry = &consent\n\treturn nil\n}\n\n// runUninstall completely removes Entire from the repository.\nfunc runUninstall(w, errW io.Writer, force bool) error {\n\t// Check if we're in a git repository\n\tif _, err := paths.RepoRoot(); err != nil {\n\t\tfmt.Fprintln(errW, \"Not a git repository. Nothing to uninstall.\")\n\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t}\n\n\t// Gather counts for display\n\tsessionStateCount := countSessionStates()\n\tshadowBranchCount := countShadowBranches()\n\tgitHooksInstalled := strategy.IsGitHookInstalled()\n\tclaudeHooksInstalled := checkClaudeCodeHooksInstalled()\n\tgeminiHooksInstalled := checkGeminiCLIHooksInstalled()\n\tentireDirExists := checkEntireDirExists()\n\n\t// Check if there's anything to uninstall\n\tif !entireDirExists && !gitHooksInstalled && sessionStateCount == 0 &&\n\t\tshadowBranchCount == 0 && !claudeHooksInstalled && !geminiHooksInstalled {\n\t\tfmt.Fprintln(w, \"Entire is not installed in this repository.\")\n\t\treturn nil\n\t}\n\n\t// Show confirmation prompt unless --force\n\tif !force {\n\t\tfmt.Fprintln(w, \"\\nThis will completely remove Entire from this repository:\")\n\t\tif entireDirExists {\n\t\t\tfmt.Fprintln(w, \"  - .entire/ directory\")\n\t\t}\n\t\tif gitHooksInstalled {\n\t\t\tfmt.Fprintln(w, \"  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\")\n\t\t}\n\t\tif sessionStateCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Session state files (%d)\\n\", sessionStateCount)\n\t\t}\n\t\tif shadowBranchCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Shadow branches (%d)\\n\", shadowBranchCount)\n\t\t}\n\t\tswitch {\n\t\tcase claudeHooksInstalled && geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code, Gemini CLI)\")\n\t\tcase claudeHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code)\")\n\t\tcase geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Gemini CLI)\")\n\t\t}\n\t\tfmt.Fprintln(w)\n\n\t\tvar confirmed bool\n\t\tform := NewAccessibleForm(\n\t\t\thuh.NewGroup(\n\t\t\t\thuh.NewConfirm().\n\t\t\t\t\tTitle(\"Are you sure you want to uninstall Entire?\").\n\t\t\t\t\tAffirmative(\"Yes, uninstall\").\n\t\t\t\t\tNegative(\"Cancel\").\n\t\t\t\t\tValue(&confirmed),\n\t\t\t),\n\t\t)\n\n\t\tif err := form.Run(); err != nil {\n\t\t\treturn fmt.Errorf(\"confirmation cancelled: %w\", err)\n\t\t}\n\n\t\tif !confirmed {\n\t\t\tfmt.Fprintln(w, \"Uninstall cancelled.\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"\\nUninstalling Entire CLI...\")\n\n\t// 0. Remove shell completion from rc file\n\tif err := removeShellCompletion(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shell completion: %v\\n\", err)\n\t} else {\n\t\tfmt.Fprintln(w, \"  Removed shell completion\")\n\t}\n\n\t// 1. Remove agent hooks (lowest risk)\n\tif err := removeAgentHooks(w); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove agent hooks: %v\\n\", err)\n\t}\n\n\t// 2. Remove git hooks\n\tremoved, err := strategy.RemoveGitHook()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove git hooks: %v\\n\", err)\n\t} else if removed > 0 {\n\t\tfmt.Fprintf(w, \"  Removed git hooks (%d)\\n\", removed)\n\t}\n\n\t// 3. Remove session state files\n\tstatesRemoved, err := removeAllSessionStates()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove session states: %v\\n\", err)\n\t} else if statesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed session states (%d)\\n\", statesRemoved)\n\t}\n\n\t// 4. Remove .entire/ directory\n\tif err := removeEntireDirectory(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove .entire directory: %v\\n\", err)\n\t} else if entireDirExists {\n\t\tfmt.Fprintln(w, \"  Removed .entire directory\")\n\t}\n\n\t// 5. Remove shadow branches\n\tbranchesRemoved, err := removeAllShadowBranches()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shadow branches: %v\\n\", err)\n\t} else if branchesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed %d shadow branches\\n\", branchesRemoved)\n\t}\n\n\tfmt.Fprintln(w, \"\\nEntire CLI uninstalled successfully.\")\n\treturn nil\n}\n\n// countSessionStates returns the number of active session state files.\nfunc countSessionStates() int {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0\n\t}\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(states)\n}\n\n// countShadowBranches returns the number of shadow branches.\nfunc countShadowBranches() int {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(branches)\n}\n\n// checkClaudeCodeHooksInstalled checks if Claude Code hooks are installed.\nfunc checkClaudeCodeHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkGeminiCLIHooksInstalled checks if Gemini CLI hooks are installed.\nfunc checkGeminiCLIHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameGemini)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkEntireDirExists checks if the .entire directory exists.\nfunc checkEntireDirExists() bool {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\t_, err = os.Stat(entireDirAbs)\n\treturn err == nil\n}\n\n// removeAgentHooks removes hooks from all agents that support hooks.\nfunc removeAgentHooks(w io.Writer) error {\n\tvar errs []error\n\n\t// Remove Claude Code hooks\n\tclaudeAgent, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err == nil {\n\t\tif hookAgent, ok := claudeAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Claude Code hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove Gemini CLI hooks\n\tgeminiAgent, err := agent.Get(agent.AgentNameGemini)\n\tif err == nil {\n\t\tif hookAgent, ok := geminiAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Gemini CLI hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errors.Join(errs...)\n}\n\n// removeAllSessionStates removes all session state files and the directory.\nfunc removeAllSessionStates() (int, error) {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to create state store: %w\", err)\n\t}\n\n\t// Count states before removing\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list session states: %w\", err)\n\t}\n\tcount := len(states)\n\n\t// Remove the entire directory\n\tif err := store.RemoveAll(); err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to remove session states: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// removeEntireDirectory removes the .entire directory.\nfunc removeEntireDirectory() error {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\tif err := os.RemoveAll(entireDirAbs); err != nil {\n\t\treturn fmt.Errorf(\"failed to remove .entire directory: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeAllShadowBranches removes all shadow branches.\nfunc removeAllShadowBranches() (int, error) {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list shadow branches: %w\", err)\n\t}\n\tif len(branches) == 0 {\n\t\treturn 0, nil\n\t}\n\tdeleted, _, err := strategy.DeleteShadowBranches(branches)\n\treturn len(deleted), err\n}\n","structuredPatch":[{"oldStart":894,"oldLines":19,"newStart":894,"newLines":10,"lines":["     return fmt.Errorf(\"shell completion: %w\", err)","   }"," ","-<<<<<<< HEAD","-  if isCompletionConfigured(rcFile) {","-    fmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)","-    return nil","-||||||| parent of b6ff09d (Add versioned stanza management for shell completion)","-  if isCompletionConfigured(rcFile, completionLine) {","-    return nil","-=======","   //nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input","   content, err := os.ReadFile(rcFile)","   if err != nil && !os.IsNotExist(err) {","     return fmt.Errorf(\"reading %s: %w\", rcFile, err)","->>>>>>> b6ff09d (Add versioned stanza management for shell completion)","   }"," ","   status := checkStanzaStatus(string(content), shellCompletionStanzaVersion)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"b2856d12-40c8-4aef-bc3a-fd65e1ae0335"}
{"parentUuid":"fae59592-b4f9-4b30-95ae-8d9d237c7ede","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01L2fH1vTJZ36W4AHjpYqScP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016z3MdUuTWTPU9fZ86S2XAn","name":"Edit","input":{"replace_all":false,"file_path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","old_string":"\tcase stanzaCurrent:\n\t\treturn nil","new_string":"\tcase stanzaCurrent:\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2325,"cache_read_input_tokens":46867,"output_tokens":162,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":2325,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXwxWjyRjiDxhAHTZXp6L","type":"assistant","uuid":"ed211c37-79ff-4268-b3e4-dbddacd2226b","timestamp":"2026-02-09T05:39:54.412Z"}
{"parentUuid":"ed211c37-79ff-4268-b3e4-dbddacd2226b","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_016z3MdUuTWTPU9fZ86S2XAn","toolUseID":"toolu_016z3MdUuTWTPU9fZ86S2XAn","timestamp":"2026-02-09T05:40:10.947Z","uuid":"e10fc0fd-1d0c-4e2d-9d89-e490bb0098e2"}
{"parentUuid":"ed211c37-79ff-4268-b3e4-dbddacd2226b","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016z3MdUuTWTPU9fZ86S2XAn","type":"tool_result","content":"The file /Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go has been updated successfully."}]},"uuid":"1015383e-ed1d-4569-a0dd-0cb0dd44475c","timestamp":"2026-02-09T05:40:10.946Z","toolUseResult":{"filePath":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","oldString":"\tcase stanzaCurrent:\n\t\treturn nil","newString":"\tcase stanzaCurrent:\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil","originalFile":"package cli\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/entireio/cli/cmd/entire/cli/agent\"\n\t\"github.com/entireio/cli/cmd/entire/cli/paths\"\n\t\"github.com/entireio/cli/cmd/entire/cli/session\"\n\t\"github.com/entireio/cli/cmd/entire/cli/strategy\"\n\n\t\"github.com/charmbracelet/huh\"\n\t\"github.com/spf13/cobra\"\n)\n\n// Strategy display names for user-friendly selection\nconst (\n\tstrategyDisplayManualCommit = \"manual-commit\"\n\tstrategyDisplayAutoCommit   = \"auto-commit\"\n)\n\n// strategyDisplayToInternal maps user-friendly names to internal strategy names\nvar strategyDisplayToInternal = map[string]string{\n\tstrategyDisplayManualCommit: strategy.StrategyNameManualCommit,\n\tstrategyDisplayAutoCommit:   strategy.StrategyNameAutoCommit,\n}\n\n// strategyInternalToDisplay maps internal strategy names to user-friendly names\nvar strategyInternalToDisplay = map[string]string{\n\tstrategy.StrategyNameManualCommit: strategyDisplayManualCommit,\n\tstrategy.StrategyNameAutoCommit:   strategyDisplayAutoCommit,\n}\n\nfunc newEnableCmd() *cobra.Command {\n\tvar localDev bool\n\tvar ignoreUntracked bool\n\tvar useLocalSettings bool\n\tvar useProjectSettings bool\n\tvar agentName string\n\tvar strategyFlag string\n\tvar forceHooks bool\n\tvar skipPushSessions bool\n\tvar telemetry bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"enable\",\n\t\tShort: \"Enable Entire\",\n\t\tLong: `Enable Entire with session tracking for your AI agent workflows.\n\nUses the manual-commit strategy by default. To use a different strategy:\n\n  entire enable --strategy auto-commit\n\nStrategies: manual-commit (default), auto-commit`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\t// Check if we're in a git repository first - this is a prerequisite error,\n\t\t\t// not a usage error, so we silence Cobra's output and use SilentError\n\t\t\t// to prevent duplicate error output in main.go\n\t\t\tif _, err := paths.RepoRoot(); err != nil {\n\t\t\t\tcmd.SilenceUsage = true\n\t\t\t\tcmd.SilenceErrors = true\n\t\t\t\tfmt.Fprintln(cmd.ErrOrStderr(), \"Not a git repository. Please run 'entire enable' from within a git repository.\")\n\t\t\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t\t\t}\n\n\t\t\tif err := validateSetupFlags(useLocalSettings, useProjectSettings); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Non-interactive mode if --agent flag is provided\n\t\t\tif agentName != \"\" {\n\t\t\t\treturn setupAgentHooksNonInteractive(agent.AgentName(agentName), strategyFlag, localDev, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\t// If strategy is specified via flag, skip interactive selection\n\t\t\tif strategyFlag != \"\" {\n\t\t\t\treturn runEnableWithStrategy(cmd.OutOrStdout(), strategyFlag, localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\treturn runEnableInteractive(cmd.OutOrStdout(), localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&localDev, \"local-dev\", false, \"Use go run instead of entire binary for hooks\")\n\tcmd.Flags().MarkHidden(\"local-dev\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&ignoreUntracked, \"ignore-untracked\", false, \"Commit all new files without tracking pre-existing untracked files\")\n\tcmd.Flags().MarkHidden(\"ignore-untracked\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&useLocalSettings, \"local\", false, \"Write settings to settings.local.json instead of settings.json\")\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Write settings to settings.json even if it already exists\")\n\tcmd.Flags().StringVar(&agentName, \"agent\", \"\", \"Agent to setup hooks for (e.g., claude-code). Enables non-interactive mode.\")\n\tcmd.Flags().StringVar(&strategyFlag, \"strategy\", \"\", \"Strategy to use (manual-commit or auto-commit)\")\n\tcmd.Flags().BoolVarP(&forceHooks, \"force\", \"f\", false, \"Force reinstall hooks (removes existing Entire hooks first)\")\n\tcmd.Flags().BoolVar(&skipPushSessions, \"skip-push-sessions\", false, \"Disable automatic pushing of session logs on git push\")\n\tcmd.Flags().BoolVar(&telemetry, \"telemetry\", true, \"Enable anonymous usage analytics\")\n\t//nolint:errcheck,gosec // completion is optional, flag is defined above\n\tcmd.RegisterFlagCompletionFunc(\"strategy\", func(_ *cobra.Command, _ []string, _ string) ([]string, cobra.ShellCompDirective) {\n\t\treturn []string{strategyDisplayManualCommit, strategyDisplayAutoCommit}, cobra.ShellCompDirectiveNoFileComp\n\t})\n\n\t// Add subcommands for automation/testing\n\tcmd.AddCommand(newSetupGitHookCmd())\n\n\treturn cmd\n}\n\nfunc newDisableCmd() *cobra.Command {\n\tvar useProjectSettings bool\n\tvar uninstall bool\n\tvar force bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"disable\",\n\t\tShort: \"Disable Entire\",\n\t\tLong: `Disable Entire temporarily. Hooks will exit silently and commands will show a disabled message.\n\nUse --uninstall to completely remove Entire from this repository, including:\n  - .entire/ directory (settings, logs, metadata)\n  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\n  - Session state files (.git/entire-sessions/)\n  - Shadow branches (entire/<hash>)\n  - Agent hooks (Claude Code, Gemini CLI)`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tif uninstall {\n\t\t\t\treturn runUninstall(cmd.OutOrStdout(), cmd.ErrOrStderr(), force)\n\t\t\t}\n\t\t\treturn runDisable(cmd.OutOrStdout(), useProjectSettings)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Update settings.json instead of settings.local.json\")\n\tcmd.Flags().BoolVar(&uninstall, \"uninstall\", false, \"Completely remove Entire from this repository\")\n\tcmd.Flags().BoolVar(&force, \"force\", false, \"Skip confirmation prompt (use with --uninstall)\")\n\n\treturn cmd\n}\n\n// runEnableWithStrategy enables Entire with a specified strategy (non-interactive).\n// The selectedStrategy can be either a display name (manual-commit, auto-commit)\n// or an internal name (manual-commit, auto-commit).\nfunc runEnableWithStrategy(w io.Writer, selectedStrategy string, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Map the strategy to internal name if it's a display name\n\tinternalStrategy := selectedStrategy\n\tif mapped, ok := strategyDisplayToInternal[selectedStrategy]; ok {\n\t\tinternalStrategy = mapped\n\t}\n\n\t// Validate the strategy exists\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", selectedStrategy)\n\t}\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\t// Determine which settings file to write to\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, showNotification := determineSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\n\tif showNotification {\n\t\tfmt.Fprintln(w, \"Info: Project settings exist. Saving to settings.local.json instead.\")\n\t\tfmt.Fprintln(w, \"  Use --project to update the project settings file.\")\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tdisplayName := selectedStrategy\n\tif dn, ok := strategyInternalToDisplay[internalStrategy]; ok {\n\t\tdisplayName = dn\n\t}\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", displayName)\n\n\treturn nil\n}\n\n// runEnableInteractive runs the interactive enable flow.\nfunc runEnableInteractive(w io.Writer, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Use the default strategy (manual-commit)\n\tinternalStrategy := strategy.DefaultStrategyName\n\tfmt.Fprintf(w, \"Using %s strategy (use --strategy to change)\\n\\n\", strategyInternalToDisplay[internalStrategy])\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Ask about telemetry consent (only if not already asked)\n\tif err := promptTelemetryConsent(settings, telemetry); err != nil {\n\t\treturn fmt.Errorf(\"telemetry consent: %w\", err)\n\t}\n\n\t// Determine which settings file to write to (interactive prompt if settings.json exists)\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, err := promptSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", strategyInternalToDisplay[internalStrategy])\n\n\treturn nil\n}\n\n// runEnable is a simple enable that just sets the enabled flag (for programmatic use).\nfunc runEnable(w io.Writer) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = true\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now enabled.\")\n\treturn nil\n}\n\nfunc runDisable(w io.Writer, useProjectSettings bool) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = false\n\n\t// If --project flag is specified, always write to project settings\n\tif useProjectSettings {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t} else {\n\t\t// Always write to local settings file (create if doesn't exist)\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now disabled.\")\n\treturn nil\n}\n\n// DisabledMessage is the message shown when Entire is disabled\nconst DisabledMessage = \"Entire is disabled. Run `entire enable` to re-enable.\"\n\n// checkDisabledGuard checks if Entire is disabled and prints a message if so.\n// Returns true if the caller should exit (i.e., Entire is disabled).\n// On error reading settings, defaults to enabled (returns false).\nfunc checkDisabledGuard(w io.Writer) bool {\n\tenabled, err := IsEnabled()\n\tif err != nil {\n\t\t// Default to enabled on error\n\t\treturn false\n\t}\n\tif !enabled {\n\t\tfmt.Fprintln(w, DisabledMessage)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// setupClaudeCodeHook sets up Claude Code hooks.\n// This is a convenience wrapper that uses the agent package.\n// Returns the number of hooks installed (0 if already installed).\nfunc setupClaudeCodeHook(localDev, forceHooks bool) (int, error) {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get claude-code agent: %w\", err)\n\t}\n\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn 0, errors.New(\"claude-code agent does not support hooks\")\n\t}\n\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to install claude-code hooks: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// setupAgentHooksNonInteractive sets up hooks for a specific agent non-interactively.\n// If strategyName is provided, it sets the strategy; otherwise uses default.\nfunc setupAgentHooksNonInteractive(agentName agent.AgentName, strategyName string, localDev, forceHooks, skipPushSessions, telemetry bool) error {\n\tag, err := agent.Get(agentName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown agent: %s\", agentName)\n\t}\n\n\t// Check if agent supports hooks\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn fmt.Errorf(\"agent %s does not support hooks\", agentName)\n\t}\n\n\t// Install hooks\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install hooks for %s: %w\", agentName, err)\n\t}\n\n\tif count == 0 {\n\t\tmsg := fmt.Sprintf(\"Hooks for %s already installed\", ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t} else {\n\t\tmsg := fmt.Sprintf(\"Installed %d hooks for %s\", count, ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\n\t// Update settings to store the strategy\n\tsettings, _ := LoadEntireSettings() //nolint:errcheck // settings defaults are fine\n\tsettings.Enabled = true\n\tif localDev {\n\t\tsettings.LocalDev = localDev\n\t}\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Set strategy if provided\n\tif strategyName != \"\" {\n\t\t// Map display name to internal name if needed\n\t\tinternalStrategy := strategyName\n\t\tif mapped, ok := strategyDisplayToInternal[strategyName]; ok {\n\t\t\tinternalStrategy = mapped\n\t\t}\n\t\t// Validate the strategy exists\n\t\tif _, err := strategy.Get(internalStrategy); err != nil {\n\t\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", strategyName)\n\t\t}\n\t\tsettings.Strategy = internalStrategy\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tif _, err := strategy.InstallGitHook(true); err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\n\t// Let the strategy handle its own setup requirements (creates entire/sessions branch, etc.)\n\tstrat, err := strategy.Get(settings.Strategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// validateSetupFlags checks that --local and --project flags are not both specified.\nfunc validateSetupFlags(useLocal, useProject bool) error {\n\tif useLocal && useProject {\n\t\treturn errors.New(\"cannot specify both --project and --local\")\n\t}\n\treturn nil\n}\n\n// determineSettingsTarget decides whether to write to settings.local.json based on:\n// - Whether settings.json already exists\n// - The --local and --project flags\n// Returns (useLocal, showNotification).\nfunc determineSettingsTarget(entireDir string, useLocal, useProject bool) (bool, bool) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, false\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, false\n\t}\n\n\t// No flags specified - check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); err == nil {\n\t\t// Settings file exists - auto-redirect to local with notification\n\t\treturn true, true\n\t}\n\n\t// Settings file doesn't exist - create it\n\treturn false, false\n}\n\n// Settings target options for interactive prompt\nconst (\n\tsettingsTargetProject = \"project\"\n\tsettingsTargetLocal   = \"local\"\n)\n\n// promptSettingsTarget interactively asks the user where to save settings\n// when settings.json already exists and no flags were provided.\n// Returns (useLocal, error).\nfunc promptSettingsTarget(entireDir string, useLocal, useProject bool) (bool, error) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, nil\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, nil\n\t}\n\n\t// Check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); os.IsNotExist(err) {\n\t\t// Settings file doesn't exist - create it (no prompt needed)\n\t\treturn false, nil\n\t}\n\n\t// Settings file exists - prompt user\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(\"Project settings already exist. Where should settings be saved?\").\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Update project settings (settings.json)\", settingsTargetProject),\n\t\t\t\t\thuh.NewOption(\"Use local settings (settings.local.json, gitignored)\", settingsTargetLocal),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false, fmt.Errorf(\"selection cancelled: %w\", err)\n\t}\n\n\treturn selected == settingsTargetLocal, nil\n}\n\n// setupEntireDirectory creates the .entire directory and gitignore.\n// Returns true if the directory was created, false if it already existed.\nfunc setupEntireDirectory() (bool, error) {\n\t// Get absolute path for the .entire directory\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\n\t// Check if directory already exists\n\tcreated := false\n\tif _, err := os.Stat(entireDirAbs); os.IsNotExist(err) {\n\t\tcreated = true\n\t}\n\n\t// Create .entire directory\n\t//nolint:gosec // G301: Project directory needs standard permissions for git\n\tif err := os.MkdirAll(entireDirAbs, 0o755); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to create .entire directory: %w\", err)\n\t}\n\n\t// Create/update .gitignore with all required entries\n\tif err := strategy.EnsureEntireGitignore(); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to setup .gitignore: %w\", err)\n\t}\n\n\treturn created, nil\n}\n\n// setupGitHook installs the prepare-commit-msg hook for context trailers.\nfunc setupGitHook() error {\n\t// Use shared implementation from strategy package\n\t// The localDev setting is read from settings.json\n\t_, err := strategy.InstallGitHook(false) // not silent - show output during setup\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hook: %w\", err)\n\t}\n\treturn nil\n}\n\n// newSetupGitHookCmd creates the standalone git-hook setup command\nfunc newSetupGitHookCmd() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:    \"git-hook\",\n\t\tShort:  \"Install git hook for session context trailers\",\n\t\tHidden: true, // Hidden as it's mainly for testing\n\t\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\treturn setupGitHook()\n\t\t},\n\t}\n\n\treturn cmd\n}\n\nfunc newCurlBashPostInstallCmd() *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:    \"curl-bash-post-install\",\n\t\tShort:  \"Post-install tasks for curl|bash installer\",\n\t\tHidden: true,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tw := cmd.OutOrStdout()\n\t\t\tif err := promptShellCompletion(w); err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Note: Shell completion setup skipped: %v\\n\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n}\n\n// Shell completion stanza management.\n// The stanza is a versioned, delimited block written to ~/.zshrc or ~/.bashrc:\n//\n//\t# Entire CLI completions (v1) {{{\n//\tautoload -Uz compinit && compinit && source <(entire completion zsh)\n//\t# }}}\nconst (\n\tshellCompletionStanzaVersion = 1\n\tshellCompletionOpenFormat    = \"# Entire CLI completions (v%d) {{{\"\n\tshellCompletionClose         = \"# }}}\"\n\tshellCompletionLegacyComment = \"# Entire CLI shell completion\" // old format for migration\n)\n\ntype stanzaStatus int\n\nconst (\n\tstanzaNotFound stanzaStatus = iota\n\tstanzaCurrent\n\tstanzaOutdated\n\tstanzaLegacy\n)\n\nvar (\n\terrStanzaCorrupted = errors.New(\"shell completion block is corrupted (missing closing marker)\")\n\terrMultipleStanzas = errors.New(\"found multiple shell completion blocks\")\n)\n\n// findStanzaVersion scans content for the opening stanza marker and returns\n// the version number. Returns 0 if no stanza is found.\nfunc findStanzaVersion(content string) int {\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\treturn version\n\t\t}\n\t}\n\treturn 0\n}\n\n// checkStanzaStatus determines the status of the shell completion stanza in content.\nfunc checkStanzaStatus(content string, currentVersion int) stanzaStatus {\n\tversion := findStanzaVersion(content)\n\tif version > 0 {\n\t\tif version >= currentVersion {\n\t\t\treturn stanzaCurrent\n\t\t}\n\t\treturn stanzaOutdated\n\t}\n\tif strings.Contains(content, shellCompletionLegacyComment) {\n\t\treturn stanzaLegacy\n\t}\n\treturn stanzaNotFound\n}\n\n// buildStanza constructs the full stanza block for the given version and completion line.\nfunc buildStanza(version int, completionLine string) string {\n\treturn fmt.Sprintf(shellCompletionOpenFormat, version) + \"\\n\" + completionLine + \"\\n\" + shellCompletionClose\n}\n\n// countStanzaOpeners counts how many opening stanza markers exist in content.\nfunc countStanzaOpeners(content string) int {\n\tcount := 0\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n// replaceStanza finds the open+close markers in content and replaces the block\n// with a new stanza. Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc replaceStanza(content string, version int, completionLine string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tnewStanza := buildStanza(version, completionLine)\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\tresult = append(result, newStanza)\n\tresult = append(result, lines[closeIdx+1:]...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeStanza finds and removes the stanza block from content.\n// Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc removeStanza(content string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\t// Skip blank line immediately after stanza if present\n\ttail := lines[closeIdx+1:]\n\tif len(tail) > 0 && strings.TrimSpace(tail[0]) == \"\" {\n\t\ttail = tail[1:]\n\t}\n\tresult = append(result, tail...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeLegacyCompletion removes the old-format comment and its following\n// completion line from content. Returns the modified content and whether\n// anything was removed.\nfunc removeLegacyCompletion(content, completionLine string) (string, bool) {\n\tlines := strings.Split(content, \"\\n\")\n\tvar result []string\n\tremoved := false\n\tfor i := 0; i < len(lines); i++ {\n\t\tif strings.TrimSpace(lines[i]) == shellCompletionLegacyComment {\n\t\t\t// Remove the comment line and the next line if it matches the completion line\n\t\t\tif i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == completionLine {\n\t\t\t\ti++ // skip next line too\n\t\t\t}\n\t\t\tremoved = true\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, lines[i])\n\t}\n\tif !removed {\n\t\treturn content, false\n\t}\n\treturn strings.Join(result, \"\\n\"), true\n}\n\n// errUnsupportedShell is returned when the user's shell is not supported for completion.\nvar errUnsupportedShell = errors.New(\"unsupported shell\")\n\n// shellCompletionTarget returns the rc file path and completion lines for the\n// user's current shell.\nfunc shellCompletionTarget() (shellName, rcFile, completionLine string, err error) {\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", fmt.Errorf(\"cannot determine home directory: %w\", err)\n\t}\n\n\tshell := os.Getenv(\"SHELL\")\n\tswitch {\n\tcase strings.Contains(shell, \"zsh\"):\n\t\treturn \"Zsh\",\n\t\t\tfilepath.Join(home, \".zshrc\"),\n\t\t\t\"source <(entire completion zsh)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"bash\"):\n\t\treturn \"Bash\",\n\t\t\tfilepath.Join(home, \".bashrc\"),\n\t\t\t\"source <(entire completion bash)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"fish\"):\n\t\treturn \"Fish\",\n\t\t\tfilepath.Join(home, \".config\", \"fish\", \"config.fish\"),\n\t\t\t\"entire completion fish | source\",\n\t\t\tnil\n\tdefault:\n\t\treturn \"\", \"\", \"\", errUnsupportedShell\n\t}\n}\n\n// promptShellCompletion offers to add shell completion to the user's rc file.\n// Handles versioned stanza detection, updates, and legacy migration.\nfunc promptShellCompletion(w io.Writer) error {\n\tshellName, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\tif errors.Is(err, errUnsupportedShell) {\n\t\t\tfmt.Fprintf(w, \"Note: Shell completion not available for your shell. Supported: zsh, bash, fish.\\n\")\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"shell completion: %w\", err)\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\tstatus := checkStanzaStatus(string(content), shellCompletionStanzaVersion)\n\tswitch status {\n\tcase stanzaCurrent:\n\t\treturn nil\n\n\tcase stanzaOutdated:\n\t\tif !promptYesNo(\"Shell completion is outdated. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t// Re-read in case file changed\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, replaceErr := replaceStanza(string(content), shellCompletionStanzaVersion, completionLine)\n\t\tif replaceErr != nil {\n\t\t\tfmt.Fprintf(w, \"Warning: %v in %s. Please fix manually.\\n\", replaceErr, rcFile)\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaLegacy:\n\t\tif !promptYesNo(\"Shell completion uses old format. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, _ := removeLegacyCompletion(string(content), completionLine)\n\t\tupdated = updated + \"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\"\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaNotFound:\n\t\tif !promptYesNo(\"Enable shell completion?\") {\n\t\t\treturn nil\n\t\t}\n\t\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t}\n\n\treturn nil\n}\n\n// promptYesNo shows a yes/no selection prompt and returns whether the user chose yes.\nfunc promptYesNo(title string) bool {\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n<<<<<<< HEAD\n\t\t\t\tTitle(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)).\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tTitle(\"Enable shell completion?\").\n=======\n\t\t\t\tTitle(title).\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Yes\", \"yes\"),\n\t\t\t\t\thuh.NewOption(\"No\", \"no\"),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n<<<<<<< HEAD\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Restart your shell to activate\")\n\n\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\n\treturn nil\n=======\n\treturn selected == \"yes\"\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n}\n\n<<<<<<< HEAD\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), \"entire completion\")\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string, completionLine string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), completionLine)\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n=======\n// appendShellCompletion adds the completion stanza to the rc file.\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\nfunc appendShellCompletion(rcFile, completionLine string) error {\n\tif err := os.MkdirAll(filepath.Dir(rcFile), 0o755); err != nil {\n\t\treturn fmt.Errorf(\"creating directory: %w\", err)\n\t}\n\t//nolint:gosec // G302: Shell rc files need 0644 for user readability\n\tf, err := os.OpenFile(rcFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(\"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing completion: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeShellCompletion removes the shell completion stanza (or legacy format)\n// from the user's rc file. Used during uninstall.\nfunc removeShellCompletion() error {\n\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\ttext := string(content)\n\tupdated, removeErr := removeStanza(text)\n\tif removeErr != nil {\n\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n\t}\n\n\tif updated != text {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Fall back to legacy format removal\n\tupdated, removed := removeLegacyCompletion(text, completionLine)\n\tif removed {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// promptTelemetryConsent asks the user if they want to enable telemetry.\n// It modifies settings.Telemetry based on the user's choice or flags.\n// The caller is responsible for saving settings.\nfunc promptTelemetryConsent(settings *EntireSettings, telemetryFlag bool) error {\n\t// Handle --telemetry=false flag first (always overrides existing setting)\n\tif !telemetryFlag {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\t// Skip if already asked\n\tif settings.Telemetry != nil {\n\t\treturn nil\n\t}\n\n\t// Skip if env var disables telemetry (record as disabled)\n\tif os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\tconsent := true // Default to Yes\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewConfirm().\n\t\t\t\tTitle(\"Help improve Entire CLI?\").\n\t\t\t\tDescription(\"Share anonymous usage data. No code or personal info collected.\").\n\t\t\t\tAffirmative(\"Yes\").\n\t\t\t\tNegative(\"No\").\n\t\t\t\tValue(&consent),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn fmt.Errorf(\"telemetry prompt: %w\", err)\n\t}\n\n\tsettings.Telemetry = &consent\n\treturn nil\n}\n\n// runUninstall completely removes Entire from the repository.\nfunc runUninstall(w, errW io.Writer, force bool) error {\n\t// Check if we're in a git repository\n\tif _, err := paths.RepoRoot(); err != nil {\n\t\tfmt.Fprintln(errW, \"Not a git repository. Nothing to uninstall.\")\n\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t}\n\n\t// Gather counts for display\n\tsessionStateCount := countSessionStates()\n\tshadowBranchCount := countShadowBranches()\n\tgitHooksInstalled := strategy.IsGitHookInstalled()\n\tclaudeHooksInstalled := checkClaudeCodeHooksInstalled()\n\tgeminiHooksInstalled := checkGeminiCLIHooksInstalled()\n\tentireDirExists := checkEntireDirExists()\n\n\t// Check if there's anything to uninstall\n\tif !entireDirExists && !gitHooksInstalled && sessionStateCount == 0 &&\n\t\tshadowBranchCount == 0 && !claudeHooksInstalled && !geminiHooksInstalled {\n\t\tfmt.Fprintln(w, \"Entire is not installed in this repository.\")\n\t\treturn nil\n\t}\n\n\t// Show confirmation prompt unless --force\n\tif !force {\n\t\tfmt.Fprintln(w, \"\\nThis will completely remove Entire from this repository:\")\n\t\tif entireDirExists {\n\t\t\tfmt.Fprintln(w, \"  - .entire/ directory\")\n\t\t}\n\t\tif gitHooksInstalled {\n\t\t\tfmt.Fprintln(w, \"  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\")\n\t\t}\n\t\tif sessionStateCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Session state files (%d)\\n\", sessionStateCount)\n\t\t}\n\t\tif shadowBranchCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Shadow branches (%d)\\n\", shadowBranchCount)\n\t\t}\n\t\tswitch {\n\t\tcase claudeHooksInstalled && geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code, Gemini CLI)\")\n\t\tcase claudeHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code)\")\n\t\tcase geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Gemini CLI)\")\n\t\t}\n\t\tfmt.Fprintln(w)\n\n\t\tvar confirmed bool\n\t\tform := NewAccessibleForm(\n\t\t\thuh.NewGroup(\n\t\t\t\thuh.NewConfirm().\n\t\t\t\t\tTitle(\"Are you sure you want to uninstall Entire?\").\n\t\t\t\t\tAffirmative(\"Yes, uninstall\").\n\t\t\t\t\tNegative(\"Cancel\").\n\t\t\t\t\tValue(&confirmed),\n\t\t\t),\n\t\t)\n\n\t\tif err := form.Run(); err != nil {\n\t\t\treturn fmt.Errorf(\"confirmation cancelled: %w\", err)\n\t\t}\n\n\t\tif !confirmed {\n\t\t\tfmt.Fprintln(w, \"Uninstall cancelled.\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"\\nUninstalling Entire CLI...\")\n\n\t// 0. Remove shell completion from rc file\n\tif err := removeShellCompletion(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shell completion: %v\\n\", err)\n\t} else {\n\t\tfmt.Fprintln(w, \"  Removed shell completion\")\n\t}\n\n\t// 1. Remove agent hooks (lowest risk)\n\tif err := removeAgentHooks(w); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove agent hooks: %v\\n\", err)\n\t}\n\n\t// 2. Remove git hooks\n\tremoved, err := strategy.RemoveGitHook()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove git hooks: %v\\n\", err)\n\t} else if removed > 0 {\n\t\tfmt.Fprintf(w, \"  Removed git hooks (%d)\\n\", removed)\n\t}\n\n\t// 3. Remove session state files\n\tstatesRemoved, err := removeAllSessionStates()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove session states: %v\\n\", err)\n\t} else if statesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed session states (%d)\\n\", statesRemoved)\n\t}\n\n\t// 4. Remove .entire/ directory\n\tif err := removeEntireDirectory(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove .entire directory: %v\\n\", err)\n\t} else if entireDirExists {\n\t\tfmt.Fprintln(w, \"  Removed .entire directory\")\n\t}\n\n\t// 5. Remove shadow branches\n\tbranchesRemoved, err := removeAllShadowBranches()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shadow branches: %v\\n\", err)\n\t} else if branchesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed %d shadow branches\\n\", branchesRemoved)\n\t}\n\n\tfmt.Fprintln(w, \"\\nEntire CLI uninstalled successfully.\")\n\treturn nil\n}\n\n// countSessionStates returns the number of active session state files.\nfunc countSessionStates() int {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0\n\t}\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(states)\n}\n\n// countShadowBranches returns the number of shadow branches.\nfunc countShadowBranches() int {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(branches)\n}\n\n// checkClaudeCodeHooksInstalled checks if Claude Code hooks are installed.\nfunc checkClaudeCodeHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkGeminiCLIHooksInstalled checks if Gemini CLI hooks are installed.\nfunc checkGeminiCLIHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameGemini)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkEntireDirExists checks if the .entire directory exists.\nfunc checkEntireDirExists() bool {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\t_, err = os.Stat(entireDirAbs)\n\treturn err == nil\n}\n\n// removeAgentHooks removes hooks from all agents that support hooks.\nfunc removeAgentHooks(w io.Writer) error {\n\tvar errs []error\n\n\t// Remove Claude Code hooks\n\tclaudeAgent, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err == nil {\n\t\tif hookAgent, ok := claudeAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Claude Code hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove Gemini CLI hooks\n\tgeminiAgent, err := agent.Get(agent.AgentNameGemini)\n\tif err == nil {\n\t\tif hookAgent, ok := geminiAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Gemini CLI hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errors.Join(errs...)\n}\n\n// removeAllSessionStates removes all session state files and the directory.\nfunc removeAllSessionStates() (int, error) {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to create state store: %w\", err)\n\t}\n\n\t// Count states before removing\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list session states: %w\", err)\n\t}\n\tcount := len(states)\n\n\t// Remove the entire directory\n\tif err := store.RemoveAll(); err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to remove session states: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// removeEntireDirectory removes the .entire directory.\nfunc removeEntireDirectory() error {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\tif err := os.RemoveAll(entireDirAbs); err != nil {\n\t\treturn fmt.Errorf(\"failed to remove .entire directory: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeAllShadowBranches removes all shadow branches.\nfunc removeAllShadowBranches() (int, error) {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list shadow branches: %w\", err)\n\t}\n\tif len(branches) == 0 {\n\t\treturn 0, nil\n\t}\n\tdeleted, _, err := strategy.DeleteShadowBranches(branches)\n\treturn len(deleted), err\n}\n","structuredPatch":[{"oldStart":903,"oldLines":6,"newStart":903,"newLines":7,"lines":["   status := checkStanzaStatus(string(content), shellCompletionStanzaVersion)","   switch status {","   case stanzaCurrent:","+    fmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)","     return nil"," ","   case stanzaOutdated:"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"ed211c37-79ff-4268-b3e4-dbddacd2226b"}
{"parentUuid":"1015383e-ed1d-4569-a0dd-0cb0dd44475c","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01KhRa39RrFH93n6Kxh39bvn","type":"message","role":"assistant","content":[{"type":"text","text":"Now resolve the second conflict (the `promptYesNo` / prompt area). I'll also add the shell name to the \"Enable\" prompt:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":369,"cache_read_input_tokens":49192,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":369},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxYTJd6fc8oHd8c4EN3","type":"assistant","uuid":"0a10ff50-be98-426b-8a31-5e62dcd72750","timestamp":"2026-02-09T05:40:17.209Z"}
{"parentUuid":"0a10ff50-be98-426b-8a31-5e62dcd72750","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01KhRa39RrFH93n6Kxh39bvn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013vodLBPCGixvyCzn6Td7oe","name":"Edit","input":{"replace_all":false,"file_path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","old_string":"\tcase stanzaNotFound:\n\t\tif !promptYesNo(\"Enable shell completion?\") {","new_string":"\tcase stanzaNotFound:\n\t\tif !promptYesNo(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)) {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":369,"cache_read_input_tokens":49192,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":369},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxYTJd6fc8oHd8c4EN3","type":"assistant","uuid":"5d3d3acd-ab20-45c7-ad90-e79b395539f3","timestamp":"2026-02-09T05:40:18.731Z"}
{"parentUuid":"5d3d3acd-ab20-45c7-ad90-e79b395539f3","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_013vodLBPCGixvyCzn6Td7oe","toolUseID":"toolu_013vodLBPCGixvyCzn6Td7oe","timestamp":"2026-02-09T05:40:28.323Z","uuid":"e9a8e31c-7da8-45b1-81fa-5857ac960ce8"}
{"parentUuid":"5d3d3acd-ab20-45c7-ad90-e79b395539f3","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013vodLBPCGixvyCzn6Td7oe","type":"tool_result","content":"The file /Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go has been updated successfully."}]},"uuid":"710a06fb-63bb-49d2-9a73-e7f9f242a3ce","timestamp":"2026-02-09T05:40:28.322Z","toolUseResult":{"filePath":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","oldString":"\tcase stanzaNotFound:\n\t\tif !promptYesNo(\"Enable shell completion?\") {","newString":"\tcase stanzaNotFound:\n\t\tif !promptYesNo(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)) {","originalFile":"package cli\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/entireio/cli/cmd/entire/cli/agent\"\n\t\"github.com/entireio/cli/cmd/entire/cli/paths\"\n\t\"github.com/entireio/cli/cmd/entire/cli/session\"\n\t\"github.com/entireio/cli/cmd/entire/cli/strategy\"\n\n\t\"github.com/charmbracelet/huh\"\n\t\"github.com/spf13/cobra\"\n)\n\n// Strategy display names for user-friendly selection\nconst (\n\tstrategyDisplayManualCommit = \"manual-commit\"\n\tstrategyDisplayAutoCommit   = \"auto-commit\"\n)\n\n// strategyDisplayToInternal maps user-friendly names to internal strategy names\nvar strategyDisplayToInternal = map[string]string{\n\tstrategyDisplayManualCommit: strategy.StrategyNameManualCommit,\n\tstrategyDisplayAutoCommit:   strategy.StrategyNameAutoCommit,\n}\n\n// strategyInternalToDisplay maps internal strategy names to user-friendly names\nvar strategyInternalToDisplay = map[string]string{\n\tstrategy.StrategyNameManualCommit: strategyDisplayManualCommit,\n\tstrategy.StrategyNameAutoCommit:   strategyDisplayAutoCommit,\n}\n\nfunc newEnableCmd() *cobra.Command {\n\tvar localDev bool\n\tvar ignoreUntracked bool\n\tvar useLocalSettings bool\n\tvar useProjectSettings bool\n\tvar agentName string\n\tvar strategyFlag string\n\tvar forceHooks bool\n\tvar skipPushSessions bool\n\tvar telemetry bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"enable\",\n\t\tShort: \"Enable Entire\",\n\t\tLong: `Enable Entire with session tracking for your AI agent workflows.\n\nUses the manual-commit strategy by default. To use a different strategy:\n\n  entire enable --strategy auto-commit\n\nStrategies: manual-commit (default), auto-commit`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\t// Check if we're in a git repository first - this is a prerequisite error,\n\t\t\t// not a usage error, so we silence Cobra's output and use SilentError\n\t\t\t// to prevent duplicate error output in main.go\n\t\t\tif _, err := paths.RepoRoot(); err != nil {\n\t\t\t\tcmd.SilenceUsage = true\n\t\t\t\tcmd.SilenceErrors = true\n\t\t\t\tfmt.Fprintln(cmd.ErrOrStderr(), \"Not a git repository. Please run 'entire enable' from within a git repository.\")\n\t\t\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t\t\t}\n\n\t\t\tif err := validateSetupFlags(useLocalSettings, useProjectSettings); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Non-interactive mode if --agent flag is provided\n\t\t\tif agentName != \"\" {\n\t\t\t\treturn setupAgentHooksNonInteractive(agent.AgentName(agentName), strategyFlag, localDev, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\t// If strategy is specified via flag, skip interactive selection\n\t\t\tif strategyFlag != \"\" {\n\t\t\t\treturn runEnableWithStrategy(cmd.OutOrStdout(), strategyFlag, localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\treturn runEnableInteractive(cmd.OutOrStdout(), localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&localDev, \"local-dev\", false, \"Use go run instead of entire binary for hooks\")\n\tcmd.Flags().MarkHidden(\"local-dev\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&ignoreUntracked, \"ignore-untracked\", false, \"Commit all new files without tracking pre-existing untracked files\")\n\tcmd.Flags().MarkHidden(\"ignore-untracked\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&useLocalSettings, \"local\", false, \"Write settings to settings.local.json instead of settings.json\")\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Write settings to settings.json even if it already exists\")\n\tcmd.Flags().StringVar(&agentName, \"agent\", \"\", \"Agent to setup hooks for (e.g., claude-code). Enables non-interactive mode.\")\n\tcmd.Flags().StringVar(&strategyFlag, \"strategy\", \"\", \"Strategy to use (manual-commit or auto-commit)\")\n\tcmd.Flags().BoolVarP(&forceHooks, \"force\", \"f\", false, \"Force reinstall hooks (removes existing Entire hooks first)\")\n\tcmd.Flags().BoolVar(&skipPushSessions, \"skip-push-sessions\", false, \"Disable automatic pushing of session logs on git push\")\n\tcmd.Flags().BoolVar(&telemetry, \"telemetry\", true, \"Enable anonymous usage analytics\")\n\t//nolint:errcheck,gosec // completion is optional, flag is defined above\n\tcmd.RegisterFlagCompletionFunc(\"strategy\", func(_ *cobra.Command, _ []string, _ string) ([]string, cobra.ShellCompDirective) {\n\t\treturn []string{strategyDisplayManualCommit, strategyDisplayAutoCommit}, cobra.ShellCompDirectiveNoFileComp\n\t})\n\n\t// Add subcommands for automation/testing\n\tcmd.AddCommand(newSetupGitHookCmd())\n\n\treturn cmd\n}\n\nfunc newDisableCmd() *cobra.Command {\n\tvar useProjectSettings bool\n\tvar uninstall bool\n\tvar force bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"disable\",\n\t\tShort: \"Disable Entire\",\n\t\tLong: `Disable Entire temporarily. Hooks will exit silently and commands will show a disabled message.\n\nUse --uninstall to completely remove Entire from this repository, including:\n  - .entire/ directory (settings, logs, metadata)\n  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\n  - Session state files (.git/entire-sessions/)\n  - Shadow branches (entire/<hash>)\n  - Agent hooks (Claude Code, Gemini CLI)`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tif uninstall {\n\t\t\t\treturn runUninstall(cmd.OutOrStdout(), cmd.ErrOrStderr(), force)\n\t\t\t}\n\t\t\treturn runDisable(cmd.OutOrStdout(), useProjectSettings)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Update settings.json instead of settings.local.json\")\n\tcmd.Flags().BoolVar(&uninstall, \"uninstall\", false, \"Completely remove Entire from this repository\")\n\tcmd.Flags().BoolVar(&force, \"force\", false, \"Skip confirmation prompt (use with --uninstall)\")\n\n\treturn cmd\n}\n\n// runEnableWithStrategy enables Entire with a specified strategy (non-interactive).\n// The selectedStrategy can be either a display name (manual-commit, auto-commit)\n// or an internal name (manual-commit, auto-commit).\nfunc runEnableWithStrategy(w io.Writer, selectedStrategy string, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Map the strategy to internal name if it's a display name\n\tinternalStrategy := selectedStrategy\n\tif mapped, ok := strategyDisplayToInternal[selectedStrategy]; ok {\n\t\tinternalStrategy = mapped\n\t}\n\n\t// Validate the strategy exists\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", selectedStrategy)\n\t}\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\t// Determine which settings file to write to\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, showNotification := determineSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\n\tif showNotification {\n\t\tfmt.Fprintln(w, \"Info: Project settings exist. Saving to settings.local.json instead.\")\n\t\tfmt.Fprintln(w, \"  Use --project to update the project settings file.\")\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tdisplayName := selectedStrategy\n\tif dn, ok := strategyInternalToDisplay[internalStrategy]; ok {\n\t\tdisplayName = dn\n\t}\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", displayName)\n\n\treturn nil\n}\n\n// runEnableInteractive runs the interactive enable flow.\nfunc runEnableInteractive(w io.Writer, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Use the default strategy (manual-commit)\n\tinternalStrategy := strategy.DefaultStrategyName\n\tfmt.Fprintf(w, \"Using %s strategy (use --strategy to change)\\n\\n\", strategyInternalToDisplay[internalStrategy])\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Ask about telemetry consent (only if not already asked)\n\tif err := promptTelemetryConsent(settings, telemetry); err != nil {\n\t\treturn fmt.Errorf(\"telemetry consent: %w\", err)\n\t}\n\n\t// Determine which settings file to write to (interactive prompt if settings.json exists)\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, err := promptSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", strategyInternalToDisplay[internalStrategy])\n\n\treturn nil\n}\n\n// runEnable is a simple enable that just sets the enabled flag (for programmatic use).\nfunc runEnable(w io.Writer) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = true\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now enabled.\")\n\treturn nil\n}\n\nfunc runDisable(w io.Writer, useProjectSettings bool) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = false\n\n\t// If --project flag is specified, always write to project settings\n\tif useProjectSettings {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t} else {\n\t\t// Always write to local settings file (create if doesn't exist)\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now disabled.\")\n\treturn nil\n}\n\n// DisabledMessage is the message shown when Entire is disabled\nconst DisabledMessage = \"Entire is disabled. Run `entire enable` to re-enable.\"\n\n// checkDisabledGuard checks if Entire is disabled and prints a message if so.\n// Returns true if the caller should exit (i.e., Entire is disabled).\n// On error reading settings, defaults to enabled (returns false).\nfunc checkDisabledGuard(w io.Writer) bool {\n\tenabled, err := IsEnabled()\n\tif err != nil {\n\t\t// Default to enabled on error\n\t\treturn false\n\t}\n\tif !enabled {\n\t\tfmt.Fprintln(w, DisabledMessage)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// setupClaudeCodeHook sets up Claude Code hooks.\n// This is a convenience wrapper that uses the agent package.\n// Returns the number of hooks installed (0 if already installed).\nfunc setupClaudeCodeHook(localDev, forceHooks bool) (int, error) {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get claude-code agent: %w\", err)\n\t}\n\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn 0, errors.New(\"claude-code agent does not support hooks\")\n\t}\n\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to install claude-code hooks: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// setupAgentHooksNonInteractive sets up hooks for a specific agent non-interactively.\n// If strategyName is provided, it sets the strategy; otherwise uses default.\nfunc setupAgentHooksNonInteractive(agentName agent.AgentName, strategyName string, localDev, forceHooks, skipPushSessions, telemetry bool) error {\n\tag, err := agent.Get(agentName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown agent: %s\", agentName)\n\t}\n\n\t// Check if agent supports hooks\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn fmt.Errorf(\"agent %s does not support hooks\", agentName)\n\t}\n\n\t// Install hooks\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install hooks for %s: %w\", agentName, err)\n\t}\n\n\tif count == 0 {\n\t\tmsg := fmt.Sprintf(\"Hooks for %s already installed\", ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t} else {\n\t\tmsg := fmt.Sprintf(\"Installed %d hooks for %s\", count, ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\n\t// Update settings to store the strategy\n\tsettings, _ := LoadEntireSettings() //nolint:errcheck // settings defaults are fine\n\tsettings.Enabled = true\n\tif localDev {\n\t\tsettings.LocalDev = localDev\n\t}\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Set strategy if provided\n\tif strategyName != \"\" {\n\t\t// Map display name to internal name if needed\n\t\tinternalStrategy := strategyName\n\t\tif mapped, ok := strategyDisplayToInternal[strategyName]; ok {\n\t\t\tinternalStrategy = mapped\n\t\t}\n\t\t// Validate the strategy exists\n\t\tif _, err := strategy.Get(internalStrategy); err != nil {\n\t\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", strategyName)\n\t\t}\n\t\tsettings.Strategy = internalStrategy\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tif _, err := strategy.InstallGitHook(true); err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\n\t// Let the strategy handle its own setup requirements (creates entire/sessions branch, etc.)\n\tstrat, err := strategy.Get(settings.Strategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// validateSetupFlags checks that --local and --project flags are not both specified.\nfunc validateSetupFlags(useLocal, useProject bool) error {\n\tif useLocal && useProject {\n\t\treturn errors.New(\"cannot specify both --project and --local\")\n\t}\n\treturn nil\n}\n\n// determineSettingsTarget decides whether to write to settings.local.json based on:\n// - Whether settings.json already exists\n// - The --local and --project flags\n// Returns (useLocal, showNotification).\nfunc determineSettingsTarget(entireDir string, useLocal, useProject bool) (bool, bool) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, false\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, false\n\t}\n\n\t// No flags specified - check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); err == nil {\n\t\t// Settings file exists - auto-redirect to local with notification\n\t\treturn true, true\n\t}\n\n\t// Settings file doesn't exist - create it\n\treturn false, false\n}\n\n// Settings target options for interactive prompt\nconst (\n\tsettingsTargetProject = \"project\"\n\tsettingsTargetLocal   = \"local\"\n)\n\n// promptSettingsTarget interactively asks the user where to save settings\n// when settings.json already exists and no flags were provided.\n// Returns (useLocal, error).\nfunc promptSettingsTarget(entireDir string, useLocal, useProject bool) (bool, error) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, nil\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, nil\n\t}\n\n\t// Check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); os.IsNotExist(err) {\n\t\t// Settings file doesn't exist - create it (no prompt needed)\n\t\treturn false, nil\n\t}\n\n\t// Settings file exists - prompt user\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(\"Project settings already exist. Where should settings be saved?\").\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Update project settings (settings.json)\", settingsTargetProject),\n\t\t\t\t\thuh.NewOption(\"Use local settings (settings.local.json, gitignored)\", settingsTargetLocal),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false, fmt.Errorf(\"selection cancelled: %w\", err)\n\t}\n\n\treturn selected == settingsTargetLocal, nil\n}\n\n// setupEntireDirectory creates the .entire directory and gitignore.\n// Returns true if the directory was created, false if it already existed.\nfunc setupEntireDirectory() (bool, error) {\n\t// Get absolute path for the .entire directory\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\n\t// Check if directory already exists\n\tcreated := false\n\tif _, err := os.Stat(entireDirAbs); os.IsNotExist(err) {\n\t\tcreated = true\n\t}\n\n\t// Create .entire directory\n\t//nolint:gosec // G301: Project directory needs standard permissions for git\n\tif err := os.MkdirAll(entireDirAbs, 0o755); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to create .entire directory: %w\", err)\n\t}\n\n\t// Create/update .gitignore with all required entries\n\tif err := strategy.EnsureEntireGitignore(); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to setup .gitignore: %w\", err)\n\t}\n\n\treturn created, nil\n}\n\n// setupGitHook installs the prepare-commit-msg hook for context trailers.\nfunc setupGitHook() error {\n\t// Use shared implementation from strategy package\n\t// The localDev setting is read from settings.json\n\t_, err := strategy.InstallGitHook(false) // not silent - show output during setup\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hook: %w\", err)\n\t}\n\treturn nil\n}\n\n// newSetupGitHookCmd creates the standalone git-hook setup command\nfunc newSetupGitHookCmd() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:    \"git-hook\",\n\t\tShort:  \"Install git hook for session context trailers\",\n\t\tHidden: true, // Hidden as it's mainly for testing\n\t\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\treturn setupGitHook()\n\t\t},\n\t}\n\n\treturn cmd\n}\n\nfunc newCurlBashPostInstallCmd() *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:    \"curl-bash-post-install\",\n\t\tShort:  \"Post-install tasks for curl|bash installer\",\n\t\tHidden: true,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tw := cmd.OutOrStdout()\n\t\t\tif err := promptShellCompletion(w); err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Note: Shell completion setup skipped: %v\\n\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n}\n\n// Shell completion stanza management.\n// The stanza is a versioned, delimited block written to ~/.zshrc or ~/.bashrc:\n//\n//\t# Entire CLI completions (v1) {{{\n//\tautoload -Uz compinit && compinit && source <(entire completion zsh)\n//\t# }}}\nconst (\n\tshellCompletionStanzaVersion = 1\n\tshellCompletionOpenFormat    = \"# Entire CLI completions (v%d) {{{\"\n\tshellCompletionClose         = \"# }}}\"\n\tshellCompletionLegacyComment = \"# Entire CLI shell completion\" // old format for migration\n)\n\ntype stanzaStatus int\n\nconst (\n\tstanzaNotFound stanzaStatus = iota\n\tstanzaCurrent\n\tstanzaOutdated\n\tstanzaLegacy\n)\n\nvar (\n\terrStanzaCorrupted = errors.New(\"shell completion block is corrupted (missing closing marker)\")\n\terrMultipleStanzas = errors.New(\"found multiple shell completion blocks\")\n)\n\n// findStanzaVersion scans content for the opening stanza marker and returns\n// the version number. Returns 0 if no stanza is found.\nfunc findStanzaVersion(content string) int {\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\treturn version\n\t\t}\n\t}\n\treturn 0\n}\n\n// checkStanzaStatus determines the status of the shell completion stanza in content.\nfunc checkStanzaStatus(content string, currentVersion int) stanzaStatus {\n\tversion := findStanzaVersion(content)\n\tif version > 0 {\n\t\tif version >= currentVersion {\n\t\t\treturn stanzaCurrent\n\t\t}\n\t\treturn stanzaOutdated\n\t}\n\tif strings.Contains(content, shellCompletionLegacyComment) {\n\t\treturn stanzaLegacy\n\t}\n\treturn stanzaNotFound\n}\n\n// buildStanza constructs the full stanza block for the given version and completion line.\nfunc buildStanza(version int, completionLine string) string {\n\treturn fmt.Sprintf(shellCompletionOpenFormat, version) + \"\\n\" + completionLine + \"\\n\" + shellCompletionClose\n}\n\n// countStanzaOpeners counts how many opening stanza markers exist in content.\nfunc countStanzaOpeners(content string) int {\n\tcount := 0\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n// replaceStanza finds the open+close markers in content and replaces the block\n// with a new stanza. Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc replaceStanza(content string, version int, completionLine string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tnewStanza := buildStanza(version, completionLine)\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\tresult = append(result, newStanza)\n\tresult = append(result, lines[closeIdx+1:]...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeStanza finds and removes the stanza block from content.\n// Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc removeStanza(content string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\t// Skip blank line immediately after stanza if present\n\ttail := lines[closeIdx+1:]\n\tif len(tail) > 0 && strings.TrimSpace(tail[0]) == \"\" {\n\t\ttail = tail[1:]\n\t}\n\tresult = append(result, tail...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeLegacyCompletion removes the old-format comment and its following\n// completion line from content. Returns the modified content and whether\n// anything was removed.\nfunc removeLegacyCompletion(content, completionLine string) (string, bool) {\n\tlines := strings.Split(content, \"\\n\")\n\tvar result []string\n\tremoved := false\n\tfor i := 0; i < len(lines); i++ {\n\t\tif strings.TrimSpace(lines[i]) == shellCompletionLegacyComment {\n\t\t\t// Remove the comment line and the next line if it matches the completion line\n\t\t\tif i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == completionLine {\n\t\t\t\ti++ // skip next line too\n\t\t\t}\n\t\t\tremoved = true\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, lines[i])\n\t}\n\tif !removed {\n\t\treturn content, false\n\t}\n\treturn strings.Join(result, \"\\n\"), true\n}\n\n// errUnsupportedShell is returned when the user's shell is not supported for completion.\nvar errUnsupportedShell = errors.New(\"unsupported shell\")\n\n// shellCompletionTarget returns the rc file path and completion lines for the\n// user's current shell.\nfunc shellCompletionTarget() (shellName, rcFile, completionLine string, err error) {\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", fmt.Errorf(\"cannot determine home directory: %w\", err)\n\t}\n\n\tshell := os.Getenv(\"SHELL\")\n\tswitch {\n\tcase strings.Contains(shell, \"zsh\"):\n\t\treturn \"Zsh\",\n\t\t\tfilepath.Join(home, \".zshrc\"),\n\t\t\t\"source <(entire completion zsh)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"bash\"):\n\t\treturn \"Bash\",\n\t\t\tfilepath.Join(home, \".bashrc\"),\n\t\t\t\"source <(entire completion bash)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"fish\"):\n\t\treturn \"Fish\",\n\t\t\tfilepath.Join(home, \".config\", \"fish\", \"config.fish\"),\n\t\t\t\"entire completion fish | source\",\n\t\t\tnil\n\tdefault:\n\t\treturn \"\", \"\", \"\", errUnsupportedShell\n\t}\n}\n\n// promptShellCompletion offers to add shell completion to the user's rc file.\n// Handles versioned stanza detection, updates, and legacy migration.\nfunc promptShellCompletion(w io.Writer) error {\n\tshellName, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\tif errors.Is(err, errUnsupportedShell) {\n\t\t\tfmt.Fprintf(w, \"Note: Shell completion not available for your shell. Supported: zsh, bash, fish.\\n\")\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"shell completion: %w\", err)\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\tstatus := checkStanzaStatus(string(content), shellCompletionStanzaVersion)\n\tswitch status {\n\tcase stanzaCurrent:\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil\n\n\tcase stanzaOutdated:\n\t\tif !promptYesNo(\"Shell completion is outdated. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t// Re-read in case file changed\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, replaceErr := replaceStanza(string(content), shellCompletionStanzaVersion, completionLine)\n\t\tif replaceErr != nil {\n\t\t\tfmt.Fprintf(w, \"Warning: %v in %s. Please fix manually.\\n\", replaceErr, rcFile)\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaLegacy:\n\t\tif !promptYesNo(\"Shell completion uses old format. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, _ := removeLegacyCompletion(string(content), completionLine)\n\t\tupdated = updated + \"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\"\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaNotFound:\n\t\tif !promptYesNo(\"Enable shell completion?\") {\n\t\t\treturn nil\n\t\t}\n\t\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t}\n\n\treturn nil\n}\n\n// promptYesNo shows a yes/no selection prompt and returns whether the user chose yes.\nfunc promptYesNo(title string) bool {\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n<<<<<<< HEAD\n\t\t\t\tTitle(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)).\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tTitle(\"Enable shell completion?\").\n=======\n\t\t\t\tTitle(title).\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Yes\", \"yes\"),\n\t\t\t\t\thuh.NewOption(\"No\", \"no\"),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n<<<<<<< HEAD\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Restart your shell to activate\")\n\n\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\n\treturn nil\n=======\n\treturn selected == \"yes\"\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n}\n\n<<<<<<< HEAD\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), \"entire completion\")\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string, completionLine string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), completionLine)\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n=======\n// appendShellCompletion adds the completion stanza to the rc file.\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\nfunc appendShellCompletion(rcFile, completionLine string) error {\n\tif err := os.MkdirAll(filepath.Dir(rcFile), 0o755); err != nil {\n\t\treturn fmt.Errorf(\"creating directory: %w\", err)\n\t}\n\t//nolint:gosec // G302: Shell rc files need 0644 for user readability\n\tf, err := os.OpenFile(rcFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(\"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing completion: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeShellCompletion removes the shell completion stanza (or legacy format)\n// from the user's rc file. Used during uninstall.\nfunc removeShellCompletion() error {\n\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\ttext := string(content)\n\tupdated, removeErr := removeStanza(text)\n\tif removeErr != nil {\n\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n\t}\n\n\tif updated != text {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Fall back to legacy format removal\n\tupdated, removed := removeLegacyCompletion(text, completionLine)\n\tif removed {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// promptTelemetryConsent asks the user if they want to enable telemetry.\n// It modifies settings.Telemetry based on the user's choice or flags.\n// The caller is responsible for saving settings.\nfunc promptTelemetryConsent(settings *EntireSettings, telemetryFlag bool) error {\n\t// Handle --telemetry=false flag first (always overrides existing setting)\n\tif !telemetryFlag {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\t// Skip if already asked\n\tif settings.Telemetry != nil {\n\t\treturn nil\n\t}\n\n\t// Skip if env var disables telemetry (record as disabled)\n\tif os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\tconsent := true // Default to Yes\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewConfirm().\n\t\t\t\tTitle(\"Help improve Entire CLI?\").\n\t\t\t\tDescription(\"Share anonymous usage data. No code or personal info collected.\").\n\t\t\t\tAffirmative(\"Yes\").\n\t\t\t\tNegative(\"No\").\n\t\t\t\tValue(&consent),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn fmt.Errorf(\"telemetry prompt: %w\", err)\n\t}\n\n\tsettings.Telemetry = &consent\n\treturn nil\n}\n\n// runUninstall completely removes Entire from the repository.\nfunc runUninstall(w, errW io.Writer, force bool) error {\n\t// Check if we're in a git repository\n\tif _, err := paths.RepoRoot(); err != nil {\n\t\tfmt.Fprintln(errW, \"Not a git repository. Nothing to uninstall.\")\n\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t}\n\n\t// Gather counts for display\n\tsessionStateCount := countSessionStates()\n\tshadowBranchCount := countShadowBranches()\n\tgitHooksInstalled := strategy.IsGitHookInstalled()\n\tclaudeHooksInstalled := checkClaudeCodeHooksInstalled()\n\tgeminiHooksInstalled := checkGeminiCLIHooksInstalled()\n\tentireDirExists := checkEntireDirExists()\n\n\t// Check if there's anything to uninstall\n\tif !entireDirExists && !gitHooksInstalled && sessionStateCount == 0 &&\n\t\tshadowBranchCount == 0 && !claudeHooksInstalled && !geminiHooksInstalled {\n\t\tfmt.Fprintln(w, \"Entire is not installed in this repository.\")\n\t\treturn nil\n\t}\n\n\t// Show confirmation prompt unless --force\n\tif !force {\n\t\tfmt.Fprintln(w, \"\\nThis will completely remove Entire from this repository:\")\n\t\tif entireDirExists {\n\t\t\tfmt.Fprintln(w, \"  - .entire/ directory\")\n\t\t}\n\t\tif gitHooksInstalled {\n\t\t\tfmt.Fprintln(w, \"  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\")\n\t\t}\n\t\tif sessionStateCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Session state files (%d)\\n\", sessionStateCount)\n\t\t}\n\t\tif shadowBranchCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Shadow branches (%d)\\n\", shadowBranchCount)\n\t\t}\n\t\tswitch {\n\t\tcase claudeHooksInstalled && geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code, Gemini CLI)\")\n\t\tcase claudeHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code)\")\n\t\tcase geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Gemini CLI)\")\n\t\t}\n\t\tfmt.Fprintln(w)\n\n\t\tvar confirmed bool\n\t\tform := NewAccessibleForm(\n\t\t\thuh.NewGroup(\n\t\t\t\thuh.NewConfirm().\n\t\t\t\t\tTitle(\"Are you sure you want to uninstall Entire?\").\n\t\t\t\t\tAffirmative(\"Yes, uninstall\").\n\t\t\t\t\tNegative(\"Cancel\").\n\t\t\t\t\tValue(&confirmed),\n\t\t\t),\n\t\t)\n\n\t\tif err := form.Run(); err != nil {\n\t\t\treturn fmt.Errorf(\"confirmation cancelled: %w\", err)\n\t\t}\n\n\t\tif !confirmed {\n\t\t\tfmt.Fprintln(w, \"Uninstall cancelled.\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"\\nUninstalling Entire CLI...\")\n\n\t// 0. Remove shell completion from rc file\n\tif err := removeShellCompletion(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shell completion: %v\\n\", err)\n\t} else {\n\t\tfmt.Fprintln(w, \"  Removed shell completion\")\n\t}\n\n\t// 1. Remove agent hooks (lowest risk)\n\tif err := removeAgentHooks(w); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove agent hooks: %v\\n\", err)\n\t}\n\n\t// 2. Remove git hooks\n\tremoved, err := strategy.RemoveGitHook()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove git hooks: %v\\n\", err)\n\t} else if removed > 0 {\n\t\tfmt.Fprintf(w, \"  Removed git hooks (%d)\\n\", removed)\n\t}\n\n\t// 3. Remove session state files\n\tstatesRemoved, err := removeAllSessionStates()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove session states: %v\\n\", err)\n\t} else if statesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed session states (%d)\\n\", statesRemoved)\n\t}\n\n\t// 4. Remove .entire/ directory\n\tif err := removeEntireDirectory(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove .entire directory: %v\\n\", err)\n\t} else if entireDirExists {\n\t\tfmt.Fprintln(w, \"  Removed .entire directory\")\n\t}\n\n\t// 5. Remove shadow branches\n\tbranchesRemoved, err := removeAllShadowBranches()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shadow branches: %v\\n\", err)\n\t} else if branchesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed %d shadow branches\\n\", branchesRemoved)\n\t}\n\n\tfmt.Fprintln(w, \"\\nEntire CLI uninstalled successfully.\")\n\treturn nil\n}\n\n// countSessionStates returns the number of active session state files.\nfunc countSessionStates() int {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0\n\t}\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(states)\n}\n\n// countShadowBranches returns the number of shadow branches.\nfunc countShadowBranches() int {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(branches)\n}\n\n// checkClaudeCodeHooksInstalled checks if Claude Code hooks are installed.\nfunc checkClaudeCodeHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkGeminiCLIHooksInstalled checks if Gemini CLI hooks are installed.\nfunc checkGeminiCLIHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameGemini)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkEntireDirExists checks if the .entire directory exists.\nfunc checkEntireDirExists() bool {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\t_, err = os.Stat(entireDirAbs)\n\treturn err == nil\n}\n\n// removeAgentHooks removes hooks from all agents that support hooks.\nfunc removeAgentHooks(w io.Writer) error {\n\tvar errs []error\n\n\t// Remove Claude Code hooks\n\tclaudeAgent, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err == nil {\n\t\tif hookAgent, ok := claudeAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Claude Code hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove Gemini CLI hooks\n\tgeminiAgent, err := agent.Get(agent.AgentNameGemini)\n\tif err == nil {\n\t\tif hookAgent, ok := geminiAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Gemini CLI hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errors.Join(errs...)\n}\n\n// removeAllSessionStates removes all session state files and the directory.\nfunc removeAllSessionStates() (int, error) {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to create state store: %w\", err)\n\t}\n\n\t// Count states before removing\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list session states: %w\", err)\n\t}\n\tcount := len(states)\n\n\t// Remove the entire directory\n\tif err := store.RemoveAll(); err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to remove session states: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// removeEntireDirectory removes the .entire directory.\nfunc removeEntireDirectory() error {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\tif err := os.RemoveAll(entireDirAbs); err != nil {\n\t\treturn fmt.Errorf(\"failed to remove .entire directory: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeAllShadowBranches removes all shadow branches.\nfunc removeAllShadowBranches() (int, error) {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list shadow branches: %w\", err)\n\t}\n\tif len(branches) == 0 {\n\t\treturn 0, nil\n\t}\n\tdeleted, _, err := strategy.DeleteShadowBranches(branches)\n\treturn len(deleted), err\n}\n","structuredPatch":[{"oldStart":949,"oldLines":7,"newStart":949,"newLines":7,"lines":["     return nil"," ","   case stanzaNotFound:","-    if !promptYesNo(\"Enable shell completion?\") {","+    if !promptYesNo(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)) {","       return nil","     }","     if err := appendShellCompletion(rcFile, completionLine); err != nil {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5d3d3acd-ab20-45c7-ad90-e79b395539f3"}
{"parentUuid":"710a06fb-63bb-49d2-9a73-e7f9f242a3ce","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_014P5muM7r7TKxST6gxiQbnS","type":"message","role":"assistant","content":[{"type":"text","text":"Now resolve the second conflict — the `promptYesNo` function with its duplicate body:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":412,"cache_read_input_tokens":49561,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":412},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxZjgtqFcbMs5EDVJ41","type":"assistant","uuid":"19c8aae2-7fce-4042-927e-1026a4d120fb","timestamp":"2026-02-09T05:40:34.238Z"}
{"parentUuid":"19c8aae2-7fce-4042-927e-1026a4d120fb","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_014P5muM7r7TKxST6gxiQbnS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012xGH9Lj8whGJQTxAqQr7cQ","name":"Edit","input":{"replace_all":false,"file_path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","old_string":"\t\t\thuh.NewSelect[string]().\n<<<<<<< HEAD\n\t\t\t\tTitle(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)).\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tTitle(\"Enable shell completion?\").\n=======\n\t\t\t\tTitle(title).\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)","new_string":"\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(title)."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":412,"cache_read_input_tokens":49561,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":412},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxZjgtqFcbMs5EDVJ41","type":"assistant","uuid":"457f3095-495b-48d7-b387-65522b43e150","timestamp":"2026-02-09T05:40:36.811Z"}
{"parentUuid":"457f3095-495b-48d7-b387-65522b43e150","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_012xGH9Lj8whGJQTxAqQr7cQ","toolUseID":"toolu_012xGH9Lj8whGJQTxAqQr7cQ","timestamp":"2026-02-09T05:40:40.881Z","uuid":"ad5dac77-df94-4c4d-b029-a3ae4112fda8"}
{"parentUuid":"457f3095-495b-48d7-b387-65522b43e150","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012xGH9Lj8whGJQTxAqQr7cQ","type":"tool_result","content":"The file /Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go has been updated successfully."}]},"uuid":"0d0972aa-280d-483a-b60b-bfc3a669a634","timestamp":"2026-02-09T05:40:40.881Z","toolUseResult":{"filePath":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","oldString":"\t\t\thuh.NewSelect[string]().\n<<<<<<< HEAD\n\t\t\t\tTitle(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)).\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tTitle(\"Enable shell completion?\").\n=======\n\t\t\t\tTitle(title).\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)","newString":"\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(title).","originalFile":"package cli\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/entireio/cli/cmd/entire/cli/agent\"\n\t\"github.com/entireio/cli/cmd/entire/cli/paths\"\n\t\"github.com/entireio/cli/cmd/entire/cli/session\"\n\t\"github.com/entireio/cli/cmd/entire/cli/strategy\"\n\n\t\"github.com/charmbracelet/huh\"\n\t\"github.com/spf13/cobra\"\n)\n\n// Strategy display names for user-friendly selection\nconst (\n\tstrategyDisplayManualCommit = \"manual-commit\"\n\tstrategyDisplayAutoCommit   = \"auto-commit\"\n)\n\n// strategyDisplayToInternal maps user-friendly names to internal strategy names\nvar strategyDisplayToInternal = map[string]string{\n\tstrategyDisplayManualCommit: strategy.StrategyNameManualCommit,\n\tstrategyDisplayAutoCommit:   strategy.StrategyNameAutoCommit,\n}\n\n// strategyInternalToDisplay maps internal strategy names to user-friendly names\nvar strategyInternalToDisplay = map[string]string{\n\tstrategy.StrategyNameManualCommit: strategyDisplayManualCommit,\n\tstrategy.StrategyNameAutoCommit:   strategyDisplayAutoCommit,\n}\n\nfunc newEnableCmd() *cobra.Command {\n\tvar localDev bool\n\tvar ignoreUntracked bool\n\tvar useLocalSettings bool\n\tvar useProjectSettings bool\n\tvar agentName string\n\tvar strategyFlag string\n\tvar forceHooks bool\n\tvar skipPushSessions bool\n\tvar telemetry bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"enable\",\n\t\tShort: \"Enable Entire\",\n\t\tLong: `Enable Entire with session tracking for your AI agent workflows.\n\nUses the manual-commit strategy by default. To use a different strategy:\n\n  entire enable --strategy auto-commit\n\nStrategies: manual-commit (default), auto-commit`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\t// Check if we're in a git repository first - this is a prerequisite error,\n\t\t\t// not a usage error, so we silence Cobra's output and use SilentError\n\t\t\t// to prevent duplicate error output in main.go\n\t\t\tif _, err := paths.RepoRoot(); err != nil {\n\t\t\t\tcmd.SilenceUsage = true\n\t\t\t\tcmd.SilenceErrors = true\n\t\t\t\tfmt.Fprintln(cmd.ErrOrStderr(), \"Not a git repository. Please run 'entire enable' from within a git repository.\")\n\t\t\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t\t\t}\n\n\t\t\tif err := validateSetupFlags(useLocalSettings, useProjectSettings); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Non-interactive mode if --agent flag is provided\n\t\t\tif agentName != \"\" {\n\t\t\t\treturn setupAgentHooksNonInteractive(agent.AgentName(agentName), strategyFlag, localDev, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\t// If strategy is specified via flag, skip interactive selection\n\t\t\tif strategyFlag != \"\" {\n\t\t\t\treturn runEnableWithStrategy(cmd.OutOrStdout(), strategyFlag, localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\treturn runEnableInteractive(cmd.OutOrStdout(), localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&localDev, \"local-dev\", false, \"Use go run instead of entire binary for hooks\")\n\tcmd.Flags().MarkHidden(\"local-dev\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&ignoreUntracked, \"ignore-untracked\", false, \"Commit all new files without tracking pre-existing untracked files\")\n\tcmd.Flags().MarkHidden(\"ignore-untracked\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&useLocalSettings, \"local\", false, \"Write settings to settings.local.json instead of settings.json\")\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Write settings to settings.json even if it already exists\")\n\tcmd.Flags().StringVar(&agentName, \"agent\", \"\", \"Agent to setup hooks for (e.g., claude-code). Enables non-interactive mode.\")\n\tcmd.Flags().StringVar(&strategyFlag, \"strategy\", \"\", \"Strategy to use (manual-commit or auto-commit)\")\n\tcmd.Flags().BoolVarP(&forceHooks, \"force\", \"f\", false, \"Force reinstall hooks (removes existing Entire hooks first)\")\n\tcmd.Flags().BoolVar(&skipPushSessions, \"skip-push-sessions\", false, \"Disable automatic pushing of session logs on git push\")\n\tcmd.Flags().BoolVar(&telemetry, \"telemetry\", true, \"Enable anonymous usage analytics\")\n\t//nolint:errcheck,gosec // completion is optional, flag is defined above\n\tcmd.RegisterFlagCompletionFunc(\"strategy\", func(_ *cobra.Command, _ []string, _ string) ([]string, cobra.ShellCompDirective) {\n\t\treturn []string{strategyDisplayManualCommit, strategyDisplayAutoCommit}, cobra.ShellCompDirectiveNoFileComp\n\t})\n\n\t// Add subcommands for automation/testing\n\tcmd.AddCommand(newSetupGitHookCmd())\n\n\treturn cmd\n}\n\nfunc newDisableCmd() *cobra.Command {\n\tvar useProjectSettings bool\n\tvar uninstall bool\n\tvar force bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"disable\",\n\t\tShort: \"Disable Entire\",\n\t\tLong: `Disable Entire temporarily. Hooks will exit silently and commands will show a disabled message.\n\nUse --uninstall to completely remove Entire from this repository, including:\n  - .entire/ directory (settings, logs, metadata)\n  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\n  - Session state files (.git/entire-sessions/)\n  - Shadow branches (entire/<hash>)\n  - Agent hooks (Claude Code, Gemini CLI)`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tif uninstall {\n\t\t\t\treturn runUninstall(cmd.OutOrStdout(), cmd.ErrOrStderr(), force)\n\t\t\t}\n\t\t\treturn runDisable(cmd.OutOrStdout(), useProjectSettings)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Update settings.json instead of settings.local.json\")\n\tcmd.Flags().BoolVar(&uninstall, \"uninstall\", false, \"Completely remove Entire from this repository\")\n\tcmd.Flags().BoolVar(&force, \"force\", false, \"Skip confirmation prompt (use with --uninstall)\")\n\n\treturn cmd\n}\n\n// runEnableWithStrategy enables Entire with a specified strategy (non-interactive).\n// The selectedStrategy can be either a display name (manual-commit, auto-commit)\n// or an internal name (manual-commit, auto-commit).\nfunc runEnableWithStrategy(w io.Writer, selectedStrategy string, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Map the strategy to internal name if it's a display name\n\tinternalStrategy := selectedStrategy\n\tif mapped, ok := strategyDisplayToInternal[selectedStrategy]; ok {\n\t\tinternalStrategy = mapped\n\t}\n\n\t// Validate the strategy exists\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", selectedStrategy)\n\t}\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\t// Determine which settings file to write to\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, showNotification := determineSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\n\tif showNotification {\n\t\tfmt.Fprintln(w, \"Info: Project settings exist. Saving to settings.local.json instead.\")\n\t\tfmt.Fprintln(w, \"  Use --project to update the project settings file.\")\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tdisplayName := selectedStrategy\n\tif dn, ok := strategyInternalToDisplay[internalStrategy]; ok {\n\t\tdisplayName = dn\n\t}\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", displayName)\n\n\treturn nil\n}\n\n// runEnableInteractive runs the interactive enable flow.\nfunc runEnableInteractive(w io.Writer, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Use the default strategy (manual-commit)\n\tinternalStrategy := strategy.DefaultStrategyName\n\tfmt.Fprintf(w, \"Using %s strategy (use --strategy to change)\\n\\n\", strategyInternalToDisplay[internalStrategy])\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Ask about telemetry consent (only if not already asked)\n\tif err := promptTelemetryConsent(settings, telemetry); err != nil {\n\t\treturn fmt.Errorf(\"telemetry consent: %w\", err)\n\t}\n\n\t// Determine which settings file to write to (interactive prompt if settings.json exists)\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, err := promptSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", strategyInternalToDisplay[internalStrategy])\n\n\treturn nil\n}\n\n// runEnable is a simple enable that just sets the enabled flag (for programmatic use).\nfunc runEnable(w io.Writer) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = true\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now enabled.\")\n\treturn nil\n}\n\nfunc runDisable(w io.Writer, useProjectSettings bool) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = false\n\n\t// If --project flag is specified, always write to project settings\n\tif useProjectSettings {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t} else {\n\t\t// Always write to local settings file (create if doesn't exist)\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now disabled.\")\n\treturn nil\n}\n\n// DisabledMessage is the message shown when Entire is disabled\nconst DisabledMessage = \"Entire is disabled. Run `entire enable` to re-enable.\"\n\n// checkDisabledGuard checks if Entire is disabled and prints a message if so.\n// Returns true if the caller should exit (i.e., Entire is disabled).\n// On error reading settings, defaults to enabled (returns false).\nfunc checkDisabledGuard(w io.Writer) bool {\n\tenabled, err := IsEnabled()\n\tif err != nil {\n\t\t// Default to enabled on error\n\t\treturn false\n\t}\n\tif !enabled {\n\t\tfmt.Fprintln(w, DisabledMessage)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// setupClaudeCodeHook sets up Claude Code hooks.\n// This is a convenience wrapper that uses the agent package.\n// Returns the number of hooks installed (0 if already installed).\nfunc setupClaudeCodeHook(localDev, forceHooks bool) (int, error) {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get claude-code agent: %w\", err)\n\t}\n\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn 0, errors.New(\"claude-code agent does not support hooks\")\n\t}\n\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to install claude-code hooks: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// setupAgentHooksNonInteractive sets up hooks for a specific agent non-interactively.\n// If strategyName is provided, it sets the strategy; otherwise uses default.\nfunc setupAgentHooksNonInteractive(agentName agent.AgentName, strategyName string, localDev, forceHooks, skipPushSessions, telemetry bool) error {\n\tag, err := agent.Get(agentName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown agent: %s\", agentName)\n\t}\n\n\t// Check if agent supports hooks\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn fmt.Errorf(\"agent %s does not support hooks\", agentName)\n\t}\n\n\t// Install hooks\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install hooks for %s: %w\", agentName, err)\n\t}\n\n\tif count == 0 {\n\t\tmsg := fmt.Sprintf(\"Hooks for %s already installed\", ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t} else {\n\t\tmsg := fmt.Sprintf(\"Installed %d hooks for %s\", count, ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\n\t// Update settings to store the strategy\n\tsettings, _ := LoadEntireSettings() //nolint:errcheck // settings defaults are fine\n\tsettings.Enabled = true\n\tif localDev {\n\t\tsettings.LocalDev = localDev\n\t}\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Set strategy if provided\n\tif strategyName != \"\" {\n\t\t// Map display name to internal name if needed\n\t\tinternalStrategy := strategyName\n\t\tif mapped, ok := strategyDisplayToInternal[strategyName]; ok {\n\t\t\tinternalStrategy = mapped\n\t\t}\n\t\t// Validate the strategy exists\n\t\tif _, err := strategy.Get(internalStrategy); err != nil {\n\t\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", strategyName)\n\t\t}\n\t\tsettings.Strategy = internalStrategy\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tif _, err := strategy.InstallGitHook(true); err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\n\t// Let the strategy handle its own setup requirements (creates entire/sessions branch, etc.)\n\tstrat, err := strategy.Get(settings.Strategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// validateSetupFlags checks that --local and --project flags are not both specified.\nfunc validateSetupFlags(useLocal, useProject bool) error {\n\tif useLocal && useProject {\n\t\treturn errors.New(\"cannot specify both --project and --local\")\n\t}\n\treturn nil\n}\n\n// determineSettingsTarget decides whether to write to settings.local.json based on:\n// - Whether settings.json already exists\n// - The --local and --project flags\n// Returns (useLocal, showNotification).\nfunc determineSettingsTarget(entireDir string, useLocal, useProject bool) (bool, bool) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, false\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, false\n\t}\n\n\t// No flags specified - check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); err == nil {\n\t\t// Settings file exists - auto-redirect to local with notification\n\t\treturn true, true\n\t}\n\n\t// Settings file doesn't exist - create it\n\treturn false, false\n}\n\n// Settings target options for interactive prompt\nconst (\n\tsettingsTargetProject = \"project\"\n\tsettingsTargetLocal   = \"local\"\n)\n\n// promptSettingsTarget interactively asks the user where to save settings\n// when settings.json already exists and no flags were provided.\n// Returns (useLocal, error).\nfunc promptSettingsTarget(entireDir string, useLocal, useProject bool) (bool, error) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, nil\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, nil\n\t}\n\n\t// Check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); os.IsNotExist(err) {\n\t\t// Settings file doesn't exist - create it (no prompt needed)\n\t\treturn false, nil\n\t}\n\n\t// Settings file exists - prompt user\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(\"Project settings already exist. Where should settings be saved?\").\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Update project settings (settings.json)\", settingsTargetProject),\n\t\t\t\t\thuh.NewOption(\"Use local settings (settings.local.json, gitignored)\", settingsTargetLocal),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false, fmt.Errorf(\"selection cancelled: %w\", err)\n\t}\n\n\treturn selected == settingsTargetLocal, nil\n}\n\n// setupEntireDirectory creates the .entire directory and gitignore.\n// Returns true if the directory was created, false if it already existed.\nfunc setupEntireDirectory() (bool, error) {\n\t// Get absolute path for the .entire directory\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\n\t// Check if directory already exists\n\tcreated := false\n\tif _, err := os.Stat(entireDirAbs); os.IsNotExist(err) {\n\t\tcreated = true\n\t}\n\n\t// Create .entire directory\n\t//nolint:gosec // G301: Project directory needs standard permissions for git\n\tif err := os.MkdirAll(entireDirAbs, 0o755); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to create .entire directory: %w\", err)\n\t}\n\n\t// Create/update .gitignore with all required entries\n\tif err := strategy.EnsureEntireGitignore(); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to setup .gitignore: %w\", err)\n\t}\n\n\treturn created, nil\n}\n\n// setupGitHook installs the prepare-commit-msg hook for context trailers.\nfunc setupGitHook() error {\n\t// Use shared implementation from strategy package\n\t// The localDev setting is read from settings.json\n\t_, err := strategy.InstallGitHook(false) // not silent - show output during setup\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hook: %w\", err)\n\t}\n\treturn nil\n}\n\n// newSetupGitHookCmd creates the standalone git-hook setup command\nfunc newSetupGitHookCmd() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:    \"git-hook\",\n\t\tShort:  \"Install git hook for session context trailers\",\n\t\tHidden: true, // Hidden as it's mainly for testing\n\t\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\treturn setupGitHook()\n\t\t},\n\t}\n\n\treturn cmd\n}\n\nfunc newCurlBashPostInstallCmd() *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:    \"curl-bash-post-install\",\n\t\tShort:  \"Post-install tasks for curl|bash installer\",\n\t\tHidden: true,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tw := cmd.OutOrStdout()\n\t\t\tif err := promptShellCompletion(w); err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Note: Shell completion setup skipped: %v\\n\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n}\n\n// Shell completion stanza management.\n// The stanza is a versioned, delimited block written to ~/.zshrc or ~/.bashrc:\n//\n//\t# Entire CLI completions (v1) {{{\n//\tautoload -Uz compinit && compinit && source <(entire completion zsh)\n//\t# }}}\nconst (\n\tshellCompletionStanzaVersion = 1\n\tshellCompletionOpenFormat    = \"# Entire CLI completions (v%d) {{{\"\n\tshellCompletionClose         = \"# }}}\"\n\tshellCompletionLegacyComment = \"# Entire CLI shell completion\" // old format for migration\n)\n\ntype stanzaStatus int\n\nconst (\n\tstanzaNotFound stanzaStatus = iota\n\tstanzaCurrent\n\tstanzaOutdated\n\tstanzaLegacy\n)\n\nvar (\n\terrStanzaCorrupted = errors.New(\"shell completion block is corrupted (missing closing marker)\")\n\terrMultipleStanzas = errors.New(\"found multiple shell completion blocks\")\n)\n\n// findStanzaVersion scans content for the opening stanza marker and returns\n// the version number. Returns 0 if no stanza is found.\nfunc findStanzaVersion(content string) int {\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\treturn version\n\t\t}\n\t}\n\treturn 0\n}\n\n// checkStanzaStatus determines the status of the shell completion stanza in content.\nfunc checkStanzaStatus(content string, currentVersion int) stanzaStatus {\n\tversion := findStanzaVersion(content)\n\tif version > 0 {\n\t\tif version >= currentVersion {\n\t\t\treturn stanzaCurrent\n\t\t}\n\t\treturn stanzaOutdated\n\t}\n\tif strings.Contains(content, shellCompletionLegacyComment) {\n\t\treturn stanzaLegacy\n\t}\n\treturn stanzaNotFound\n}\n\n// buildStanza constructs the full stanza block for the given version and completion line.\nfunc buildStanza(version int, completionLine string) string {\n\treturn fmt.Sprintf(shellCompletionOpenFormat, version) + \"\\n\" + completionLine + \"\\n\" + shellCompletionClose\n}\n\n// countStanzaOpeners counts how many opening stanza markers exist in content.\nfunc countStanzaOpeners(content string) int {\n\tcount := 0\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n// replaceStanza finds the open+close markers in content and replaces the block\n// with a new stanza. Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc replaceStanza(content string, version int, completionLine string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tnewStanza := buildStanza(version, completionLine)\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\tresult = append(result, newStanza)\n\tresult = append(result, lines[closeIdx+1:]...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeStanza finds and removes the stanza block from content.\n// Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc removeStanza(content string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\t// Skip blank line immediately after stanza if present\n\ttail := lines[closeIdx+1:]\n\tif len(tail) > 0 && strings.TrimSpace(tail[0]) == \"\" {\n\t\ttail = tail[1:]\n\t}\n\tresult = append(result, tail...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeLegacyCompletion removes the old-format comment and its following\n// completion line from content. Returns the modified content and whether\n// anything was removed.\nfunc removeLegacyCompletion(content, completionLine string) (string, bool) {\n\tlines := strings.Split(content, \"\\n\")\n\tvar result []string\n\tremoved := false\n\tfor i := 0; i < len(lines); i++ {\n\t\tif strings.TrimSpace(lines[i]) == shellCompletionLegacyComment {\n\t\t\t// Remove the comment line and the next line if it matches the completion line\n\t\t\tif i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == completionLine {\n\t\t\t\ti++ // skip next line too\n\t\t\t}\n\t\t\tremoved = true\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, lines[i])\n\t}\n\tif !removed {\n\t\treturn content, false\n\t}\n\treturn strings.Join(result, \"\\n\"), true\n}\n\n// errUnsupportedShell is returned when the user's shell is not supported for completion.\nvar errUnsupportedShell = errors.New(\"unsupported shell\")\n\n// shellCompletionTarget returns the rc file path and completion lines for the\n// user's current shell.\nfunc shellCompletionTarget() (shellName, rcFile, completionLine string, err error) {\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", fmt.Errorf(\"cannot determine home directory: %w\", err)\n\t}\n\n\tshell := os.Getenv(\"SHELL\")\n\tswitch {\n\tcase strings.Contains(shell, \"zsh\"):\n\t\treturn \"Zsh\",\n\t\t\tfilepath.Join(home, \".zshrc\"),\n\t\t\t\"source <(entire completion zsh)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"bash\"):\n\t\treturn \"Bash\",\n\t\t\tfilepath.Join(home, \".bashrc\"),\n\t\t\t\"source <(entire completion bash)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"fish\"):\n\t\treturn \"Fish\",\n\t\t\tfilepath.Join(home, \".config\", \"fish\", \"config.fish\"),\n\t\t\t\"entire completion fish | source\",\n\t\t\tnil\n\tdefault:\n\t\treturn \"\", \"\", \"\", errUnsupportedShell\n\t}\n}\n\n// promptShellCompletion offers to add shell completion to the user's rc file.\n// Handles versioned stanza detection, updates, and legacy migration.\nfunc promptShellCompletion(w io.Writer) error {\n\tshellName, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\tif errors.Is(err, errUnsupportedShell) {\n\t\t\tfmt.Fprintf(w, \"Note: Shell completion not available for your shell. Supported: zsh, bash, fish.\\n\")\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"shell completion: %w\", err)\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\tstatus := checkStanzaStatus(string(content), shellCompletionStanzaVersion)\n\tswitch status {\n\tcase stanzaCurrent:\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil\n\n\tcase stanzaOutdated:\n\t\tif !promptYesNo(\"Shell completion is outdated. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t// Re-read in case file changed\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, replaceErr := replaceStanza(string(content), shellCompletionStanzaVersion, completionLine)\n\t\tif replaceErr != nil {\n\t\t\tfmt.Fprintf(w, \"Warning: %v in %s. Please fix manually.\\n\", replaceErr, rcFile)\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaLegacy:\n\t\tif !promptYesNo(\"Shell completion uses old format. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, _ := removeLegacyCompletion(string(content), completionLine)\n\t\tupdated = updated + \"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\"\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaNotFound:\n\t\tif !promptYesNo(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)) {\n\t\t\treturn nil\n\t\t}\n\t\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t}\n\n\treturn nil\n}\n\n// promptYesNo shows a yes/no selection prompt and returns whether the user chose yes.\nfunc promptYesNo(title string) bool {\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n<<<<<<< HEAD\n\t\t\t\tTitle(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)).\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tTitle(\"Enable shell completion?\").\n=======\n\t\t\t\tTitle(title).\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Yes\", \"yes\"),\n\t\t\t\t\thuh.NewOption(\"No\", \"no\"),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n<<<<<<< HEAD\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Restart your shell to activate\")\n\n\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\n\treturn nil\n=======\n\treturn selected == \"yes\"\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n}\n\n<<<<<<< HEAD\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), \"entire completion\")\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string, completionLine string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), completionLine)\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n=======\n// appendShellCompletion adds the completion stanza to the rc file.\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\nfunc appendShellCompletion(rcFile, completionLine string) error {\n\tif err := os.MkdirAll(filepath.Dir(rcFile), 0o755); err != nil {\n\t\treturn fmt.Errorf(\"creating directory: %w\", err)\n\t}\n\t//nolint:gosec // G302: Shell rc files need 0644 for user readability\n\tf, err := os.OpenFile(rcFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(\"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing completion: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeShellCompletion removes the shell completion stanza (or legacy format)\n// from the user's rc file. Used during uninstall.\nfunc removeShellCompletion() error {\n\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\ttext := string(content)\n\tupdated, removeErr := removeStanza(text)\n\tif removeErr != nil {\n\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n\t}\n\n\tif updated != text {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Fall back to legacy format removal\n\tupdated, removed := removeLegacyCompletion(text, completionLine)\n\tif removed {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// promptTelemetryConsent asks the user if they want to enable telemetry.\n// It modifies settings.Telemetry based on the user's choice or flags.\n// The caller is responsible for saving settings.\nfunc promptTelemetryConsent(settings *EntireSettings, telemetryFlag bool) error {\n\t// Handle --telemetry=false flag first (always overrides existing setting)\n\tif !telemetryFlag {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\t// Skip if already asked\n\tif settings.Telemetry != nil {\n\t\treturn nil\n\t}\n\n\t// Skip if env var disables telemetry (record as disabled)\n\tif os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\tconsent := true // Default to Yes\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewConfirm().\n\t\t\t\tTitle(\"Help improve Entire CLI?\").\n\t\t\t\tDescription(\"Share anonymous usage data. No code or personal info collected.\").\n\t\t\t\tAffirmative(\"Yes\").\n\t\t\t\tNegative(\"No\").\n\t\t\t\tValue(&consent),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn fmt.Errorf(\"telemetry prompt: %w\", err)\n\t}\n\n\tsettings.Telemetry = &consent\n\treturn nil\n}\n\n// runUninstall completely removes Entire from the repository.\nfunc runUninstall(w, errW io.Writer, force bool) error {\n\t// Check if we're in a git repository\n\tif _, err := paths.RepoRoot(); err != nil {\n\t\tfmt.Fprintln(errW, \"Not a git repository. Nothing to uninstall.\")\n\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t}\n\n\t// Gather counts for display\n\tsessionStateCount := countSessionStates()\n\tshadowBranchCount := countShadowBranches()\n\tgitHooksInstalled := strategy.IsGitHookInstalled()\n\tclaudeHooksInstalled := checkClaudeCodeHooksInstalled()\n\tgeminiHooksInstalled := checkGeminiCLIHooksInstalled()\n\tentireDirExists := checkEntireDirExists()\n\n\t// Check if there's anything to uninstall\n\tif !entireDirExists && !gitHooksInstalled && sessionStateCount == 0 &&\n\t\tshadowBranchCount == 0 && !claudeHooksInstalled && !geminiHooksInstalled {\n\t\tfmt.Fprintln(w, \"Entire is not installed in this repository.\")\n\t\treturn nil\n\t}\n\n\t// Show confirmation prompt unless --force\n\tif !force {\n\t\tfmt.Fprintln(w, \"\\nThis will completely remove Entire from this repository:\")\n\t\tif entireDirExists {\n\t\t\tfmt.Fprintln(w, \"  - .entire/ directory\")\n\t\t}\n\t\tif gitHooksInstalled {\n\t\t\tfmt.Fprintln(w, \"  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\")\n\t\t}\n\t\tif sessionStateCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Session state files (%d)\\n\", sessionStateCount)\n\t\t}\n\t\tif shadowBranchCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Shadow branches (%d)\\n\", shadowBranchCount)\n\t\t}\n\t\tswitch {\n\t\tcase claudeHooksInstalled && geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code, Gemini CLI)\")\n\t\tcase claudeHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code)\")\n\t\tcase geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Gemini CLI)\")\n\t\t}\n\t\tfmt.Fprintln(w)\n\n\t\tvar confirmed bool\n\t\tform := NewAccessibleForm(\n\t\t\thuh.NewGroup(\n\t\t\t\thuh.NewConfirm().\n\t\t\t\t\tTitle(\"Are you sure you want to uninstall Entire?\").\n\t\t\t\t\tAffirmative(\"Yes, uninstall\").\n\t\t\t\t\tNegative(\"Cancel\").\n\t\t\t\t\tValue(&confirmed),\n\t\t\t),\n\t\t)\n\n\t\tif err := form.Run(); err != nil {\n\t\t\treturn fmt.Errorf(\"confirmation cancelled: %w\", err)\n\t\t}\n\n\t\tif !confirmed {\n\t\t\tfmt.Fprintln(w, \"Uninstall cancelled.\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"\\nUninstalling Entire CLI...\")\n\n\t// 0. Remove shell completion from rc file\n\tif err := removeShellCompletion(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shell completion: %v\\n\", err)\n\t} else {\n\t\tfmt.Fprintln(w, \"  Removed shell completion\")\n\t}\n\n\t// 1. Remove agent hooks (lowest risk)\n\tif err := removeAgentHooks(w); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove agent hooks: %v\\n\", err)\n\t}\n\n\t// 2. Remove git hooks\n\tremoved, err := strategy.RemoveGitHook()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove git hooks: %v\\n\", err)\n\t} else if removed > 0 {\n\t\tfmt.Fprintf(w, \"  Removed git hooks (%d)\\n\", removed)\n\t}\n\n\t// 3. Remove session state files\n\tstatesRemoved, err := removeAllSessionStates()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove session states: %v\\n\", err)\n\t} else if statesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed session states (%d)\\n\", statesRemoved)\n\t}\n\n\t// 4. Remove .entire/ directory\n\tif err := removeEntireDirectory(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove .entire directory: %v\\n\", err)\n\t} else if entireDirExists {\n\t\tfmt.Fprintln(w, \"  Removed .entire directory\")\n\t}\n\n\t// 5. Remove shadow branches\n\tbranchesRemoved, err := removeAllShadowBranches()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shadow branches: %v\\n\", err)\n\t} else if branchesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed %d shadow branches\\n\", branchesRemoved)\n\t}\n\n\tfmt.Fprintln(w, \"\\nEntire CLI uninstalled successfully.\")\n\treturn nil\n}\n\n// countSessionStates returns the number of active session state files.\nfunc countSessionStates() int {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0\n\t}\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(states)\n}\n\n// countShadowBranches returns the number of shadow branches.\nfunc countShadowBranches() int {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(branches)\n}\n\n// checkClaudeCodeHooksInstalled checks if Claude Code hooks are installed.\nfunc checkClaudeCodeHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkGeminiCLIHooksInstalled checks if Gemini CLI hooks are installed.\nfunc checkGeminiCLIHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameGemini)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkEntireDirExists checks if the .entire directory exists.\nfunc checkEntireDirExists() bool {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\t_, err = os.Stat(entireDirAbs)\n\treturn err == nil\n}\n\n// removeAgentHooks removes hooks from all agents that support hooks.\nfunc removeAgentHooks(w io.Writer) error {\n\tvar errs []error\n\n\t// Remove Claude Code hooks\n\tclaudeAgent, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err == nil {\n\t\tif hookAgent, ok := claudeAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Claude Code hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove Gemini CLI hooks\n\tgeminiAgent, err := agent.Get(agent.AgentNameGemini)\n\tif err == nil {\n\t\tif hookAgent, ok := geminiAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Gemini CLI hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errors.Join(errs...)\n}\n\n// removeAllSessionStates removes all session state files and the directory.\nfunc removeAllSessionStates() (int, error) {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to create state store: %w\", err)\n\t}\n\n\t// Count states before removing\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list session states: %w\", err)\n\t}\n\tcount := len(states)\n\n\t// Remove the entire directory\n\tif err := store.RemoveAll(); err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to remove session states: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// removeEntireDirectory removes the .entire directory.\nfunc removeEntireDirectory() error {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\tif err := os.RemoveAll(entireDirAbs); err != nil {\n\t\treturn fmt.Errorf(\"failed to remove .entire directory: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeAllShadowBranches removes all shadow branches.\nfunc removeAllShadowBranches() (int, error) {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list shadow branches: %w\", err)\n\t}\n\tif len(branches) == 0 {\n\t\treturn 0, nil\n\t}\n\tdeleted, _, err := strategy.DeleteShadowBranches(branches)\n\treturn len(deleted), err\n}\n","structuredPatch":[{"oldStart":968,"oldLines":13,"newStart":968,"newLines":7,"lines":["   form := NewAccessibleForm(","     huh.NewGroup(","       huh.NewSelect[string]().","-<<<<<<< HEAD","-        Title(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)).","-||||||| parent of b6ff09d (Add versioned stanza management for shell completion)","-        Title(\"Enable shell completion?\").","-=======","         Title(title).","->>>>>>> b6ff09d (Add versioned stanza management for shell completion)","         Options(","           huh.NewOption(\"Yes\", \"yes\"),","           huh.NewOption(\"No\", \"no\"),"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"457f3095-495b-48d7-b387-65522b43e150"}
{"parentUuid":"0d0972aa-280d-483a-b60b-bfc3a669a634","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01GWfZXtiTs1hkxZV5GLatgw","type":"message","role":"assistant","content":[{"type":"text","text":"Now resolve the third conflict — the remaining body after the form:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":419,"cache_read_input_tokens":49973,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":419},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxafMitccTWx85KSuyD","type":"assistant","uuid":"c2ea2367-30c7-4a2b-9a3e-222a50bd0be3","timestamp":"2026-02-09T05:40:46.874Z"}
{"parentUuid":"c2ea2367-30c7-4a2b-9a3e-222a50bd0be3","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01GWfZXtiTs1hkxZV5GLatgw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016R9cdfqxMdaZDbX9wvkHHm","name":"Edit","input":{"replace_all":false,"file_path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","old_string":"\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n<<<<<<< HEAD\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Restart your shell to activate\")\n\n\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\n\treturn nil\n=======\n\treturn selected == \"yes\"\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n}","new_string":"\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n\treturn selected == \"yes\"\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":419,"cache_read_input_tokens":49973,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":419},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxafMitccTWx85KSuyD","type":"assistant","uuid":"57780539-43a6-4be8-84a8-1e57ee11f0cb","timestamp":"2026-02-09T05:40:51.903Z"}
{"parentUuid":"57780539-43a6-4be8-84a8-1e57ee11f0cb","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_016R9cdfqxMdaZDbX9wvkHHm","toolUseID":"toolu_016R9cdfqxMdaZDbX9wvkHHm","timestamp":"2026-02-09T05:40:58.449Z","uuid":"bd01b90c-8604-4099-b8f1-4dce352730f3"}
{"parentUuid":"57780539-43a6-4be8-84a8-1e57ee11f0cb","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016R9cdfqxMdaZDbX9wvkHHm","type":"tool_result","content":"The file /Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go has been updated successfully."}]},"uuid":"4d6d1993-cf8b-42a3-abfc-8ffca272ef53","timestamp":"2026-02-09T05:40:58.449Z","toolUseResult":{"filePath":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","oldString":"\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n<<<<<<< HEAD\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Restart your shell to activate\")\n\n\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\n\treturn nil\n=======\n\treturn selected == \"yes\"\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n}","newString":"\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n\treturn selected == \"yes\"\n}","originalFile":"package cli\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/entireio/cli/cmd/entire/cli/agent\"\n\t\"github.com/entireio/cli/cmd/entire/cli/paths\"\n\t\"github.com/entireio/cli/cmd/entire/cli/session\"\n\t\"github.com/entireio/cli/cmd/entire/cli/strategy\"\n\n\t\"github.com/charmbracelet/huh\"\n\t\"github.com/spf13/cobra\"\n)\n\n// Strategy display names for user-friendly selection\nconst (\n\tstrategyDisplayManualCommit = \"manual-commit\"\n\tstrategyDisplayAutoCommit   = \"auto-commit\"\n)\n\n// strategyDisplayToInternal maps user-friendly names to internal strategy names\nvar strategyDisplayToInternal = map[string]string{\n\tstrategyDisplayManualCommit: strategy.StrategyNameManualCommit,\n\tstrategyDisplayAutoCommit:   strategy.StrategyNameAutoCommit,\n}\n\n// strategyInternalToDisplay maps internal strategy names to user-friendly names\nvar strategyInternalToDisplay = map[string]string{\n\tstrategy.StrategyNameManualCommit: strategyDisplayManualCommit,\n\tstrategy.StrategyNameAutoCommit:   strategyDisplayAutoCommit,\n}\n\nfunc newEnableCmd() *cobra.Command {\n\tvar localDev bool\n\tvar ignoreUntracked bool\n\tvar useLocalSettings bool\n\tvar useProjectSettings bool\n\tvar agentName string\n\tvar strategyFlag string\n\tvar forceHooks bool\n\tvar skipPushSessions bool\n\tvar telemetry bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"enable\",\n\t\tShort: \"Enable Entire\",\n\t\tLong: `Enable Entire with session tracking for your AI agent workflows.\n\nUses the manual-commit strategy by default. To use a different strategy:\n\n  entire enable --strategy auto-commit\n\nStrategies: manual-commit (default), auto-commit`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\t// Check if we're in a git repository first - this is a prerequisite error,\n\t\t\t// not a usage error, so we silence Cobra's output and use SilentError\n\t\t\t// to prevent duplicate error output in main.go\n\t\t\tif _, err := paths.RepoRoot(); err != nil {\n\t\t\t\tcmd.SilenceUsage = true\n\t\t\t\tcmd.SilenceErrors = true\n\t\t\t\tfmt.Fprintln(cmd.ErrOrStderr(), \"Not a git repository. Please run 'entire enable' from within a git repository.\")\n\t\t\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t\t\t}\n\n\t\t\tif err := validateSetupFlags(useLocalSettings, useProjectSettings); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Non-interactive mode if --agent flag is provided\n\t\t\tif agentName != \"\" {\n\t\t\t\treturn setupAgentHooksNonInteractive(agent.AgentName(agentName), strategyFlag, localDev, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\t// If strategy is specified via flag, skip interactive selection\n\t\t\tif strategyFlag != \"\" {\n\t\t\t\treturn runEnableWithStrategy(cmd.OutOrStdout(), strategyFlag, localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\treturn runEnableInteractive(cmd.OutOrStdout(), localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&localDev, \"local-dev\", false, \"Use go run instead of entire binary for hooks\")\n\tcmd.Flags().MarkHidden(\"local-dev\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&ignoreUntracked, \"ignore-untracked\", false, \"Commit all new files without tracking pre-existing untracked files\")\n\tcmd.Flags().MarkHidden(\"ignore-untracked\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&useLocalSettings, \"local\", false, \"Write settings to settings.local.json instead of settings.json\")\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Write settings to settings.json even if it already exists\")\n\tcmd.Flags().StringVar(&agentName, \"agent\", \"\", \"Agent to setup hooks for (e.g., claude-code). Enables non-interactive mode.\")\n\tcmd.Flags().StringVar(&strategyFlag, \"strategy\", \"\", \"Strategy to use (manual-commit or auto-commit)\")\n\tcmd.Flags().BoolVarP(&forceHooks, \"force\", \"f\", false, \"Force reinstall hooks (removes existing Entire hooks first)\")\n\tcmd.Flags().BoolVar(&skipPushSessions, \"skip-push-sessions\", false, \"Disable automatic pushing of session logs on git push\")\n\tcmd.Flags().BoolVar(&telemetry, \"telemetry\", true, \"Enable anonymous usage analytics\")\n\t//nolint:errcheck,gosec // completion is optional, flag is defined above\n\tcmd.RegisterFlagCompletionFunc(\"strategy\", func(_ *cobra.Command, _ []string, _ string) ([]string, cobra.ShellCompDirective) {\n\t\treturn []string{strategyDisplayManualCommit, strategyDisplayAutoCommit}, cobra.ShellCompDirectiveNoFileComp\n\t})\n\n\t// Add subcommands for automation/testing\n\tcmd.AddCommand(newSetupGitHookCmd())\n\n\treturn cmd\n}\n\nfunc newDisableCmd() *cobra.Command {\n\tvar useProjectSettings bool\n\tvar uninstall bool\n\tvar force bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"disable\",\n\t\tShort: \"Disable Entire\",\n\t\tLong: `Disable Entire temporarily. Hooks will exit silently and commands will show a disabled message.\n\nUse --uninstall to completely remove Entire from this repository, including:\n  - .entire/ directory (settings, logs, metadata)\n  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\n  - Session state files (.git/entire-sessions/)\n  - Shadow branches (entire/<hash>)\n  - Agent hooks (Claude Code, Gemini CLI)`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tif uninstall {\n\t\t\t\treturn runUninstall(cmd.OutOrStdout(), cmd.ErrOrStderr(), force)\n\t\t\t}\n\t\t\treturn runDisable(cmd.OutOrStdout(), useProjectSettings)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Update settings.json instead of settings.local.json\")\n\tcmd.Flags().BoolVar(&uninstall, \"uninstall\", false, \"Completely remove Entire from this repository\")\n\tcmd.Flags().BoolVar(&force, \"force\", false, \"Skip confirmation prompt (use with --uninstall)\")\n\n\treturn cmd\n}\n\n// runEnableWithStrategy enables Entire with a specified strategy (non-interactive).\n// The selectedStrategy can be either a display name (manual-commit, auto-commit)\n// or an internal name (manual-commit, auto-commit).\nfunc runEnableWithStrategy(w io.Writer, selectedStrategy string, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Map the strategy to internal name if it's a display name\n\tinternalStrategy := selectedStrategy\n\tif mapped, ok := strategyDisplayToInternal[selectedStrategy]; ok {\n\t\tinternalStrategy = mapped\n\t}\n\n\t// Validate the strategy exists\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", selectedStrategy)\n\t}\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\t// Determine which settings file to write to\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, showNotification := determineSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\n\tif showNotification {\n\t\tfmt.Fprintln(w, \"Info: Project settings exist. Saving to settings.local.json instead.\")\n\t\tfmt.Fprintln(w, \"  Use --project to update the project settings file.\")\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tdisplayName := selectedStrategy\n\tif dn, ok := strategyInternalToDisplay[internalStrategy]; ok {\n\t\tdisplayName = dn\n\t}\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", displayName)\n\n\treturn nil\n}\n\n// runEnableInteractive runs the interactive enable flow.\nfunc runEnableInteractive(w io.Writer, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Use the default strategy (manual-commit)\n\tinternalStrategy := strategy.DefaultStrategyName\n\tfmt.Fprintf(w, \"Using %s strategy (use --strategy to change)\\n\\n\", strategyInternalToDisplay[internalStrategy])\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Ask about telemetry consent (only if not already asked)\n\tif err := promptTelemetryConsent(settings, telemetry); err != nil {\n\t\treturn fmt.Errorf(\"telemetry consent: %w\", err)\n\t}\n\n\t// Determine which settings file to write to (interactive prompt if settings.json exists)\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, err := promptSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", strategyInternalToDisplay[internalStrategy])\n\n\treturn nil\n}\n\n// runEnable is a simple enable that just sets the enabled flag (for programmatic use).\nfunc runEnable(w io.Writer) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = true\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now enabled.\")\n\treturn nil\n}\n\nfunc runDisable(w io.Writer, useProjectSettings bool) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = false\n\n\t// If --project flag is specified, always write to project settings\n\tif useProjectSettings {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t} else {\n\t\t// Always write to local settings file (create if doesn't exist)\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now disabled.\")\n\treturn nil\n}\n\n// DisabledMessage is the message shown when Entire is disabled\nconst DisabledMessage = \"Entire is disabled. Run `entire enable` to re-enable.\"\n\n// checkDisabledGuard checks if Entire is disabled and prints a message if so.\n// Returns true if the caller should exit (i.e., Entire is disabled).\n// On error reading settings, defaults to enabled (returns false).\nfunc checkDisabledGuard(w io.Writer) bool {\n\tenabled, err := IsEnabled()\n\tif err != nil {\n\t\t// Default to enabled on error\n\t\treturn false\n\t}\n\tif !enabled {\n\t\tfmt.Fprintln(w, DisabledMessage)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// setupClaudeCodeHook sets up Claude Code hooks.\n// This is a convenience wrapper that uses the agent package.\n// Returns the number of hooks installed (0 if already installed).\nfunc setupClaudeCodeHook(localDev, forceHooks bool) (int, error) {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get claude-code agent: %w\", err)\n\t}\n\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn 0, errors.New(\"claude-code agent does not support hooks\")\n\t}\n\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to install claude-code hooks: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// setupAgentHooksNonInteractive sets up hooks for a specific agent non-interactively.\n// If strategyName is provided, it sets the strategy; otherwise uses default.\nfunc setupAgentHooksNonInteractive(agentName agent.AgentName, strategyName string, localDev, forceHooks, skipPushSessions, telemetry bool) error {\n\tag, err := agent.Get(agentName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown agent: %s\", agentName)\n\t}\n\n\t// Check if agent supports hooks\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn fmt.Errorf(\"agent %s does not support hooks\", agentName)\n\t}\n\n\t// Install hooks\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install hooks for %s: %w\", agentName, err)\n\t}\n\n\tif count == 0 {\n\t\tmsg := fmt.Sprintf(\"Hooks for %s already installed\", ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t} else {\n\t\tmsg := fmt.Sprintf(\"Installed %d hooks for %s\", count, ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\n\t// Update settings to store the strategy\n\tsettings, _ := LoadEntireSettings() //nolint:errcheck // settings defaults are fine\n\tsettings.Enabled = true\n\tif localDev {\n\t\tsettings.LocalDev = localDev\n\t}\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Set strategy if provided\n\tif strategyName != \"\" {\n\t\t// Map display name to internal name if needed\n\t\tinternalStrategy := strategyName\n\t\tif mapped, ok := strategyDisplayToInternal[strategyName]; ok {\n\t\t\tinternalStrategy = mapped\n\t\t}\n\t\t// Validate the strategy exists\n\t\tif _, err := strategy.Get(internalStrategy); err != nil {\n\t\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", strategyName)\n\t\t}\n\t\tsettings.Strategy = internalStrategy\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tif _, err := strategy.InstallGitHook(true); err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\n\t// Let the strategy handle its own setup requirements (creates entire/sessions branch, etc.)\n\tstrat, err := strategy.Get(settings.Strategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// validateSetupFlags checks that --local and --project flags are not both specified.\nfunc validateSetupFlags(useLocal, useProject bool) error {\n\tif useLocal && useProject {\n\t\treturn errors.New(\"cannot specify both --project and --local\")\n\t}\n\treturn nil\n}\n\n// determineSettingsTarget decides whether to write to settings.local.json based on:\n// - Whether settings.json already exists\n// - The --local and --project flags\n// Returns (useLocal, showNotification).\nfunc determineSettingsTarget(entireDir string, useLocal, useProject bool) (bool, bool) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, false\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, false\n\t}\n\n\t// No flags specified - check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); err == nil {\n\t\t// Settings file exists - auto-redirect to local with notification\n\t\treturn true, true\n\t}\n\n\t// Settings file doesn't exist - create it\n\treturn false, false\n}\n\n// Settings target options for interactive prompt\nconst (\n\tsettingsTargetProject = \"project\"\n\tsettingsTargetLocal   = \"local\"\n)\n\n// promptSettingsTarget interactively asks the user where to save settings\n// when settings.json already exists and no flags were provided.\n// Returns (useLocal, error).\nfunc promptSettingsTarget(entireDir string, useLocal, useProject bool) (bool, error) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, nil\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, nil\n\t}\n\n\t// Check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); os.IsNotExist(err) {\n\t\t// Settings file doesn't exist - create it (no prompt needed)\n\t\treturn false, nil\n\t}\n\n\t// Settings file exists - prompt user\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(\"Project settings already exist. Where should settings be saved?\").\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Update project settings (settings.json)\", settingsTargetProject),\n\t\t\t\t\thuh.NewOption(\"Use local settings (settings.local.json, gitignored)\", settingsTargetLocal),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false, fmt.Errorf(\"selection cancelled: %w\", err)\n\t}\n\n\treturn selected == settingsTargetLocal, nil\n}\n\n// setupEntireDirectory creates the .entire directory and gitignore.\n// Returns true if the directory was created, false if it already existed.\nfunc setupEntireDirectory() (bool, error) {\n\t// Get absolute path for the .entire directory\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\n\t// Check if directory already exists\n\tcreated := false\n\tif _, err := os.Stat(entireDirAbs); os.IsNotExist(err) {\n\t\tcreated = true\n\t}\n\n\t// Create .entire directory\n\t//nolint:gosec // G301: Project directory needs standard permissions for git\n\tif err := os.MkdirAll(entireDirAbs, 0o755); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to create .entire directory: %w\", err)\n\t}\n\n\t// Create/update .gitignore with all required entries\n\tif err := strategy.EnsureEntireGitignore(); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to setup .gitignore: %w\", err)\n\t}\n\n\treturn created, nil\n}\n\n// setupGitHook installs the prepare-commit-msg hook for context trailers.\nfunc setupGitHook() error {\n\t// Use shared implementation from strategy package\n\t// The localDev setting is read from settings.json\n\t_, err := strategy.InstallGitHook(false) // not silent - show output during setup\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hook: %w\", err)\n\t}\n\treturn nil\n}\n\n// newSetupGitHookCmd creates the standalone git-hook setup command\nfunc newSetupGitHookCmd() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:    \"git-hook\",\n\t\tShort:  \"Install git hook for session context trailers\",\n\t\tHidden: true, // Hidden as it's mainly for testing\n\t\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\treturn setupGitHook()\n\t\t},\n\t}\n\n\treturn cmd\n}\n\nfunc newCurlBashPostInstallCmd() *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:    \"curl-bash-post-install\",\n\t\tShort:  \"Post-install tasks for curl|bash installer\",\n\t\tHidden: true,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tw := cmd.OutOrStdout()\n\t\t\tif err := promptShellCompletion(w); err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Note: Shell completion setup skipped: %v\\n\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n}\n\n// Shell completion stanza management.\n// The stanza is a versioned, delimited block written to ~/.zshrc or ~/.bashrc:\n//\n//\t# Entire CLI completions (v1) {{{\n//\tautoload -Uz compinit && compinit && source <(entire completion zsh)\n//\t# }}}\nconst (\n\tshellCompletionStanzaVersion = 1\n\tshellCompletionOpenFormat    = \"# Entire CLI completions (v%d) {{{\"\n\tshellCompletionClose         = \"# }}}\"\n\tshellCompletionLegacyComment = \"# Entire CLI shell completion\" // old format for migration\n)\n\ntype stanzaStatus int\n\nconst (\n\tstanzaNotFound stanzaStatus = iota\n\tstanzaCurrent\n\tstanzaOutdated\n\tstanzaLegacy\n)\n\nvar (\n\terrStanzaCorrupted = errors.New(\"shell completion block is corrupted (missing closing marker)\")\n\terrMultipleStanzas = errors.New(\"found multiple shell completion blocks\")\n)\n\n// findStanzaVersion scans content for the opening stanza marker and returns\n// the version number. Returns 0 if no stanza is found.\nfunc findStanzaVersion(content string) int {\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\treturn version\n\t\t}\n\t}\n\treturn 0\n}\n\n// checkStanzaStatus determines the status of the shell completion stanza in content.\nfunc checkStanzaStatus(content string, currentVersion int) stanzaStatus {\n\tversion := findStanzaVersion(content)\n\tif version > 0 {\n\t\tif version >= currentVersion {\n\t\t\treturn stanzaCurrent\n\t\t}\n\t\treturn stanzaOutdated\n\t}\n\tif strings.Contains(content, shellCompletionLegacyComment) {\n\t\treturn stanzaLegacy\n\t}\n\treturn stanzaNotFound\n}\n\n// buildStanza constructs the full stanza block for the given version and completion line.\nfunc buildStanza(version int, completionLine string) string {\n\treturn fmt.Sprintf(shellCompletionOpenFormat, version) + \"\\n\" + completionLine + \"\\n\" + shellCompletionClose\n}\n\n// countStanzaOpeners counts how many opening stanza markers exist in content.\nfunc countStanzaOpeners(content string) int {\n\tcount := 0\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n// replaceStanza finds the open+close markers in content and replaces the block\n// with a new stanza. Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc replaceStanza(content string, version int, completionLine string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tnewStanza := buildStanza(version, completionLine)\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\tresult = append(result, newStanza)\n\tresult = append(result, lines[closeIdx+1:]...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeStanza finds and removes the stanza block from content.\n// Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc removeStanza(content string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\t// Skip blank line immediately after stanza if present\n\ttail := lines[closeIdx+1:]\n\tif len(tail) > 0 && strings.TrimSpace(tail[0]) == \"\" {\n\t\ttail = tail[1:]\n\t}\n\tresult = append(result, tail...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeLegacyCompletion removes the old-format comment and its following\n// completion line from content. Returns the modified content and whether\n// anything was removed.\nfunc removeLegacyCompletion(content, completionLine string) (string, bool) {\n\tlines := strings.Split(content, \"\\n\")\n\tvar result []string\n\tremoved := false\n\tfor i := 0; i < len(lines); i++ {\n\t\tif strings.TrimSpace(lines[i]) == shellCompletionLegacyComment {\n\t\t\t// Remove the comment line and the next line if it matches the completion line\n\t\t\tif i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == completionLine {\n\t\t\t\ti++ // skip next line too\n\t\t\t}\n\t\t\tremoved = true\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, lines[i])\n\t}\n\tif !removed {\n\t\treturn content, false\n\t}\n\treturn strings.Join(result, \"\\n\"), true\n}\n\n// errUnsupportedShell is returned when the user's shell is not supported for completion.\nvar errUnsupportedShell = errors.New(\"unsupported shell\")\n\n// shellCompletionTarget returns the rc file path and completion lines for the\n// user's current shell.\nfunc shellCompletionTarget() (shellName, rcFile, completionLine string, err error) {\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", fmt.Errorf(\"cannot determine home directory: %w\", err)\n\t}\n\n\tshell := os.Getenv(\"SHELL\")\n\tswitch {\n\tcase strings.Contains(shell, \"zsh\"):\n\t\treturn \"Zsh\",\n\t\t\tfilepath.Join(home, \".zshrc\"),\n\t\t\t\"source <(entire completion zsh)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"bash\"):\n\t\treturn \"Bash\",\n\t\t\tfilepath.Join(home, \".bashrc\"),\n\t\t\t\"source <(entire completion bash)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"fish\"):\n\t\treturn \"Fish\",\n\t\t\tfilepath.Join(home, \".config\", \"fish\", \"config.fish\"),\n\t\t\t\"entire completion fish | source\",\n\t\t\tnil\n\tdefault:\n\t\treturn \"\", \"\", \"\", errUnsupportedShell\n\t}\n}\n\n// promptShellCompletion offers to add shell completion to the user's rc file.\n// Handles versioned stanza detection, updates, and legacy migration.\nfunc promptShellCompletion(w io.Writer) error {\n\tshellName, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\tif errors.Is(err, errUnsupportedShell) {\n\t\t\tfmt.Fprintf(w, \"Note: Shell completion not available for your shell. Supported: zsh, bash, fish.\\n\")\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"shell completion: %w\", err)\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\tstatus := checkStanzaStatus(string(content), shellCompletionStanzaVersion)\n\tswitch status {\n\tcase stanzaCurrent:\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil\n\n\tcase stanzaOutdated:\n\t\tif !promptYesNo(\"Shell completion is outdated. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t// Re-read in case file changed\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, replaceErr := replaceStanza(string(content), shellCompletionStanzaVersion, completionLine)\n\t\tif replaceErr != nil {\n\t\t\tfmt.Fprintf(w, \"Warning: %v in %s. Please fix manually.\\n\", replaceErr, rcFile)\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaLegacy:\n\t\tif !promptYesNo(\"Shell completion uses old format. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, _ := removeLegacyCompletion(string(content), completionLine)\n\t\tupdated = updated + \"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\"\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaNotFound:\n\t\tif !promptYesNo(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)) {\n\t\t\treturn nil\n\t\t}\n\t\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t}\n\n\treturn nil\n}\n\n// promptYesNo shows a yes/no selection prompt and returns whether the user chose yes.\nfunc promptYesNo(title string) bool {\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(title).\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Yes\", \"yes\"),\n\t\t\t\t\thuh.NewOption(\"No\", \"no\"),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n<<<<<<< HEAD\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Restart your shell to activate\")\n\n\treturn nil\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n\n\tif selected != \"yes\" {\n\t\treturn nil\n\t}\n\n\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t}\n\n\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\n\treturn nil\n=======\n\treturn selected == \"yes\"\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\n}\n\n<<<<<<< HEAD\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), \"entire completion\")\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string, completionLine string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), completionLine)\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n=======\n// appendShellCompletion adds the completion stanza to the rc file.\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\nfunc appendShellCompletion(rcFile, completionLine string) error {\n\tif err := os.MkdirAll(filepath.Dir(rcFile), 0o755); err != nil {\n\t\treturn fmt.Errorf(\"creating directory: %w\", err)\n\t}\n\t//nolint:gosec // G302: Shell rc files need 0644 for user readability\n\tf, err := os.OpenFile(rcFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(\"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing completion: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeShellCompletion removes the shell completion stanza (or legacy format)\n// from the user's rc file. Used during uninstall.\nfunc removeShellCompletion() error {\n\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\ttext := string(content)\n\tupdated, removeErr := removeStanza(text)\n\tif removeErr != nil {\n\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n\t}\n\n\tif updated != text {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Fall back to legacy format removal\n\tupdated, removed := removeLegacyCompletion(text, completionLine)\n\tif removed {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// promptTelemetryConsent asks the user if they want to enable telemetry.\n// It modifies settings.Telemetry based on the user's choice or flags.\n// The caller is responsible for saving settings.\nfunc promptTelemetryConsent(settings *EntireSettings, telemetryFlag bool) error {\n\t// Handle --telemetry=false flag first (always overrides existing setting)\n\tif !telemetryFlag {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\t// Skip if already asked\n\tif settings.Telemetry != nil {\n\t\treturn nil\n\t}\n\n\t// Skip if env var disables telemetry (record as disabled)\n\tif os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\tconsent := true // Default to Yes\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewConfirm().\n\t\t\t\tTitle(\"Help improve Entire CLI?\").\n\t\t\t\tDescription(\"Share anonymous usage data. No code or personal info collected.\").\n\t\t\t\tAffirmative(\"Yes\").\n\t\t\t\tNegative(\"No\").\n\t\t\t\tValue(&consent),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn fmt.Errorf(\"telemetry prompt: %w\", err)\n\t}\n\n\tsettings.Telemetry = &consent\n\treturn nil\n}\n\n// runUninstall completely removes Entire from the repository.\nfunc runUninstall(w, errW io.Writer, force bool) error {\n\t// Check if we're in a git repository\n\tif _, err := paths.RepoRoot(); err != nil {\n\t\tfmt.Fprintln(errW, \"Not a git repository. Nothing to uninstall.\")\n\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t}\n\n\t// Gather counts for display\n\tsessionStateCount := countSessionStates()\n\tshadowBranchCount := countShadowBranches()\n\tgitHooksInstalled := strategy.IsGitHookInstalled()\n\tclaudeHooksInstalled := checkClaudeCodeHooksInstalled()\n\tgeminiHooksInstalled := checkGeminiCLIHooksInstalled()\n\tentireDirExists := checkEntireDirExists()\n\n\t// Check if there's anything to uninstall\n\tif !entireDirExists && !gitHooksInstalled && sessionStateCount == 0 &&\n\t\tshadowBranchCount == 0 && !claudeHooksInstalled && !geminiHooksInstalled {\n\t\tfmt.Fprintln(w, \"Entire is not installed in this repository.\")\n\t\treturn nil\n\t}\n\n\t// Show confirmation prompt unless --force\n\tif !force {\n\t\tfmt.Fprintln(w, \"\\nThis will completely remove Entire from this repository:\")\n\t\tif entireDirExists {\n\t\t\tfmt.Fprintln(w, \"  - .entire/ directory\")\n\t\t}\n\t\tif gitHooksInstalled {\n\t\t\tfmt.Fprintln(w, \"  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\")\n\t\t}\n\t\tif sessionStateCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Session state files (%d)\\n\", sessionStateCount)\n\t\t}\n\t\tif shadowBranchCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Shadow branches (%d)\\n\", shadowBranchCount)\n\t\t}\n\t\tswitch {\n\t\tcase claudeHooksInstalled && geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code, Gemini CLI)\")\n\t\tcase claudeHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code)\")\n\t\tcase geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Gemini CLI)\")\n\t\t}\n\t\tfmt.Fprintln(w)\n\n\t\tvar confirmed bool\n\t\tform := NewAccessibleForm(\n\t\t\thuh.NewGroup(\n\t\t\t\thuh.NewConfirm().\n\t\t\t\t\tTitle(\"Are you sure you want to uninstall Entire?\").\n\t\t\t\t\tAffirmative(\"Yes, uninstall\").\n\t\t\t\t\tNegative(\"Cancel\").\n\t\t\t\t\tValue(&confirmed),\n\t\t\t),\n\t\t)\n\n\t\tif err := form.Run(); err != nil {\n\t\t\treturn fmt.Errorf(\"confirmation cancelled: %w\", err)\n\t\t}\n\n\t\tif !confirmed {\n\t\t\tfmt.Fprintln(w, \"Uninstall cancelled.\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"\\nUninstalling Entire CLI...\")\n\n\t// 0. Remove shell completion from rc file\n\tif err := removeShellCompletion(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shell completion: %v\\n\", err)\n\t} else {\n\t\tfmt.Fprintln(w, \"  Removed shell completion\")\n\t}\n\n\t// 1. Remove agent hooks (lowest risk)\n\tif err := removeAgentHooks(w); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove agent hooks: %v\\n\", err)\n\t}\n\n\t// 2. Remove git hooks\n\tremoved, err := strategy.RemoveGitHook()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove git hooks: %v\\n\", err)\n\t} else if removed > 0 {\n\t\tfmt.Fprintf(w, \"  Removed git hooks (%d)\\n\", removed)\n\t}\n\n\t// 3. Remove session state files\n\tstatesRemoved, err := removeAllSessionStates()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove session states: %v\\n\", err)\n\t} else if statesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed session states (%d)\\n\", statesRemoved)\n\t}\n\n\t// 4. Remove .entire/ directory\n\tif err := removeEntireDirectory(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove .entire directory: %v\\n\", err)\n\t} else if entireDirExists {\n\t\tfmt.Fprintln(w, \"  Removed .entire directory\")\n\t}\n\n\t// 5. Remove shadow branches\n\tbranchesRemoved, err := removeAllShadowBranches()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shadow branches: %v\\n\", err)\n\t} else if branchesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed %d shadow branches\\n\", branchesRemoved)\n\t}\n\n\tfmt.Fprintln(w, \"\\nEntire CLI uninstalled successfully.\")\n\treturn nil\n}\n\n// countSessionStates returns the number of active session state files.\nfunc countSessionStates() int {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0\n\t}\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(states)\n}\n\n// countShadowBranches returns the number of shadow branches.\nfunc countShadowBranches() int {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(branches)\n}\n\n// checkClaudeCodeHooksInstalled checks if Claude Code hooks are installed.\nfunc checkClaudeCodeHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkGeminiCLIHooksInstalled checks if Gemini CLI hooks are installed.\nfunc checkGeminiCLIHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameGemini)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkEntireDirExists checks if the .entire directory exists.\nfunc checkEntireDirExists() bool {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\t_, err = os.Stat(entireDirAbs)\n\treturn err == nil\n}\n\n// removeAgentHooks removes hooks from all agents that support hooks.\nfunc removeAgentHooks(w io.Writer) error {\n\tvar errs []error\n\n\t// Remove Claude Code hooks\n\tclaudeAgent, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err == nil {\n\t\tif hookAgent, ok := claudeAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Claude Code hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove Gemini CLI hooks\n\tgeminiAgent, err := agent.Get(agent.AgentNameGemini)\n\tif err == nil {\n\t\tif hookAgent, ok := geminiAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Gemini CLI hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errors.Join(errs...)\n}\n\n// removeAllSessionStates removes all session state files and the directory.\nfunc removeAllSessionStates() (int, error) {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to create state store: %w\", err)\n\t}\n\n\t// Count states before removing\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list session states: %w\", err)\n\t}\n\tcount := len(states)\n\n\t// Remove the entire directory\n\tif err := store.RemoveAll(); err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to remove session states: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// removeEntireDirectory removes the .entire directory.\nfunc removeEntireDirectory() error {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\tif err := os.RemoveAll(entireDirAbs); err != nil {\n\t\treturn fmt.Errorf(\"failed to remove .entire directory: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeAllShadowBranches removes all shadow branches.\nfunc removeAllShadowBranches() (int, error) {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list shadow branches: %w\", err)\n\t}\n\tif len(branches) == 0 {\n\t\treturn 0, nil\n\t}\n\tdeleted, _, err := strategy.DeleteShadowBranches(branches)\n\treturn len(deleted), err\n}\n","structuredPatch":[{"oldStart":980,"oldLines":37,"newStart":980,"newLines":7,"lines":["   if err := form.Run(); err != nil {","     return false // User cancelled","   }","-<<<<<<< HEAD","-","-  if selected != \"yes\" {","-    return nil","-  }","-","-  if err := appendShellCompletion(rcFile, completionLine); err != nil {","-    return fmt.Errorf(\"failed to update %s: %w\", rcFile, err)","-  }","-","-  fmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)","-  fmt.Fprintln(w, \"  Restart your shell to activate\")","-","-  return nil","-||||||| parent of b6ff09d (Add versioned stanza management for shell completion)","-","-  if selected != \"yes\" {","-    return nil","-  }","-","-  if err := appendShellCompletion(rcFile, completionLine); err != nil {","-    return fmt.Errorf(\"failed to update %s: %w\", rcFile, err)","-  }","-","-  fmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)","-  fmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")","-","-  return nil","-=======","   return selected == \"yes\"","->>>>>>> b6ff09d (Add versioned stanza management for shell completion)"," }"," "," <<<<<<< HEAD"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"57780539-43a6-4be8-84a8-1e57ee11f0cb"}
{"parentUuid":"4d6d1993-cf8b-42a3-abfc-8ffca272ef53","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01MexMj7UiV2ekYDhZyjGZ3Y","type":"message","role":"assistant","content":[{"type":"text","text":"Now the last conflict — remove `isCompletionConfigured` (replaced by stanza checking) and use the incoming comment:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":678,"cache_read_input_tokens":50392,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":678},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxbxRfevDQS6ryZ1anw","type":"assistant","uuid":"24eee1b3-149c-4aaa-a0bd-3ba076937daf","timestamp":"2026-02-09T05:41:04.387Z"}
{"parentUuid":"24eee1b3-149c-4aaa-a0bd-3ba076937daf","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01MexMj7UiV2ekYDhZyjGZ3Y","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VehQqkBcuvmTjTpiEJLNxj","name":"Edit","input":{"replace_all":false,"file_path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","old_string":"<<<<<<< HEAD\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), \"entire completion\")\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string, completionLine string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), completionLine)\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n=======\n// appendShellCompletion adds the completion stanza to the rc file.\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)","new_string":"// appendShellCompletion adds the completion stanza to the rc file."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":678,"cache_read_input_tokens":50392,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":678},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxbxRfevDQS6ryZ1anw","type":"assistant","uuid":"f119639b-df6f-42b3-95e8-24c23f08221d","timestamp":"2026-02-09T05:41:08.900Z"}
{"parentUuid":"f119639b-df6f-42b3-95e8-24c23f08221d","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01VehQqkBcuvmTjTpiEJLNxj","toolUseID":"toolu_01VehQqkBcuvmTjTpiEJLNxj","timestamp":"2026-02-09T05:41:24.374Z","uuid":"545516d2-0dac-436f-900b-810168587743"}
{"parentUuid":"f119639b-df6f-42b3-95e8-24c23f08221d","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VehQqkBcuvmTjTpiEJLNxj","type":"tool_result","content":"The file /Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go has been updated successfully."}]},"uuid":"0ed94c82-80ed-4fe6-8e59-078593d24852","timestamp":"2026-02-09T05:41:24.373Z","toolUseResult":{"filePath":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","oldString":"<<<<<<< HEAD\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), \"entire completion\")\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string, completionLine string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), completionLine)\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n=======\n// appendShellCompletion adds the completion stanza to the rc file.\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)","newString":"// appendShellCompletion adds the completion stanza to the rc file.","originalFile":"package cli\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/entireio/cli/cmd/entire/cli/agent\"\n\t\"github.com/entireio/cli/cmd/entire/cli/paths\"\n\t\"github.com/entireio/cli/cmd/entire/cli/session\"\n\t\"github.com/entireio/cli/cmd/entire/cli/strategy\"\n\n\t\"github.com/charmbracelet/huh\"\n\t\"github.com/spf13/cobra\"\n)\n\n// Strategy display names for user-friendly selection\nconst (\n\tstrategyDisplayManualCommit = \"manual-commit\"\n\tstrategyDisplayAutoCommit   = \"auto-commit\"\n)\n\n// strategyDisplayToInternal maps user-friendly names to internal strategy names\nvar strategyDisplayToInternal = map[string]string{\n\tstrategyDisplayManualCommit: strategy.StrategyNameManualCommit,\n\tstrategyDisplayAutoCommit:   strategy.StrategyNameAutoCommit,\n}\n\n// strategyInternalToDisplay maps internal strategy names to user-friendly names\nvar strategyInternalToDisplay = map[string]string{\n\tstrategy.StrategyNameManualCommit: strategyDisplayManualCommit,\n\tstrategy.StrategyNameAutoCommit:   strategyDisplayAutoCommit,\n}\n\nfunc newEnableCmd() *cobra.Command {\n\tvar localDev bool\n\tvar ignoreUntracked bool\n\tvar useLocalSettings bool\n\tvar useProjectSettings bool\n\tvar agentName string\n\tvar strategyFlag string\n\tvar forceHooks bool\n\tvar skipPushSessions bool\n\tvar telemetry bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"enable\",\n\t\tShort: \"Enable Entire\",\n\t\tLong: `Enable Entire with session tracking for your AI agent workflows.\n\nUses the manual-commit strategy by default. To use a different strategy:\n\n  entire enable --strategy auto-commit\n\nStrategies: manual-commit (default), auto-commit`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\t// Check if we're in a git repository first - this is a prerequisite error,\n\t\t\t// not a usage error, so we silence Cobra's output and use SilentError\n\t\t\t// to prevent duplicate error output in main.go\n\t\t\tif _, err := paths.RepoRoot(); err != nil {\n\t\t\t\tcmd.SilenceUsage = true\n\t\t\t\tcmd.SilenceErrors = true\n\t\t\t\tfmt.Fprintln(cmd.ErrOrStderr(), \"Not a git repository. Please run 'entire enable' from within a git repository.\")\n\t\t\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t\t\t}\n\n\t\t\tif err := validateSetupFlags(useLocalSettings, useProjectSettings); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Non-interactive mode if --agent flag is provided\n\t\t\tif agentName != \"\" {\n\t\t\t\treturn setupAgentHooksNonInteractive(agent.AgentName(agentName), strategyFlag, localDev, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\t// If strategy is specified via flag, skip interactive selection\n\t\t\tif strategyFlag != \"\" {\n\t\t\t\treturn runEnableWithStrategy(cmd.OutOrStdout(), strategyFlag, localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\treturn runEnableInteractive(cmd.OutOrStdout(), localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&localDev, \"local-dev\", false, \"Use go run instead of entire binary for hooks\")\n\tcmd.Flags().MarkHidden(\"local-dev\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&ignoreUntracked, \"ignore-untracked\", false, \"Commit all new files without tracking pre-existing untracked files\")\n\tcmd.Flags().MarkHidden(\"ignore-untracked\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&useLocalSettings, \"local\", false, \"Write settings to settings.local.json instead of settings.json\")\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Write settings to settings.json even if it already exists\")\n\tcmd.Flags().StringVar(&agentName, \"agent\", \"\", \"Agent to setup hooks for (e.g., claude-code). Enables non-interactive mode.\")\n\tcmd.Flags().StringVar(&strategyFlag, \"strategy\", \"\", \"Strategy to use (manual-commit or auto-commit)\")\n\tcmd.Flags().BoolVarP(&forceHooks, \"force\", \"f\", false, \"Force reinstall hooks (removes existing Entire hooks first)\")\n\tcmd.Flags().BoolVar(&skipPushSessions, \"skip-push-sessions\", false, \"Disable automatic pushing of session logs on git push\")\n\tcmd.Flags().BoolVar(&telemetry, \"telemetry\", true, \"Enable anonymous usage analytics\")\n\t//nolint:errcheck,gosec // completion is optional, flag is defined above\n\tcmd.RegisterFlagCompletionFunc(\"strategy\", func(_ *cobra.Command, _ []string, _ string) ([]string, cobra.ShellCompDirective) {\n\t\treturn []string{strategyDisplayManualCommit, strategyDisplayAutoCommit}, cobra.ShellCompDirectiveNoFileComp\n\t})\n\n\t// Add subcommands for automation/testing\n\tcmd.AddCommand(newSetupGitHookCmd())\n\n\treturn cmd\n}\n\nfunc newDisableCmd() *cobra.Command {\n\tvar useProjectSettings bool\n\tvar uninstall bool\n\tvar force bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"disable\",\n\t\tShort: \"Disable Entire\",\n\t\tLong: `Disable Entire temporarily. Hooks will exit silently and commands will show a disabled message.\n\nUse --uninstall to completely remove Entire from this repository, including:\n  - .entire/ directory (settings, logs, metadata)\n  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\n  - Session state files (.git/entire-sessions/)\n  - Shadow branches (entire/<hash>)\n  - Agent hooks (Claude Code, Gemini CLI)`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tif uninstall {\n\t\t\t\treturn runUninstall(cmd.OutOrStdout(), cmd.ErrOrStderr(), force)\n\t\t\t}\n\t\t\treturn runDisable(cmd.OutOrStdout(), useProjectSettings)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Update settings.json instead of settings.local.json\")\n\tcmd.Flags().BoolVar(&uninstall, \"uninstall\", false, \"Completely remove Entire from this repository\")\n\tcmd.Flags().BoolVar(&force, \"force\", false, \"Skip confirmation prompt (use with --uninstall)\")\n\n\treturn cmd\n}\n\n// runEnableWithStrategy enables Entire with a specified strategy (non-interactive).\n// The selectedStrategy can be either a display name (manual-commit, auto-commit)\n// or an internal name (manual-commit, auto-commit).\nfunc runEnableWithStrategy(w io.Writer, selectedStrategy string, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Map the strategy to internal name if it's a display name\n\tinternalStrategy := selectedStrategy\n\tif mapped, ok := strategyDisplayToInternal[selectedStrategy]; ok {\n\t\tinternalStrategy = mapped\n\t}\n\n\t// Validate the strategy exists\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", selectedStrategy)\n\t}\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\t// Determine which settings file to write to\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, showNotification := determineSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\n\tif showNotification {\n\t\tfmt.Fprintln(w, \"Info: Project settings exist. Saving to settings.local.json instead.\")\n\t\tfmt.Fprintln(w, \"  Use --project to update the project settings file.\")\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tdisplayName := selectedStrategy\n\tif dn, ok := strategyInternalToDisplay[internalStrategy]; ok {\n\t\tdisplayName = dn\n\t}\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", displayName)\n\n\treturn nil\n}\n\n// runEnableInteractive runs the interactive enable flow.\nfunc runEnableInteractive(w io.Writer, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Use the default strategy (manual-commit)\n\tinternalStrategy := strategy.DefaultStrategyName\n\tfmt.Fprintf(w, \"Using %s strategy (use --strategy to change)\\n\\n\", strategyInternalToDisplay[internalStrategy])\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Ask about telemetry consent (only if not already asked)\n\tif err := promptTelemetryConsent(settings, telemetry); err != nil {\n\t\treturn fmt.Errorf(\"telemetry consent: %w\", err)\n\t}\n\n\t// Determine which settings file to write to (interactive prompt if settings.json exists)\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, err := promptSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", strategyInternalToDisplay[internalStrategy])\n\n\treturn nil\n}\n\n// runEnable is a simple enable that just sets the enabled flag (for programmatic use).\nfunc runEnable(w io.Writer) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = true\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now enabled.\")\n\treturn nil\n}\n\nfunc runDisable(w io.Writer, useProjectSettings bool) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = false\n\n\t// If --project flag is specified, always write to project settings\n\tif useProjectSettings {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t} else {\n\t\t// Always write to local settings file (create if doesn't exist)\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now disabled.\")\n\treturn nil\n}\n\n// DisabledMessage is the message shown when Entire is disabled\nconst DisabledMessage = \"Entire is disabled. Run `entire enable` to re-enable.\"\n\n// checkDisabledGuard checks if Entire is disabled and prints a message if so.\n// Returns true if the caller should exit (i.e., Entire is disabled).\n// On error reading settings, defaults to enabled (returns false).\nfunc checkDisabledGuard(w io.Writer) bool {\n\tenabled, err := IsEnabled()\n\tif err != nil {\n\t\t// Default to enabled on error\n\t\treturn false\n\t}\n\tif !enabled {\n\t\tfmt.Fprintln(w, DisabledMessage)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// setupClaudeCodeHook sets up Claude Code hooks.\n// This is a convenience wrapper that uses the agent package.\n// Returns the number of hooks installed (0 if already installed).\nfunc setupClaudeCodeHook(localDev, forceHooks bool) (int, error) {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get claude-code agent: %w\", err)\n\t}\n\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn 0, errors.New(\"claude-code agent does not support hooks\")\n\t}\n\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to install claude-code hooks: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// setupAgentHooksNonInteractive sets up hooks for a specific agent non-interactively.\n// If strategyName is provided, it sets the strategy; otherwise uses default.\nfunc setupAgentHooksNonInteractive(agentName agent.AgentName, strategyName string, localDev, forceHooks, skipPushSessions, telemetry bool) error {\n\tag, err := agent.Get(agentName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown agent: %s\", agentName)\n\t}\n\n\t// Check if agent supports hooks\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn fmt.Errorf(\"agent %s does not support hooks\", agentName)\n\t}\n\n\t// Install hooks\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install hooks for %s: %w\", agentName, err)\n\t}\n\n\tif count == 0 {\n\t\tmsg := fmt.Sprintf(\"Hooks for %s already installed\", ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t} else {\n\t\tmsg := fmt.Sprintf(\"Installed %d hooks for %s\", count, ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\n\t// Update settings to store the strategy\n\tsettings, _ := LoadEntireSettings() //nolint:errcheck // settings defaults are fine\n\tsettings.Enabled = true\n\tif localDev {\n\t\tsettings.LocalDev = localDev\n\t}\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Set strategy if provided\n\tif strategyName != \"\" {\n\t\t// Map display name to internal name if needed\n\t\tinternalStrategy := strategyName\n\t\tif mapped, ok := strategyDisplayToInternal[strategyName]; ok {\n\t\t\tinternalStrategy = mapped\n\t\t}\n\t\t// Validate the strategy exists\n\t\tif _, err := strategy.Get(internalStrategy); err != nil {\n\t\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", strategyName)\n\t\t}\n\t\tsettings.Strategy = internalStrategy\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tif _, err := strategy.InstallGitHook(true); err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\n\t// Let the strategy handle its own setup requirements (creates entire/sessions branch, etc.)\n\tstrat, err := strategy.Get(settings.Strategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// validateSetupFlags checks that --local and --project flags are not both specified.\nfunc validateSetupFlags(useLocal, useProject bool) error {\n\tif useLocal && useProject {\n\t\treturn errors.New(\"cannot specify both --project and --local\")\n\t}\n\treturn nil\n}\n\n// determineSettingsTarget decides whether to write to settings.local.json based on:\n// - Whether settings.json already exists\n// - The --local and --project flags\n// Returns (useLocal, showNotification).\nfunc determineSettingsTarget(entireDir string, useLocal, useProject bool) (bool, bool) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, false\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, false\n\t}\n\n\t// No flags specified - check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); err == nil {\n\t\t// Settings file exists - auto-redirect to local with notification\n\t\treturn true, true\n\t}\n\n\t// Settings file doesn't exist - create it\n\treturn false, false\n}\n\n// Settings target options for interactive prompt\nconst (\n\tsettingsTargetProject = \"project\"\n\tsettingsTargetLocal   = \"local\"\n)\n\n// promptSettingsTarget interactively asks the user where to save settings\n// when settings.json already exists and no flags were provided.\n// Returns (useLocal, error).\nfunc promptSettingsTarget(entireDir string, useLocal, useProject bool) (bool, error) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, nil\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, nil\n\t}\n\n\t// Check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); os.IsNotExist(err) {\n\t\t// Settings file doesn't exist - create it (no prompt needed)\n\t\treturn false, nil\n\t}\n\n\t// Settings file exists - prompt user\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(\"Project settings already exist. Where should settings be saved?\").\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Update project settings (settings.json)\", settingsTargetProject),\n\t\t\t\t\thuh.NewOption(\"Use local settings (settings.local.json, gitignored)\", settingsTargetLocal),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false, fmt.Errorf(\"selection cancelled: %w\", err)\n\t}\n\n\treturn selected == settingsTargetLocal, nil\n}\n\n// setupEntireDirectory creates the .entire directory and gitignore.\n// Returns true if the directory was created, false if it already existed.\nfunc setupEntireDirectory() (bool, error) {\n\t// Get absolute path for the .entire directory\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\n\t// Check if directory already exists\n\tcreated := false\n\tif _, err := os.Stat(entireDirAbs); os.IsNotExist(err) {\n\t\tcreated = true\n\t}\n\n\t// Create .entire directory\n\t//nolint:gosec // G301: Project directory needs standard permissions for git\n\tif err := os.MkdirAll(entireDirAbs, 0o755); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to create .entire directory: %w\", err)\n\t}\n\n\t// Create/update .gitignore with all required entries\n\tif err := strategy.EnsureEntireGitignore(); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to setup .gitignore: %w\", err)\n\t}\n\n\treturn created, nil\n}\n\n// setupGitHook installs the prepare-commit-msg hook for context trailers.\nfunc setupGitHook() error {\n\t// Use shared implementation from strategy package\n\t// The localDev setting is read from settings.json\n\t_, err := strategy.InstallGitHook(false) // not silent - show output during setup\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hook: %w\", err)\n\t}\n\treturn nil\n}\n\n// newSetupGitHookCmd creates the standalone git-hook setup command\nfunc newSetupGitHookCmd() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:    \"git-hook\",\n\t\tShort:  \"Install git hook for session context trailers\",\n\t\tHidden: true, // Hidden as it's mainly for testing\n\t\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\treturn setupGitHook()\n\t\t},\n\t}\n\n\treturn cmd\n}\n\nfunc newCurlBashPostInstallCmd() *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:    \"curl-bash-post-install\",\n\t\tShort:  \"Post-install tasks for curl|bash installer\",\n\t\tHidden: true,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tw := cmd.OutOrStdout()\n\t\t\tif err := promptShellCompletion(w); err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Note: Shell completion setup skipped: %v\\n\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n}\n\n// Shell completion stanza management.\n// The stanza is a versioned, delimited block written to ~/.zshrc or ~/.bashrc:\n//\n//\t# Entire CLI completions (v1) {{{\n//\tautoload -Uz compinit && compinit && source <(entire completion zsh)\n//\t# }}}\nconst (\n\tshellCompletionStanzaVersion = 1\n\tshellCompletionOpenFormat    = \"# Entire CLI completions (v%d) {{{\"\n\tshellCompletionClose         = \"# }}}\"\n\tshellCompletionLegacyComment = \"# Entire CLI shell completion\" // old format for migration\n)\n\ntype stanzaStatus int\n\nconst (\n\tstanzaNotFound stanzaStatus = iota\n\tstanzaCurrent\n\tstanzaOutdated\n\tstanzaLegacy\n)\n\nvar (\n\terrStanzaCorrupted = errors.New(\"shell completion block is corrupted (missing closing marker)\")\n\terrMultipleStanzas = errors.New(\"found multiple shell completion blocks\")\n)\n\n// findStanzaVersion scans content for the opening stanza marker and returns\n// the version number. Returns 0 if no stanza is found.\nfunc findStanzaVersion(content string) int {\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\treturn version\n\t\t}\n\t}\n\treturn 0\n}\n\n// checkStanzaStatus determines the status of the shell completion stanza in content.\nfunc checkStanzaStatus(content string, currentVersion int) stanzaStatus {\n\tversion := findStanzaVersion(content)\n\tif version > 0 {\n\t\tif version >= currentVersion {\n\t\t\treturn stanzaCurrent\n\t\t}\n\t\treturn stanzaOutdated\n\t}\n\tif strings.Contains(content, shellCompletionLegacyComment) {\n\t\treturn stanzaLegacy\n\t}\n\treturn stanzaNotFound\n}\n\n// buildStanza constructs the full stanza block for the given version and completion line.\nfunc buildStanza(version int, completionLine string) string {\n\treturn fmt.Sprintf(shellCompletionOpenFormat, version) + \"\\n\" + completionLine + \"\\n\" + shellCompletionClose\n}\n\n// countStanzaOpeners counts how many opening stanza markers exist in content.\nfunc countStanzaOpeners(content string) int {\n\tcount := 0\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n// replaceStanza finds the open+close markers in content and replaces the block\n// with a new stanza. Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc replaceStanza(content string, version int, completionLine string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tnewStanza := buildStanza(version, completionLine)\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\tresult = append(result, newStanza)\n\tresult = append(result, lines[closeIdx+1:]...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeStanza finds and removes the stanza block from content.\n// Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc removeStanza(content string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\t// Skip blank line immediately after stanza if present\n\ttail := lines[closeIdx+1:]\n\tif len(tail) > 0 && strings.TrimSpace(tail[0]) == \"\" {\n\t\ttail = tail[1:]\n\t}\n\tresult = append(result, tail...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeLegacyCompletion removes the old-format comment and its following\n// completion line from content. Returns the modified content and whether\n// anything was removed.\nfunc removeLegacyCompletion(content, completionLine string) (string, bool) {\n\tlines := strings.Split(content, \"\\n\")\n\tvar result []string\n\tremoved := false\n\tfor i := 0; i < len(lines); i++ {\n\t\tif strings.TrimSpace(lines[i]) == shellCompletionLegacyComment {\n\t\t\t// Remove the comment line and the next line if it matches the completion line\n\t\t\tif i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == completionLine {\n\t\t\t\ti++ // skip next line too\n\t\t\t}\n\t\t\tremoved = true\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, lines[i])\n\t}\n\tif !removed {\n\t\treturn content, false\n\t}\n\treturn strings.Join(result, \"\\n\"), true\n}\n\n// errUnsupportedShell is returned when the user's shell is not supported for completion.\nvar errUnsupportedShell = errors.New(\"unsupported shell\")\n\n// shellCompletionTarget returns the rc file path and completion lines for the\n// user's current shell.\nfunc shellCompletionTarget() (shellName, rcFile, completionLine string, err error) {\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", fmt.Errorf(\"cannot determine home directory: %w\", err)\n\t}\n\n\tshell := os.Getenv(\"SHELL\")\n\tswitch {\n\tcase strings.Contains(shell, \"zsh\"):\n\t\treturn \"Zsh\",\n\t\t\tfilepath.Join(home, \".zshrc\"),\n\t\t\t\"source <(entire completion zsh)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"bash\"):\n\t\treturn \"Bash\",\n\t\t\tfilepath.Join(home, \".bashrc\"),\n\t\t\t\"source <(entire completion bash)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"fish\"):\n\t\treturn \"Fish\",\n\t\t\tfilepath.Join(home, \".config\", \"fish\", \"config.fish\"),\n\t\t\t\"entire completion fish | source\",\n\t\t\tnil\n\tdefault:\n\t\treturn \"\", \"\", \"\", errUnsupportedShell\n\t}\n}\n\n// promptShellCompletion offers to add shell completion to the user's rc file.\n// Handles versioned stanza detection, updates, and legacy migration.\nfunc promptShellCompletion(w io.Writer) error {\n\tshellName, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\tif errors.Is(err, errUnsupportedShell) {\n\t\t\tfmt.Fprintf(w, \"Note: Shell completion not available for your shell. Supported: zsh, bash, fish.\\n\")\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"shell completion: %w\", err)\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\tstatus := checkStanzaStatus(string(content), shellCompletionStanzaVersion)\n\tswitch status {\n\tcase stanzaCurrent:\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil\n\n\tcase stanzaOutdated:\n\t\tif !promptYesNo(\"Shell completion is outdated. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t// Re-read in case file changed\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, replaceErr := replaceStanza(string(content), shellCompletionStanzaVersion, completionLine)\n\t\tif replaceErr != nil {\n\t\t\tfmt.Fprintf(w, \"Warning: %v in %s. Please fix manually.\\n\", replaceErr, rcFile)\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaLegacy:\n\t\tif !promptYesNo(\"Shell completion uses old format. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, _ := removeLegacyCompletion(string(content), completionLine)\n\t\tupdated = updated + \"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\"\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaNotFound:\n\t\tif !promptYesNo(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)) {\n\t\t\treturn nil\n\t\t}\n\t\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t}\n\n\treturn nil\n}\n\n// promptYesNo shows a yes/no selection prompt and returns whether the user chose yes.\nfunc promptYesNo(title string) bool {\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(title).\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Yes\", \"yes\"),\n\t\t\t\t\thuh.NewOption(\"No\", \"no\"),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n\treturn selected == \"yes\"\n}\n\n<<<<<<< HEAD\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), \"entire completion\")\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n||||||| parent of b6ff09d (Add versioned stanza management for shell completion)\n// isCompletionConfigured checks if shell completion is already in the rc file.\nfunc isCompletionConfigured(rcFile string, completionLine string) bool {\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\treturn false // File doesn't exist or can't read, treat as not configured\n\t}\n\treturn strings.Contains(string(content), completionLine)\n}\n\n// appendShellCompletion adds the completion line to the rc file.\n=======\n// appendShellCompletion adds the completion stanza to the rc file.\n>>>>>>> b6ff09d (Add versioned stanza management for shell completion)\nfunc appendShellCompletion(rcFile, completionLine string) error {\n\tif err := os.MkdirAll(filepath.Dir(rcFile), 0o755); err != nil {\n\t\treturn fmt.Errorf(\"creating directory: %w\", err)\n\t}\n\t//nolint:gosec // G302: Shell rc files need 0644 for user readability\n\tf, err := os.OpenFile(rcFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(\"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing completion: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeShellCompletion removes the shell completion stanza (or legacy format)\n// from the user's rc file. Used during uninstall.\nfunc removeShellCompletion() error {\n\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\ttext := string(content)\n\tupdated, removeErr := removeStanza(text)\n\tif removeErr != nil {\n\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n\t}\n\n\tif updated != text {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Fall back to legacy format removal\n\tupdated, removed := removeLegacyCompletion(text, completionLine)\n\tif removed {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// promptTelemetryConsent asks the user if they want to enable telemetry.\n// It modifies settings.Telemetry based on the user's choice or flags.\n// The caller is responsible for saving settings.\nfunc promptTelemetryConsent(settings *EntireSettings, telemetryFlag bool) error {\n\t// Handle --telemetry=false flag first (always overrides existing setting)\n\tif !telemetryFlag {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\t// Skip if already asked\n\tif settings.Telemetry != nil {\n\t\treturn nil\n\t}\n\n\t// Skip if env var disables telemetry (record as disabled)\n\tif os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\tconsent := true // Default to Yes\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewConfirm().\n\t\t\t\tTitle(\"Help improve Entire CLI?\").\n\t\t\t\tDescription(\"Share anonymous usage data. No code or personal info collected.\").\n\t\t\t\tAffirmative(\"Yes\").\n\t\t\t\tNegative(\"No\").\n\t\t\t\tValue(&consent),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn fmt.Errorf(\"telemetry prompt: %w\", err)\n\t}\n\n\tsettings.Telemetry = &consent\n\treturn nil\n}\n\n// runUninstall completely removes Entire from the repository.\nfunc runUninstall(w, errW io.Writer, force bool) error {\n\t// Check if we're in a git repository\n\tif _, err := paths.RepoRoot(); err != nil {\n\t\tfmt.Fprintln(errW, \"Not a git repository. Nothing to uninstall.\")\n\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t}\n\n\t// Gather counts for display\n\tsessionStateCount := countSessionStates()\n\tshadowBranchCount := countShadowBranches()\n\tgitHooksInstalled := strategy.IsGitHookInstalled()\n\tclaudeHooksInstalled := checkClaudeCodeHooksInstalled()\n\tgeminiHooksInstalled := checkGeminiCLIHooksInstalled()\n\tentireDirExists := checkEntireDirExists()\n\n\t// Check if there's anything to uninstall\n\tif !entireDirExists && !gitHooksInstalled && sessionStateCount == 0 &&\n\t\tshadowBranchCount == 0 && !claudeHooksInstalled && !geminiHooksInstalled {\n\t\tfmt.Fprintln(w, \"Entire is not installed in this repository.\")\n\t\treturn nil\n\t}\n\n\t// Show confirmation prompt unless --force\n\tif !force {\n\t\tfmt.Fprintln(w, \"\\nThis will completely remove Entire from this repository:\")\n\t\tif entireDirExists {\n\t\t\tfmt.Fprintln(w, \"  - .entire/ directory\")\n\t\t}\n\t\tif gitHooksInstalled {\n\t\t\tfmt.Fprintln(w, \"  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\")\n\t\t}\n\t\tif sessionStateCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Session state files (%d)\\n\", sessionStateCount)\n\t\t}\n\t\tif shadowBranchCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Shadow branches (%d)\\n\", shadowBranchCount)\n\t\t}\n\t\tswitch {\n\t\tcase claudeHooksInstalled && geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code, Gemini CLI)\")\n\t\tcase claudeHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code)\")\n\t\tcase geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Gemini CLI)\")\n\t\t}\n\t\tfmt.Fprintln(w)\n\n\t\tvar confirmed bool\n\t\tform := NewAccessibleForm(\n\t\t\thuh.NewGroup(\n\t\t\t\thuh.NewConfirm().\n\t\t\t\t\tTitle(\"Are you sure you want to uninstall Entire?\").\n\t\t\t\t\tAffirmative(\"Yes, uninstall\").\n\t\t\t\t\tNegative(\"Cancel\").\n\t\t\t\t\tValue(&confirmed),\n\t\t\t),\n\t\t)\n\n\t\tif err := form.Run(); err != nil {\n\t\t\treturn fmt.Errorf(\"confirmation cancelled: %w\", err)\n\t\t}\n\n\t\tif !confirmed {\n\t\t\tfmt.Fprintln(w, \"Uninstall cancelled.\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"\\nUninstalling Entire CLI...\")\n\n\t// 0. Remove shell completion from rc file\n\tif err := removeShellCompletion(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shell completion: %v\\n\", err)\n\t} else {\n\t\tfmt.Fprintln(w, \"  Removed shell completion\")\n\t}\n\n\t// 1. Remove agent hooks (lowest risk)\n\tif err := removeAgentHooks(w); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove agent hooks: %v\\n\", err)\n\t}\n\n\t// 2. Remove git hooks\n\tremoved, err := strategy.RemoveGitHook()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove git hooks: %v\\n\", err)\n\t} else if removed > 0 {\n\t\tfmt.Fprintf(w, \"  Removed git hooks (%d)\\n\", removed)\n\t}\n\n\t// 3. Remove session state files\n\tstatesRemoved, err := removeAllSessionStates()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove session states: %v\\n\", err)\n\t} else if statesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed session states (%d)\\n\", statesRemoved)\n\t}\n\n\t// 4. Remove .entire/ directory\n\tif err := removeEntireDirectory(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove .entire directory: %v\\n\", err)\n\t} else if entireDirExists {\n\t\tfmt.Fprintln(w, \"  Removed .entire directory\")\n\t}\n\n\t// 5. Remove shadow branches\n\tbranchesRemoved, err := removeAllShadowBranches()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shadow branches: %v\\n\", err)\n\t} else if branchesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed %d shadow branches\\n\", branchesRemoved)\n\t}\n\n\tfmt.Fprintln(w, \"\\nEntire CLI uninstalled successfully.\")\n\treturn nil\n}\n\n// countSessionStates returns the number of active session state files.\nfunc countSessionStates() int {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0\n\t}\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(states)\n}\n\n// countShadowBranches returns the number of shadow branches.\nfunc countShadowBranches() int {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(branches)\n}\n\n// checkClaudeCodeHooksInstalled checks if Claude Code hooks are installed.\nfunc checkClaudeCodeHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkGeminiCLIHooksInstalled checks if Gemini CLI hooks are installed.\nfunc checkGeminiCLIHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameGemini)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkEntireDirExists checks if the .entire directory exists.\nfunc checkEntireDirExists() bool {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\t_, err = os.Stat(entireDirAbs)\n\treturn err == nil\n}\n\n// removeAgentHooks removes hooks from all agents that support hooks.\nfunc removeAgentHooks(w io.Writer) error {\n\tvar errs []error\n\n\t// Remove Claude Code hooks\n\tclaudeAgent, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err == nil {\n\t\tif hookAgent, ok := claudeAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Claude Code hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove Gemini CLI hooks\n\tgeminiAgent, err := agent.Get(agent.AgentNameGemini)\n\tif err == nil {\n\t\tif hookAgent, ok := geminiAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Gemini CLI hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errors.Join(errs...)\n}\n\n// removeAllSessionStates removes all session state files and the directory.\nfunc removeAllSessionStates() (int, error) {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to create state store: %w\", err)\n\t}\n\n\t// Count states before removing\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list session states: %w\", err)\n\t}\n\tcount := len(states)\n\n\t// Remove the entire directory\n\tif err := store.RemoveAll(); err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to remove session states: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// removeEntireDirectory removes the .entire directory.\nfunc removeEntireDirectory() error {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\tif err := os.RemoveAll(entireDirAbs); err != nil {\n\t\treturn fmt.Errorf(\"failed to remove .entire directory: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeAllShadowBranches removes all shadow branches.\nfunc removeAllShadowBranches() (int, error) {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list shadow branches: %w\", err)\n\t}\n\tif len(branches) == 0 {\n\t\treturn 0, nil\n\t}\n\tdeleted, _, err := strategy.DeleteShadowBranches(branches)\n\treturn len(deleted), err\n}\n","structuredPatch":[{"oldStart":983,"oldLines":33,"newStart":983,"newLines":7,"lines":["   return selected == \"yes\""," }"," ","-<<<<<<< HEAD","-// isCompletionConfigured checks if shell completion is already in the rc file.","-func isCompletionConfigured(rcFile string) bool {","-  //nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input","-  content, err := os.ReadFile(rcFile)","-  if err != nil {","-    return false // File doesn't exist or can't read, treat as not configured","-  }","-  return strings.Contains(string(content), \"entire completion\")","-}","-","-// appendShellCompletion adds the completion line to the rc file.","-||||||| parent of b6ff09d (Add versioned stanza management for shell completion)","-// isCompletionConfigured checks if shell completion is already in the rc file.","-func isCompletionConfigured(rcFile string, completionLine string) bool {","-  //nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input","-  content, err := os.ReadFile(rcFile)","-  if err != nil {","-    return false // File doesn't exist or can't read, treat as not configured","-  }","-  return strings.Contains(string(content), completionLine)","-}","-","-// appendShellCompletion adds the completion line to the rc file.","-======="," // appendShellCompletion adds the completion stanza to the rc file.","->>>>>>> b6ff09d (Add versioned stanza management for shell completion)"," func appendShellCompletion(rcFile, completionLine string) error {","   if err := os.MkdirAll(filepath.Dir(rcFile), 0o755); err != nil {","     return fmt.Errorf(\"creating directory: %w\", err)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"f119639b-df6f-42b3-95e8-24c23f08221d"}
{"parentUuid":"0ed94c82-80ed-4fe6-8e59-078593d24852","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01WZPoEhUdcPZHCSQeqFUCnc","type":"message","role":"assistant","content":[{"type":"text","text":"There's still a conflict marker somewhere. Let me check what's left:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":625,"cache_read_input_tokens":51070,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":625},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxdsFRTjyDpwQ1DpNqa","type":"assistant","uuid":"5acd8d23-32fc-4c2d-aa69-0e00b488f907","timestamp":"2026-02-09T05:41:30.648Z"}
{"parentUuid":"5acd8d23-32fc-4c2d-aa69-0e00b488f907","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01WZPoEhUdcPZHCSQeqFUCnc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015JPpwhN8LcrqToEy296FSS","name":"Grep","input":{"pattern":"^[<>=]{7}","path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":625,"cache_read_input_tokens":51070,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":625},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxdsFRTjyDpwQ1DpNqa","type":"assistant","uuid":"0c6c5e28-cc71-45df-9270-4f151b770295","timestamp":"2026-02-09T05:41:31.692Z"}
{"parentUuid":"0c6c5e28-cc71-45df-9270-4f151b770295","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_015JPpwhN8LcrqToEy296FSS","toolUseID":"toolu_015JPpwhN8LcrqToEy296FSS","timestamp":"2026-02-09T05:41:31.787Z","uuid":"98f3b551-0bcb-4d35-9a4d-1b2bb05b624e"}
{"parentUuid":"0c6c5e28-cc71-45df-9270-4f151b770295","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015JPpwhN8LcrqToEy296FSS","type":"tool_result","content":"No matches found"}]},"uuid":"727b4b9c-bb01-412a-a132-b826a3bb7b49","timestamp":"2026-02-09T05:41:31.786Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0},"sourceToolAssistantUUID":"0c6c5e28-cc71-45df-9270-4f151b770295"}
{"parentUuid":"727b4b9c-bb01-412a-a132-b826a3bb7b49","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01Bn7d4g38a3zxYvaHrybbab","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DqbMvEAK7twtUjJvo2PSMR","name":"Grep","input":{"pattern":"^[\\|]{7}","path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":229,"cache_read_input_tokens":51695,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":229},"output_tokens":19,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxeR75gxkX7a7dbK6ro","type":"assistant","uuid":"69af7bc2-94f6-4fc8-9d08-72320401711b","timestamp":"2026-02-09T05:41:38.526Z"}
{"parentUuid":"69af7bc2-94f6-4fc8-9d08-72320401711b","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_01DqbMvEAK7twtUjJvo2PSMR","toolUseID":"toolu_01DqbMvEAK7twtUjJvo2PSMR","timestamp":"2026-02-09T05:41:38.601Z","uuid":"7b5df959-1bbf-422f-83ee-9616ea958639"}
{"parentUuid":"69af7bc2-94f6-4fc8-9d08-72320401711b","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DqbMvEAK7twtUjJvo2PSMR","type":"tool_result","content":"No matches found"}]},"uuid":"84ed9d03-5cf8-41b3-a556-77f58f804712","timestamp":"2026-02-09T05:41:38.600Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0},"sourceToolAssistantUUID":"69af7bc2-94f6-4fc8-9d08-72320401711b"}
{"parentUuid":"84ed9d03-5cf8-41b3-a556-77f58f804712","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_011BvpoHmbZp87q8EyiUDVzn","type":"message","role":"assistant","content":[{"type":"text","text":"All conflict markers are gone. The remaining issue is `removeShellCompletion` calling `shellCompletionTarget()` with only 2 return values. Let me fix that:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":132,"cache_read_input_tokens":51924,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":132},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxev678v8eMLnTUgxML","type":"assistant","uuid":"e913c63c-04a0-42ef-9a83-943b08fb7334","timestamp":"2026-02-09T05:41:45.103Z"}
{"parentUuid":"e913c63c-04a0-42ef-9a83-943b08fb7334","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_011BvpoHmbZp87q8EyiUDVzn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012VSWwpsHNeDNkETaKtqVzW","name":"Read","input":{"file_path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","offset":1003,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":132,"cache_read_input_tokens":51924,"output_tokens":154,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":132,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXwxev678v8eMLnTUgxML","type":"assistant","uuid":"8e824576-4457-464c-918a-d3afbb881cf9","timestamp":"2026-02-09T05:41:45.835Z"}
{"parentUuid":"8e824576-4457-464c-918a-d3afbb881cf9","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_012VSWwpsHNeDNkETaKtqVzW","toolUseID":"toolu_012VSWwpsHNeDNkETaKtqVzW","timestamp":"2026-02-09T05:41:45.850Z","uuid":"2f8a39e2-87dd-43d7-88d2-da338e7d00ef"}
{"parentUuid":"8e824576-4457-464c-918a-d3afbb881cf9","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012VSWwpsHNeDNkETaKtqVzW","type":"tool_result","content":"  1003→}\n  1004→\n  1005→// removeShellCompletion removes the shell completion stanza (or legacy format)\n  1006→// from the user's rc file. Used during uninstall.\n  1007→func removeShellCompletion() error {\n  1008→\trcFile, completionLine := shellCompletionTarget()\n  1009→\tif rcFile == \"\" {\n  1010→\t\treturn nil\n  1011→\t}\n  1012→\n  1013→\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n  1014→\tcontent, err := os.ReadFile(rcFile)\n  1015→\tif err != nil {\n  1016→\t\tif os.IsNotExist(err) {\n  1017→\t\t\treturn nil\n  1018→\t\t}\n  1019→\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n  1020→\t}\n  1021→\n  1022→\ttext := string(content)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a9b20e7e-355e-4c2e-aa4a-eb95d50ddfde","timestamp":"2026-02-09T05:41:45.849Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","content":"}\n\n// removeShellCompletion removes the shell completion stanza (or legacy format)\n// from the user's rc file. Used during uninstall.\nfunc removeShellCompletion() error {\n\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\ttext := string(content)","numLines":20,"startLine":1003,"totalLines":1346}},"sourceToolAssistantUUID":"8e824576-4457-464c-918a-d3afbb881cf9"}
{"parentUuid":"a9b20e7e-355e-4c2e-aa4a-eb95d50ddfde","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_01XrVAbmiYY82A9DYxkEvUoV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SSHf7Lamg2DkrYAofnJZJY","name":"Edit","input":{"replace_all":false,"file_path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","old_string":"\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}","new_string":"\t_, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\treturn nil // unsupported shell or no home dir - nothing to remove\n\t}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":505,"cache_read_input_tokens":52056,"output_tokens":204,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":505,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXwxfT7QbwkrEyq7umvJH","type":"assistant","uuid":"343cc2a6-6c4e-4e04-814e-d658b9f049a9","timestamp":"2026-02-09T05:41:53.254Z"}
{"parentUuid":"343cc2a6-6c4e-4e04-814e-d658b9f049a9","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01SSHf7Lamg2DkrYAofnJZJY","toolUseID":"toolu_01SSHf7Lamg2DkrYAofnJZJY","timestamp":"2026-02-09T05:42:00.098Z","uuid":"28f3f02e-5118-42be-afe0-4783e831071e"}
{"parentUuid":"343cc2a6-6c4e-4e04-814e-d658b9f049a9","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SSHf7Lamg2DkrYAofnJZJY","type":"tool_result","content":"The file /Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go has been updated successfully."}]},"uuid":"756da67a-d15b-4513-b4bb-11eb1c0bf3f0","timestamp":"2026-02-09T05:42:00.097Z","toolUseResult":{"filePath":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","oldString":"\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}","newString":"\t_, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\treturn nil // unsupported shell or no home dir - nothing to remove\n\t}","originalFile":"package cli\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/entireio/cli/cmd/entire/cli/agent\"\n\t\"github.com/entireio/cli/cmd/entire/cli/paths\"\n\t\"github.com/entireio/cli/cmd/entire/cli/session\"\n\t\"github.com/entireio/cli/cmd/entire/cli/strategy\"\n\n\t\"github.com/charmbracelet/huh\"\n\t\"github.com/spf13/cobra\"\n)\n\n// Strategy display names for user-friendly selection\nconst (\n\tstrategyDisplayManualCommit = \"manual-commit\"\n\tstrategyDisplayAutoCommit   = \"auto-commit\"\n)\n\n// strategyDisplayToInternal maps user-friendly names to internal strategy names\nvar strategyDisplayToInternal = map[string]string{\n\tstrategyDisplayManualCommit: strategy.StrategyNameManualCommit,\n\tstrategyDisplayAutoCommit:   strategy.StrategyNameAutoCommit,\n}\n\n// strategyInternalToDisplay maps internal strategy names to user-friendly names\nvar strategyInternalToDisplay = map[string]string{\n\tstrategy.StrategyNameManualCommit: strategyDisplayManualCommit,\n\tstrategy.StrategyNameAutoCommit:   strategyDisplayAutoCommit,\n}\n\nfunc newEnableCmd() *cobra.Command {\n\tvar localDev bool\n\tvar ignoreUntracked bool\n\tvar useLocalSettings bool\n\tvar useProjectSettings bool\n\tvar agentName string\n\tvar strategyFlag string\n\tvar forceHooks bool\n\tvar skipPushSessions bool\n\tvar telemetry bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"enable\",\n\t\tShort: \"Enable Entire\",\n\t\tLong: `Enable Entire with session tracking for your AI agent workflows.\n\nUses the manual-commit strategy by default. To use a different strategy:\n\n  entire enable --strategy auto-commit\n\nStrategies: manual-commit (default), auto-commit`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\t// Check if we're in a git repository first - this is a prerequisite error,\n\t\t\t// not a usage error, so we silence Cobra's output and use SilentError\n\t\t\t// to prevent duplicate error output in main.go\n\t\t\tif _, err := paths.RepoRoot(); err != nil {\n\t\t\t\tcmd.SilenceUsage = true\n\t\t\t\tcmd.SilenceErrors = true\n\t\t\t\tfmt.Fprintln(cmd.ErrOrStderr(), \"Not a git repository. Please run 'entire enable' from within a git repository.\")\n\t\t\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t\t\t}\n\n\t\t\tif err := validateSetupFlags(useLocalSettings, useProjectSettings); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Non-interactive mode if --agent flag is provided\n\t\t\tif agentName != \"\" {\n\t\t\t\treturn setupAgentHooksNonInteractive(agent.AgentName(agentName), strategyFlag, localDev, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\t// If strategy is specified via flag, skip interactive selection\n\t\t\tif strategyFlag != \"\" {\n\t\t\t\treturn runEnableWithStrategy(cmd.OutOrStdout(), strategyFlag, localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t\t}\n\t\t\treturn runEnableInteractive(cmd.OutOrStdout(), localDev, ignoreUntracked, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&localDev, \"local-dev\", false, \"Use go run instead of entire binary for hooks\")\n\tcmd.Flags().MarkHidden(\"local-dev\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&ignoreUntracked, \"ignore-untracked\", false, \"Commit all new files without tracking pre-existing untracked files\")\n\tcmd.Flags().MarkHidden(\"ignore-untracked\") //nolint:errcheck,gosec // flag is defined above\n\tcmd.Flags().BoolVar(&useLocalSettings, \"local\", false, \"Write settings to settings.local.json instead of settings.json\")\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Write settings to settings.json even if it already exists\")\n\tcmd.Flags().StringVar(&agentName, \"agent\", \"\", \"Agent to setup hooks for (e.g., claude-code). Enables non-interactive mode.\")\n\tcmd.Flags().StringVar(&strategyFlag, \"strategy\", \"\", \"Strategy to use (manual-commit or auto-commit)\")\n\tcmd.Flags().BoolVarP(&forceHooks, \"force\", \"f\", false, \"Force reinstall hooks (removes existing Entire hooks first)\")\n\tcmd.Flags().BoolVar(&skipPushSessions, \"skip-push-sessions\", false, \"Disable automatic pushing of session logs on git push\")\n\tcmd.Flags().BoolVar(&telemetry, \"telemetry\", true, \"Enable anonymous usage analytics\")\n\t//nolint:errcheck,gosec // completion is optional, flag is defined above\n\tcmd.RegisterFlagCompletionFunc(\"strategy\", func(_ *cobra.Command, _ []string, _ string) ([]string, cobra.ShellCompDirective) {\n\t\treturn []string{strategyDisplayManualCommit, strategyDisplayAutoCommit}, cobra.ShellCompDirectiveNoFileComp\n\t})\n\n\t// Add subcommands for automation/testing\n\tcmd.AddCommand(newSetupGitHookCmd())\n\n\treturn cmd\n}\n\nfunc newDisableCmd() *cobra.Command {\n\tvar useProjectSettings bool\n\tvar uninstall bool\n\tvar force bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"disable\",\n\t\tShort: \"Disable Entire\",\n\t\tLong: `Disable Entire temporarily. Hooks will exit silently and commands will show a disabled message.\n\nUse --uninstall to completely remove Entire from this repository, including:\n  - .entire/ directory (settings, logs, metadata)\n  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\n  - Session state files (.git/entire-sessions/)\n  - Shadow branches (entire/<hash>)\n  - Agent hooks (Claude Code, Gemini CLI)`,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tif uninstall {\n\t\t\t\treturn runUninstall(cmd.OutOrStdout(), cmd.ErrOrStderr(), force)\n\t\t\t}\n\t\t\treturn runDisable(cmd.OutOrStdout(), useProjectSettings)\n\t\t},\n\t}\n\n\tcmd.Flags().BoolVar(&useProjectSettings, \"project\", false, \"Update settings.json instead of settings.local.json\")\n\tcmd.Flags().BoolVar(&uninstall, \"uninstall\", false, \"Completely remove Entire from this repository\")\n\tcmd.Flags().BoolVar(&force, \"force\", false, \"Skip confirmation prompt (use with --uninstall)\")\n\n\treturn cmd\n}\n\n// runEnableWithStrategy enables Entire with a specified strategy (non-interactive).\n// The selectedStrategy can be either a display name (manual-commit, auto-commit)\n// or an internal name (manual-commit, auto-commit).\nfunc runEnableWithStrategy(w io.Writer, selectedStrategy string, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Map the strategy to internal name if it's a display name\n\tinternalStrategy := selectedStrategy\n\tif mapped, ok := strategyDisplayToInternal[selectedStrategy]; ok {\n\t\tinternalStrategy = mapped\n\t}\n\n\t// Validate the strategy exists\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", selectedStrategy)\n\t}\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\t// Determine which settings file to write to\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, showNotification := determineSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\n\tif showNotification {\n\t\tfmt.Fprintln(w, \"Info: Project settings exist. Saving to settings.local.json instead.\")\n\t\tfmt.Fprintln(w, \"  Use --project to update the project settings file.\")\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tdisplayName := selectedStrategy\n\tif dn, ok := strategyInternalToDisplay[internalStrategy]; ok {\n\t\tdisplayName = dn\n\t}\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", displayName)\n\n\treturn nil\n}\n\n// runEnableInteractive runs the interactive enable flow.\nfunc runEnableInteractive(w io.Writer, localDev, _, useLocalSettings, useProjectSettings, forceHooks, skipPushSessions, telemetry bool) error {\n\t// Use the default strategy (manual-commit)\n\tinternalStrategy := strategy.DefaultStrategyName\n\tfmt.Fprintf(w, \"Using %s strategy (use --strategy to change)\\n\\n\", strategyInternalToDisplay[internalStrategy])\n\n\t// Setup Claude Code hooks\n\thooksInstalled, err := setupClaudeCodeHook(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup Claude Code hooks: %w\", err)\n\t}\n\tif hooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Claude Code hooks verified\")\n\t}\n\n\t// Setup .entire directory\n\tdirCreated, err := setupEntireDirectory()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to setup .entire directory: %w\", err)\n\t}\n\tif dirCreated {\n\t\tfmt.Fprintln(w, \"✓ .entire directory created\")\n\t}\n\n\t// Load existing settings to preserve other options (like strategy_options.push)\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\t// If we can't load, start with defaults\n\t\tsettings = &EntireSettings{}\n\t}\n\t// Update the specific fields\n\tsettings.Strategy = internalStrategy\n\tsettings.LocalDev = localDev\n\tsettings.Enabled = true\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Ask about telemetry consent (only if not already asked)\n\tif err := promptTelemetryConsent(settings, telemetry); err != nil {\n\t\treturn fmt.Errorf(\"telemetry consent: %w\", err)\n\t}\n\n\t// Determine which settings file to write to (interactive prompt if settings.json exists)\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\tshouldUseLocal, err := promptSettingsTarget(entireDirAbs, useLocalSettings, useProjectSettings)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif shouldUseLocal {\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Local settings saved (.entire/settings.local.json)\")\n\t} else {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t\tfmt.Fprintln(w, \"✓ Project settings saved (.entire/settings.json)\")\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tgitHooksInstalled, err := strategy.InstallGitHook(true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\tif gitHooksInstalled > 0 {\n\t\tfmt.Fprintln(w, \"✓ Git hooks installed\")\n\t} else {\n\t\tfmt.Fprintln(w, \"✓ Git hooks verified\")\n\t}\n\n\t// Let the strategy handle its own setup requirements\n\tstrat, err := strategy.Get(internalStrategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\t// Show success message with display name\n\tfmt.Fprintf(w, \"\\n✓ %s strategy enabled\\n\", strategyInternalToDisplay[internalStrategy])\n\n\treturn nil\n}\n\n// runEnable is a simple enable that just sets the enabled flag (for programmatic use).\nfunc runEnable(w io.Writer) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = true\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now enabled.\")\n\treturn nil\n}\n\nfunc runDisable(w io.Writer, useProjectSettings bool) error {\n\tsettings, err := LoadEntireSettings()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to load settings: %w\", err)\n\t}\n\n\tsettings.Enabled = false\n\n\t// If --project flag is specified, always write to project settings\n\tif useProjectSettings {\n\t\tif err := SaveEntireSettings(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t\t}\n\t} else {\n\t\t// Always write to local settings file (create if doesn't exist)\n\t\tif err := SaveEntireSettingsLocal(settings); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save local settings: %w\", err)\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"Entire is now disabled.\")\n\treturn nil\n}\n\n// DisabledMessage is the message shown when Entire is disabled\nconst DisabledMessage = \"Entire is disabled. Run `entire enable` to re-enable.\"\n\n// checkDisabledGuard checks if Entire is disabled and prints a message if so.\n// Returns true if the caller should exit (i.e., Entire is disabled).\n// On error reading settings, defaults to enabled (returns false).\nfunc checkDisabledGuard(w io.Writer) bool {\n\tenabled, err := IsEnabled()\n\tif err != nil {\n\t\t// Default to enabled on error\n\t\treturn false\n\t}\n\tif !enabled {\n\t\tfmt.Fprintln(w, DisabledMessage)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// setupClaudeCodeHook sets up Claude Code hooks.\n// This is a convenience wrapper that uses the agent package.\n// Returns the number of hooks installed (0 if already installed).\nfunc setupClaudeCodeHook(localDev, forceHooks bool) (int, error) {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to get claude-code agent: %w\", err)\n\t}\n\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn 0, errors.New(\"claude-code agent does not support hooks\")\n\t}\n\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to install claude-code hooks: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// setupAgentHooksNonInteractive sets up hooks for a specific agent non-interactively.\n// If strategyName is provided, it sets the strategy; otherwise uses default.\nfunc setupAgentHooksNonInteractive(agentName agent.AgentName, strategyName string, localDev, forceHooks, skipPushSessions, telemetry bool) error {\n\tag, err := agent.Get(agentName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unknown agent: %s\", agentName)\n\t}\n\n\t// Check if agent supports hooks\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn fmt.Errorf(\"agent %s does not support hooks\", agentName)\n\t}\n\n\t// Install hooks\n\tcount, err := hookAgent.InstallHooks(localDev, forceHooks)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install hooks for %s: %w\", agentName, err)\n\t}\n\n\tif count == 0 {\n\t\tmsg := fmt.Sprintf(\"Hooks for %s already installed\", ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t} else {\n\t\tmsg := fmt.Sprintf(\"Installed %d hooks for %s\", count, ag.Description())\n\t\tif agentName == agent.AgentNameGemini {\n\t\t\tmsg += \" - This is a work in progress\"\n\t\t}\n\t\tfmt.Println(msg)\n\t}\n\n\t// Update settings to store the strategy\n\tsettings, _ := LoadEntireSettings() //nolint:errcheck // settings defaults are fine\n\tsettings.Enabled = true\n\tif localDev {\n\t\tsettings.LocalDev = localDev\n\t}\n\n\t// Set push_sessions option if --skip-push-sessions flag was provided\n\tif skipPushSessions {\n\t\tif settings.StrategyOptions == nil {\n\t\t\tsettings.StrategyOptions = make(map[string]interface{})\n\t\t}\n\t\tsettings.StrategyOptions[\"push_sessions\"] = false\n\t}\n\n\t// Set strategy if provided\n\tif strategyName != \"\" {\n\t\t// Map display name to internal name if needed\n\t\tinternalStrategy := strategyName\n\t\tif mapped, ok := strategyDisplayToInternal[strategyName]; ok {\n\t\t\tinternalStrategy = mapped\n\t\t}\n\t\t// Validate the strategy exists\n\t\tif _, err := strategy.Get(internalStrategy); err != nil {\n\t\t\treturn fmt.Errorf(\"unknown strategy: %s (use manual-commit or auto-commit)\", strategyName)\n\t\t}\n\t\tsettings.Strategy = internalStrategy\n\t}\n\n\t// Handle telemetry for non-interactive mode\n\t// Note: if telemetry is nil (not configured), it defaults to disabled\n\tif !telemetry || os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t}\n\n\tif err := SaveEntireSettings(settings); err != nil {\n\t\treturn fmt.Errorf(\"failed to save settings: %w\", err)\n\t}\n\n\t// Install git hooks (always reinstall to ensure they're up-to-date)\n\tif _, err := strategy.InstallGitHook(true); err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hooks: %w\", err)\n\t}\n\n\t// Let the strategy handle its own setup requirements (creates entire/sessions branch, etc.)\n\tstrat, err := strategy.Get(settings.Strategy)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get strategy: %w\", err)\n\t}\n\tif err := strat.EnsureSetup(); err != nil {\n\t\treturn fmt.Errorf(\"failed to setup strategy: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// validateSetupFlags checks that --local and --project flags are not both specified.\nfunc validateSetupFlags(useLocal, useProject bool) error {\n\tif useLocal && useProject {\n\t\treturn errors.New(\"cannot specify both --project and --local\")\n\t}\n\treturn nil\n}\n\n// determineSettingsTarget decides whether to write to settings.local.json based on:\n// - Whether settings.json already exists\n// - The --local and --project flags\n// Returns (useLocal, showNotification).\nfunc determineSettingsTarget(entireDir string, useLocal, useProject bool) (bool, bool) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, false\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, false\n\t}\n\n\t// No flags specified - check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); err == nil {\n\t\t// Settings file exists - auto-redirect to local with notification\n\t\treturn true, true\n\t}\n\n\t// Settings file doesn't exist - create it\n\treturn false, false\n}\n\n// Settings target options for interactive prompt\nconst (\n\tsettingsTargetProject = \"project\"\n\tsettingsTargetLocal   = \"local\"\n)\n\n// promptSettingsTarget interactively asks the user where to save settings\n// when settings.json already exists and no flags were provided.\n// Returns (useLocal, error).\nfunc promptSettingsTarget(entireDir string, useLocal, useProject bool) (bool, error) {\n\t// Explicit --local flag always uses local settings\n\tif useLocal {\n\t\treturn true, nil\n\t}\n\n\t// Explicit --project flag always uses project settings\n\tif useProject {\n\t\treturn false, nil\n\t}\n\n\t// Check if settings file exists\n\tsettingsPath := filepath.Join(entireDir, paths.SettingsFileName)\n\tif _, err := os.Stat(settingsPath); os.IsNotExist(err) {\n\t\t// Settings file doesn't exist - create it (no prompt needed)\n\t\treturn false, nil\n\t}\n\n\t// Settings file exists - prompt user\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(\"Project settings already exist. Where should settings be saved?\").\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Update project settings (settings.json)\", settingsTargetProject),\n\t\t\t\t\thuh.NewOption(\"Use local settings (settings.local.json, gitignored)\", settingsTargetLocal),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false, fmt.Errorf(\"selection cancelled: %w\", err)\n\t}\n\n\treturn selected == settingsTargetLocal, nil\n}\n\n// setupEntireDirectory creates the .entire directory and gitignore.\n// Returns true if the directory was created, false if it already existed.\nfunc setupEntireDirectory() (bool, error) {\n\t// Get absolute path for the .entire directory\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir // Fallback to relative\n\t}\n\n\t// Check if directory already exists\n\tcreated := false\n\tif _, err := os.Stat(entireDirAbs); os.IsNotExist(err) {\n\t\tcreated = true\n\t}\n\n\t// Create .entire directory\n\t//nolint:gosec // G301: Project directory needs standard permissions for git\n\tif err := os.MkdirAll(entireDirAbs, 0o755); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to create .entire directory: %w\", err)\n\t}\n\n\t// Create/update .gitignore with all required entries\n\tif err := strategy.EnsureEntireGitignore(); err != nil {\n\t\treturn false, fmt.Errorf(\"failed to setup .gitignore: %w\", err)\n\t}\n\n\treturn created, nil\n}\n\n// setupGitHook installs the prepare-commit-msg hook for context trailers.\nfunc setupGitHook() error {\n\t// Use shared implementation from strategy package\n\t// The localDev setting is read from settings.json\n\t_, err := strategy.InstallGitHook(false) // not silent - show output during setup\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to install git hook: %w\", err)\n\t}\n\treturn nil\n}\n\n// newSetupGitHookCmd creates the standalone git-hook setup command\nfunc newSetupGitHookCmd() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:    \"git-hook\",\n\t\tShort:  \"Install git hook for session context trailers\",\n\t\tHidden: true, // Hidden as it's mainly for testing\n\t\tRunE: func(_ *cobra.Command, _ []string) error {\n\t\t\treturn setupGitHook()\n\t\t},\n\t}\n\n\treturn cmd\n}\n\nfunc newCurlBashPostInstallCmd() *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:    \"curl-bash-post-install\",\n\t\tShort:  \"Post-install tasks for curl|bash installer\",\n\t\tHidden: true,\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tw := cmd.OutOrStdout()\n\t\t\tif err := promptShellCompletion(w); err != nil {\n\t\t\t\tfmt.Fprintf(w, \"Note: Shell completion setup skipped: %v\\n\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n}\n\n// Shell completion stanza management.\n// The stanza is a versioned, delimited block written to ~/.zshrc or ~/.bashrc:\n//\n//\t# Entire CLI completions (v1) {{{\n//\tautoload -Uz compinit && compinit && source <(entire completion zsh)\n//\t# }}}\nconst (\n\tshellCompletionStanzaVersion = 1\n\tshellCompletionOpenFormat    = \"# Entire CLI completions (v%d) {{{\"\n\tshellCompletionClose         = \"# }}}\"\n\tshellCompletionLegacyComment = \"# Entire CLI shell completion\" // old format for migration\n)\n\ntype stanzaStatus int\n\nconst (\n\tstanzaNotFound stanzaStatus = iota\n\tstanzaCurrent\n\tstanzaOutdated\n\tstanzaLegacy\n)\n\nvar (\n\terrStanzaCorrupted = errors.New(\"shell completion block is corrupted (missing closing marker)\")\n\terrMultipleStanzas = errors.New(\"found multiple shell completion blocks\")\n)\n\n// findStanzaVersion scans content for the opening stanza marker and returns\n// the version number. Returns 0 if no stanza is found.\nfunc findStanzaVersion(content string) int {\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\treturn version\n\t\t}\n\t}\n\treturn 0\n}\n\n// checkStanzaStatus determines the status of the shell completion stanza in content.\nfunc checkStanzaStatus(content string, currentVersion int) stanzaStatus {\n\tversion := findStanzaVersion(content)\n\tif version > 0 {\n\t\tif version >= currentVersion {\n\t\t\treturn stanzaCurrent\n\t\t}\n\t\treturn stanzaOutdated\n\t}\n\tif strings.Contains(content, shellCompletionLegacyComment) {\n\t\treturn stanzaLegacy\n\t}\n\treturn stanzaNotFound\n}\n\n// buildStanza constructs the full stanza block for the given version and completion line.\nfunc buildStanza(version int, completionLine string) string {\n\treturn fmt.Sprintf(shellCompletionOpenFormat, version) + \"\\n\" + completionLine + \"\\n\" + shellCompletionClose\n}\n\n// countStanzaOpeners counts how many opening stanza markers exist in content.\nfunc countStanzaOpeners(content string) int {\n\tcount := 0\n\tfor line := range strings.SplitSeq(content, \"\\n\") {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar version int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &version); err == nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n// replaceStanza finds the open+close markers in content and replaces the block\n// with a new stanza. Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc replaceStanza(content string, version int, completionLine string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tnewStanza := buildStanza(version, completionLine)\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\tresult = append(result, newStanza)\n\tresult = append(result, lines[closeIdx+1:]...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeStanza finds and removes the stanza block from content.\n// Returns errStanzaCorrupted if open found without close,\n// errMultipleStanzas if count > 1. Returns unchanged content with nil error if\n// no stanza found.\nfunc removeStanza(content string) (string, error) {\n\topenerCount := countStanzaOpeners(content)\n\tif openerCount == 0 {\n\t\treturn content, nil\n\t}\n\tif openerCount > 1 {\n\t\treturn content, errMultipleStanzas\n\t}\n\n\tlines := strings.Split(content, \"\\n\")\n\topenIdx := -1\n\tcloseIdx := -1\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tvar v int\n\t\tif _, err := fmt.Sscanf(trimmed, shellCompletionOpenFormat, &v); err == nil {\n\t\t\topenIdx = i\n\t\t}\n\t\tif openIdx >= 0 && trimmed == shellCompletionClose {\n\t\t\tcloseIdx = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif openIdx >= 0 && closeIdx < 0 {\n\t\treturn content, errStanzaCorrupted\n\t}\n\n\tvar result []string\n\tresult = append(result, lines[:openIdx]...)\n\t// Skip blank line immediately after stanza if present\n\ttail := lines[closeIdx+1:]\n\tif len(tail) > 0 && strings.TrimSpace(tail[0]) == \"\" {\n\t\ttail = tail[1:]\n\t}\n\tresult = append(result, tail...)\n\treturn strings.Join(result, \"\\n\"), nil\n}\n\n// removeLegacyCompletion removes the old-format comment and its following\n// completion line from content. Returns the modified content and whether\n// anything was removed.\nfunc removeLegacyCompletion(content, completionLine string) (string, bool) {\n\tlines := strings.Split(content, \"\\n\")\n\tvar result []string\n\tremoved := false\n\tfor i := 0; i < len(lines); i++ {\n\t\tif strings.TrimSpace(lines[i]) == shellCompletionLegacyComment {\n\t\t\t// Remove the comment line and the next line if it matches the completion line\n\t\t\tif i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == completionLine {\n\t\t\t\ti++ // skip next line too\n\t\t\t}\n\t\t\tremoved = true\n\t\t\tcontinue\n\t\t}\n\t\tresult = append(result, lines[i])\n\t}\n\tif !removed {\n\t\treturn content, false\n\t}\n\treturn strings.Join(result, \"\\n\"), true\n}\n\n// errUnsupportedShell is returned when the user's shell is not supported for completion.\nvar errUnsupportedShell = errors.New(\"unsupported shell\")\n\n// shellCompletionTarget returns the rc file path and completion lines for the\n// user's current shell.\nfunc shellCompletionTarget() (shellName, rcFile, completionLine string, err error) {\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn \"\", \"\", \"\", fmt.Errorf(\"cannot determine home directory: %w\", err)\n\t}\n\n\tshell := os.Getenv(\"SHELL\")\n\tswitch {\n\tcase strings.Contains(shell, \"zsh\"):\n\t\treturn \"Zsh\",\n\t\t\tfilepath.Join(home, \".zshrc\"),\n\t\t\t\"source <(entire completion zsh)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"bash\"):\n\t\treturn \"Bash\",\n\t\t\tfilepath.Join(home, \".bashrc\"),\n\t\t\t\"source <(entire completion bash)\",\n\t\t\tnil\n\tcase strings.Contains(shell, \"fish\"):\n\t\treturn \"Fish\",\n\t\t\tfilepath.Join(home, \".config\", \"fish\", \"config.fish\"),\n\t\t\t\"entire completion fish | source\",\n\t\t\tnil\n\tdefault:\n\t\treturn \"\", \"\", \"\", errUnsupportedShell\n\t}\n}\n\n// promptShellCompletion offers to add shell completion to the user's rc file.\n// Handles versioned stanza detection, updates, and legacy migration.\nfunc promptShellCompletion(w io.Writer) error {\n\tshellName, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\tif errors.Is(err, errUnsupportedShell) {\n\t\t\tfmt.Fprintf(w, \"Note: Shell completion not available for your shell. Supported: zsh, bash, fish.\\n\")\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"shell completion: %w\", err)\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\tstatus := checkStanzaStatus(string(content), shellCompletionStanzaVersion)\n\tswitch status {\n\tcase stanzaCurrent:\n\t\tfmt.Fprintf(w, \"✓ Shell completion already configured in %s\\n\", rcFile)\n\t\treturn nil\n\n\tcase stanzaOutdated:\n\t\tif !promptYesNo(\"Shell completion is outdated. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t// Re-read in case file changed\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, replaceErr := replaceStanza(string(content), shellCompletionStanzaVersion, completionLine)\n\t\tif replaceErr != nil {\n\t\t\tfmt.Fprintf(w, \"Warning: %v in %s. Please fix manually.\\n\", replaceErr, rcFile)\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaLegacy:\n\t\tif !promptYesNo(\"Shell completion uses old format. Update?\") {\n\t\t\treturn nil\n\t\t}\n\t\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename\n\t\tcontent, err = os.ReadFile(rcFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t\t}\n\t\tupdated, _ := removeLegacyCompletion(string(content), completionLine)\n\t\tupdated = updated + \"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\"\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion updated in %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t\treturn nil\n\n\tcase stanzaNotFound:\n\t\tif !promptYesNo(fmt.Sprintf(\"Enable shell completion? (detected: %s)\", shellName)) {\n\t\t\treturn nil\n\t\t}\n\t\tif err := appendShellCompletion(rcFile, completionLine); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to update %s: %w\", rcFile, err)\n\t\t}\n\t\tfmt.Fprintf(w, \"✓ Shell completion added to %s\\n\", rcFile)\n\t\tfmt.Fprintln(w, \"  Run `source \"+rcFile+\"` or restart your shell to activate\")\n\t}\n\n\treturn nil\n}\n\n// promptYesNo shows a yes/no selection prompt and returns whether the user chose yes.\nfunc promptYesNo(title string) bool {\n\tvar selected string\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewSelect[string]().\n\t\t\t\tTitle(title).\n\t\t\t\tOptions(\n\t\t\t\t\thuh.NewOption(\"Yes\", \"yes\"),\n\t\t\t\t\thuh.NewOption(\"No\", \"no\"),\n\t\t\t\t).\n\t\t\t\tValue(&selected),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn false // User cancelled\n\t}\n\treturn selected == \"yes\"\n}\n\n// appendShellCompletion adds the completion stanza to the rc file.\nfunc appendShellCompletion(rcFile, completionLine string) error {\n\tif err := os.MkdirAll(filepath.Dir(rcFile), 0o755); err != nil {\n\t\treturn fmt.Errorf(\"creating directory: %w\", err)\n\t}\n\t//nolint:gosec // G302: Shell rc files need 0644 for user readability\n\tf, err := os.OpenFile(rcFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(\"\\n\" + buildStanza(shellCompletionStanzaVersion, completionLine) + \"\\n\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing completion: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeShellCompletion removes the shell completion stanza (or legacy format)\n// from the user's rc file. Used during uninstall.\nfunc removeShellCompletion() error {\n\trcFile, completionLine := shellCompletionTarget()\n\tif rcFile == \"\" {\n\t\treturn nil\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\ttext := string(content)\n\tupdated, removeErr := removeStanza(text)\n\tif removeErr != nil {\n\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n\t}\n\n\tif updated != text {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Fall back to legacy format removal\n\tupdated, removed := removeLegacyCompletion(text, completionLine)\n\tif removed {\n\t\t//nolint:gosec // G306: Shell rc files need 0644 for user readability\n\t\tif err := os.WriteFile(rcFile, []byte(updated), 0o644); err != nil {\n\t\t\treturn fmt.Errorf(\"writing %s: %w\", rcFile, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// promptTelemetryConsent asks the user if they want to enable telemetry.\n// It modifies settings.Telemetry based on the user's choice or flags.\n// The caller is responsible for saving settings.\nfunc promptTelemetryConsent(settings *EntireSettings, telemetryFlag bool) error {\n\t// Handle --telemetry=false flag first (always overrides existing setting)\n\tif !telemetryFlag {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\t// Skip if already asked\n\tif settings.Telemetry != nil {\n\t\treturn nil\n\t}\n\n\t// Skip if env var disables telemetry (record as disabled)\n\tif os.Getenv(\"ENTIRE_TELEMETRY_OPTOUT\") != \"\" {\n\t\tf := false\n\t\tsettings.Telemetry = &f\n\t\treturn nil\n\t}\n\n\tconsent := true // Default to Yes\n\tform := NewAccessibleForm(\n\t\thuh.NewGroup(\n\t\t\thuh.NewConfirm().\n\t\t\t\tTitle(\"Help improve Entire CLI?\").\n\t\t\t\tDescription(\"Share anonymous usage data. No code or personal info collected.\").\n\t\t\t\tAffirmative(\"Yes\").\n\t\t\t\tNegative(\"No\").\n\t\t\t\tValue(&consent),\n\t\t),\n\t)\n\n\tif err := form.Run(); err != nil {\n\t\treturn fmt.Errorf(\"telemetry prompt: %w\", err)\n\t}\n\n\tsettings.Telemetry = &consent\n\treturn nil\n}\n\n// runUninstall completely removes Entire from the repository.\nfunc runUninstall(w, errW io.Writer, force bool) error {\n\t// Check if we're in a git repository\n\tif _, err := paths.RepoRoot(); err != nil {\n\t\tfmt.Fprintln(errW, \"Not a git repository. Nothing to uninstall.\")\n\t\treturn NewSilentError(errors.New(\"not a git repository\"))\n\t}\n\n\t// Gather counts for display\n\tsessionStateCount := countSessionStates()\n\tshadowBranchCount := countShadowBranches()\n\tgitHooksInstalled := strategy.IsGitHookInstalled()\n\tclaudeHooksInstalled := checkClaudeCodeHooksInstalled()\n\tgeminiHooksInstalled := checkGeminiCLIHooksInstalled()\n\tentireDirExists := checkEntireDirExists()\n\n\t// Check if there's anything to uninstall\n\tif !entireDirExists && !gitHooksInstalled && sessionStateCount == 0 &&\n\t\tshadowBranchCount == 0 && !claudeHooksInstalled && !geminiHooksInstalled {\n\t\tfmt.Fprintln(w, \"Entire is not installed in this repository.\")\n\t\treturn nil\n\t}\n\n\t// Show confirmation prompt unless --force\n\tif !force {\n\t\tfmt.Fprintln(w, \"\\nThis will completely remove Entire from this repository:\")\n\t\tif entireDirExists {\n\t\t\tfmt.Fprintln(w, \"  - .entire/ directory\")\n\t\t}\n\t\tif gitHooksInstalled {\n\t\t\tfmt.Fprintln(w, \"  - Git hooks (prepare-commit-msg, commit-msg, post-commit, pre-push)\")\n\t\t}\n\t\tif sessionStateCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Session state files (%d)\\n\", sessionStateCount)\n\t\t}\n\t\tif shadowBranchCount > 0 {\n\t\t\tfmt.Fprintf(w, \"  - Shadow branches (%d)\\n\", shadowBranchCount)\n\t\t}\n\t\tswitch {\n\t\tcase claudeHooksInstalled && geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code, Gemini CLI)\")\n\t\tcase claudeHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Claude Code)\")\n\t\tcase geminiHooksInstalled:\n\t\t\tfmt.Fprintln(w, \"  - Agent hooks (Gemini CLI)\")\n\t\t}\n\t\tfmt.Fprintln(w)\n\n\t\tvar confirmed bool\n\t\tform := NewAccessibleForm(\n\t\t\thuh.NewGroup(\n\t\t\t\thuh.NewConfirm().\n\t\t\t\t\tTitle(\"Are you sure you want to uninstall Entire?\").\n\t\t\t\t\tAffirmative(\"Yes, uninstall\").\n\t\t\t\t\tNegative(\"Cancel\").\n\t\t\t\t\tValue(&confirmed),\n\t\t\t),\n\t\t)\n\n\t\tif err := form.Run(); err != nil {\n\t\t\treturn fmt.Errorf(\"confirmation cancelled: %w\", err)\n\t\t}\n\n\t\tif !confirmed {\n\t\t\tfmt.Fprintln(w, \"Uninstall cancelled.\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tfmt.Fprintln(w, \"\\nUninstalling Entire CLI...\")\n\n\t// 0. Remove shell completion from rc file\n\tif err := removeShellCompletion(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shell completion: %v\\n\", err)\n\t} else {\n\t\tfmt.Fprintln(w, \"  Removed shell completion\")\n\t}\n\n\t// 1. Remove agent hooks (lowest risk)\n\tif err := removeAgentHooks(w); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove agent hooks: %v\\n\", err)\n\t}\n\n\t// 2. Remove git hooks\n\tremoved, err := strategy.RemoveGitHook()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove git hooks: %v\\n\", err)\n\t} else if removed > 0 {\n\t\tfmt.Fprintf(w, \"  Removed git hooks (%d)\\n\", removed)\n\t}\n\n\t// 3. Remove session state files\n\tstatesRemoved, err := removeAllSessionStates()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove session states: %v\\n\", err)\n\t} else if statesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed session states (%d)\\n\", statesRemoved)\n\t}\n\n\t// 4. Remove .entire/ directory\n\tif err := removeEntireDirectory(); err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove .entire directory: %v\\n\", err)\n\t} else if entireDirExists {\n\t\tfmt.Fprintln(w, \"  Removed .entire directory\")\n\t}\n\n\t// 5. Remove shadow branches\n\tbranchesRemoved, err := removeAllShadowBranches()\n\tif err != nil {\n\t\tfmt.Fprintf(errW, \"Warning: failed to remove shadow branches: %v\\n\", err)\n\t} else if branchesRemoved > 0 {\n\t\tfmt.Fprintf(w, \"  Removed %d shadow branches\\n\", branchesRemoved)\n\t}\n\n\tfmt.Fprintln(w, \"\\nEntire CLI uninstalled successfully.\")\n\treturn nil\n}\n\n// countSessionStates returns the number of active session state files.\nfunc countSessionStates() int {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0\n\t}\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(states)\n}\n\n// countShadowBranches returns the number of shadow branches.\nfunc countShadowBranches() int {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn len(branches)\n}\n\n// checkClaudeCodeHooksInstalled checks if Claude Code hooks are installed.\nfunc checkClaudeCodeHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkGeminiCLIHooksInstalled checks if Gemini CLI hooks are installed.\nfunc checkGeminiCLIHooksInstalled() bool {\n\tag, err := agent.Get(agent.AgentNameGemini)\n\tif err != nil {\n\t\treturn false\n\t}\n\thookAgent, ok := ag.(agent.HookSupport)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn hookAgent.AreHooksInstalled()\n}\n\n// checkEntireDirExists checks if the .entire directory exists.\nfunc checkEntireDirExists() bool {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\t_, err = os.Stat(entireDirAbs)\n\treturn err == nil\n}\n\n// removeAgentHooks removes hooks from all agents that support hooks.\nfunc removeAgentHooks(w io.Writer) error {\n\tvar errs []error\n\n\t// Remove Claude Code hooks\n\tclaudeAgent, err := agent.Get(agent.AgentNameClaudeCode)\n\tif err == nil {\n\t\tif hookAgent, ok := claudeAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Claude Code hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove Gemini CLI hooks\n\tgeminiAgent, err := agent.Get(agent.AgentNameGemini)\n\tif err == nil {\n\t\tif hookAgent, ok := geminiAgent.(agent.HookSupport); ok {\n\t\t\twasInstalled := hookAgent.AreHooksInstalled()\n\t\t\tif err := hookAgent.UninstallHooks(); err != nil {\n\t\t\t\terrs = append(errs, err)\n\t\t\t} else if wasInstalled {\n\t\t\t\tfmt.Fprintln(w, \"  Removed Gemini CLI hooks\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn errors.Join(errs...)\n}\n\n// removeAllSessionStates removes all session state files and the directory.\nfunc removeAllSessionStates() (int, error) {\n\tstore, err := session.NewStateStore()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to create state store: %w\", err)\n\t}\n\n\t// Count states before removing\n\tstates, err := store.List(context.Background())\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list session states: %w\", err)\n\t}\n\tcount := len(states)\n\n\t// Remove the entire directory\n\tif err := store.RemoveAll(); err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to remove session states: %w\", err)\n\t}\n\n\treturn count, nil\n}\n\n// removeEntireDirectory removes the .entire directory.\nfunc removeEntireDirectory() error {\n\tentireDirAbs, err := paths.AbsPath(paths.EntireDir)\n\tif err != nil {\n\t\tentireDirAbs = paths.EntireDir\n\t}\n\tif err := os.RemoveAll(entireDirAbs); err != nil {\n\t\treturn fmt.Errorf(\"failed to remove .entire directory: %w\", err)\n\t}\n\treturn nil\n}\n\n// removeAllShadowBranches removes all shadow branches.\nfunc removeAllShadowBranches() (int, error) {\n\tbranches, err := strategy.ListShadowBranches()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to list shadow branches: %w\", err)\n\t}\n\tif len(branches) == 0 {\n\t\treturn 0, nil\n\t}\n\tdeleted, _, err := strategy.DeleteShadowBranches(branches)\n\treturn len(deleted), err\n}\n","structuredPatch":[{"oldStart":1005,"oldLines":9,"newStart":1005,"newLines":9,"lines":[" // removeShellCompletion removes the shell completion stanza (or legacy format)"," // from the user's rc file. Used during uninstall."," func removeShellCompletion() error {","-  rcFile, completionLine := shellCompletionTarget()","-  if rcFile == \"\" {","-    return nil","+  _, rcFile, completionLine, err := shellCompletionTarget()","+  if err != nil {","+    return nil // unsupported shell or no home dir - nothing to remove","   }"," ","   //nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"343cc2a6-6c4e-4e04-814e-d658b9f049a9"}
{"parentUuid":"756da67a-d15b-4513-b4bb-11eb1c0bf3f0","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_011UgzaKPocLySnD7MsTKdXM","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also fix the `err` redeclaration since we now have `err` from `shellCompletionTarget`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":359,"cache_read_input_tokens":52561,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":359},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxgW1pMBVD88XkYDqke","type":"assistant","uuid":"00b18771-88a3-4aea-ae62-ae6dc260c053","timestamp":"2026-02-09T05:42:06.300Z"}
{"parentUuid":"00b18771-88a3-4aea-ae62-ae6dc260c053","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_011UgzaKPocLySnD7MsTKdXM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WvyR8vDMmbiJVs8W1BXPFV","name":"Read","input":{"file_path":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","offset":1007,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":359,"cache_read_input_tokens":52561,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":359},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxgW1pMBVD88XkYDqke","type":"assistant","uuid":"4b046a44-7ff7-4c64-ad34-efcc68b86cd0","timestamp":"2026-02-09T05:42:06.975Z"}
{"parentUuid":"4b046a44-7ff7-4c64-ad34-efcc68b86cd0","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01WvyR8vDMmbiJVs8W1BXPFV","toolUseID":"toolu_01WvyR8vDMmbiJVs8W1BXPFV","timestamp":"2026-02-09T05:42:06.982Z","uuid":"1acec1e3-3fa2-4db5-825a-724f828ef515"}
{"parentUuid":"4b046a44-7ff7-4c64-ad34-efcc68b86cd0","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WvyR8vDMmbiJVs8W1BXPFV","type":"tool_result","content":"  1007→func removeShellCompletion() error {\n  1008→\t_, rcFile, completionLine, err := shellCompletionTarget()\n  1009→\tif err != nil {\n  1010→\t\treturn nil // unsupported shell or no home dir - nothing to remove\n  1011→\t}\n  1012→\n  1013→\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n  1014→\tcontent, err := os.ReadFile(rcFile)\n  1015→\tif err != nil {\n  1016→\t\tif os.IsNotExist(err) {\n  1017→\t\t\treturn nil\n  1018→\t\t}\n  1019→\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n  1020→\t}\n  1021→\n  1022→\ttext := string(content)\n  1023→\tupdated, removeErr := removeStanza(text)\n  1024→\tif removeErr != nil {\n  1025→\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n  1026→\t}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"01a3bd9a-d23e-4b4e-b2b5-2992d398100e","timestamp":"2026-02-09T05:42:06.981Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/paul/src/entireio/cli-completion-updater/cmd/entire/cli/setup.go","content":"func removeShellCompletion() error {\n\t_, rcFile, completionLine, err := shellCompletionTarget()\n\tif err != nil {\n\t\treturn nil // unsupported shell or no home dir - nothing to remove\n\t}\n\n\t//nolint:gosec // G304: rcFile is constructed from home dir + known filename, not user input\n\tcontent, err := os.ReadFile(rcFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"reading %s: %w\", rcFile, err)\n\t}\n\n\ttext := string(content)\n\tupdated, removeErr := removeStanza(text)\n\tif removeErr != nil {\n\t\treturn fmt.Errorf(\"%w in %s\", removeErr, rcFile)\n\t}","numLines":20,"startLine":1007,"totalLines":1346}},"sourceToolAssistantUUID":"4b046a44-7ff7-4c64-ad34-efcc68b86cd0"}
{"parentUuid":"01a3bd9a-d23e-4b4e-b2b5-2992d398100e","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_0195VXAkEddUSMSk88wxJDcy","type":"message","role":"assistant","content":[{"type":"text","text":"Good — `err` is properly re-declared with `:=` on line 1014 so there's no issue. The diagnostics now show only pre-existing lint suggestions (the `interface{}` → `any` ones are in code from both branches, not from this conflict). Let me verify the file compiles:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":636,"cache_read_input_tokens":52920,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":636},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxh1Y5ZPkqgfBqkchyj","type":"assistant","uuid":"33832a49-02a5-43a6-a3b2-d863832da482","timestamp":"2026-02-09T05:42:14.973Z"}
{"parentUuid":"33832a49-02a5-43a6-a3b2-d863832da482","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_0195VXAkEddUSMSk88wxJDcy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0126ErMofar5McsAQTZ8b8hA","name":"Bash","input":{"command":"go build ./cmd/entire/cli/ 2>&1","description":"Check if setup.go compiles"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":636,"cache_read_input_tokens":52920,"output_tokens":175,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":636,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXwxh1Y5ZPkqgfBqkchyj","type":"assistant","uuid":"31d29078-ed66-4f13-9e6e-fd92733741a6","timestamp":"2026-02-09T05:42:15.699Z"}
{"parentUuid":"31d29078-ed66-4f13-9e6e-fd92733741a6","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0126ErMofar5McsAQTZ8b8hA","type":"tool_result","content":"","is_error":false}]},"uuid":"c58a49f9-340a-4ef2-a023-f98a3a6d870a","timestamp":"2026-02-09T05:42:25.541Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"31d29078-ed66-4f13-9e6e-fd92733741a6"}
{"parentUuid":"c58a49f9-340a-4ef2-a023-f98a3a6d870a","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_011jVum2uVUWkKujY8VFRTZ2","type":"message","role":"assistant","content":[{"type":"text","text":"Compiles clean. Now let me mark the conflict as resolved and check if the tests pass:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":183,"cache_read_input_tokens":53556,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":183},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwxiP7PZnT3FmnpztVFV","type":"assistant","uuid":"735da4e5-8a85-4115-a0b8-e4c755ea150b","timestamp":"2026-02-09T05:42:31.604Z"}
{"parentUuid":"735da4e5-8a85-4115-a0b8-e4c755ea150b","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_011jVum2uVUWkKujY8VFRTZ2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BfzeJTypU9CvWCxw4ipzt5","name":"Bash","input":{"command":"git add cmd/entire/cli/setup.go","description":"Mark conflict as resolved"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":183,"cache_read_input_tokens":53556,"output_tokens":103,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":183,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXwxiP7PZnT3FmnpztVFV","type":"assistant","uuid":"e279a703-1de7-41f3-ab7a-5b093961548b","timestamp":"2026-02-09T05:42:32.191Z"}
{"parentUuid":"e279a703-1de7-41f3-ab7a-5b093961548b","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BfzeJTypU9CvWCxw4ipzt5","type":"tool_result","content":"","is_error":false}]},"uuid":"94db6689-b438-4bc0-8a99-b59fb8256f14","timestamp":"2026-02-09T05:46:13.010Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"e279a703-1de7-41f3-ab7a-5b093961548b"}
{"parentUuid":"94db6689-b438-4bc0-8a99-b59fb8256f14","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_013rnfkoq3adbAWdFpPBRM3A","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CvVmjhpNWcceCPUnzSNcLy","name":"Bash","input":{"command":"go test ./cmd/entire/cli/ -run \"Shell|Stanza|Completion|stanza|completion\" -count=1 -timeout 30s 2>&1","description":"Run shell completion related tests"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":129,"cache_read_input_tokens":53739,"output_tokens":112,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":129,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXwy1AMuDb9gsdyaK3R7N","type":"assistant","uuid":"404f2b80-297e-4824-a6f7-80f8b352cbc1","timestamp":"2026-02-09T05:46:19.759Z"}
{"parentUuid":"404f2b80-297e-4824-a6f7-80f8b352cbc1","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CvVmjhpNWcceCPUnzSNcLy","type":"tool_result","content":"ok  \tgithub.com/entireio/cli/cmd/entire/cli\t0.013s","is_error":false}]},"uuid":"abd8a007-682c-4426-b200-46d805abc52a","timestamp":"2026-02-09T05:48:00.617Z","toolUseResult":{"stdout":"ok  \tgithub.com/entireio/cli/cmd/entire/cli\t0.013s","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"404f2b80-297e-4824-a6f7-80f8b352cbc1"}
{"parentUuid":"abd8a007-682c-4426-b200-46d805abc52a","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_015Syv4BGLNmY4Sxq9M5iWUr","type":"message","role":"assistant","content":[{"type":"text","text":"Tests pass. Now let me continue the rebase:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":146,"cache_read_input_tokens":53868,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":146},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXwy97Skra3iwuT3fp1sY","type":"assistant","uuid":"fe780140-ee9f-48f2-8f1b-6ce162e154e9","timestamp":"2026-02-09T05:48:07.249Z"}
{"parentUuid":"fe780140-ee9f-48f2-8f1b-6ce162e154e9","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","message":{"model":"claude-opus-4-6","id":"msg_015Syv4BGLNmY4Sxq9M5iWUr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EhRMGLgPS6ajvPtspbKxNt","name":"Bash","input":{"command":"git rebase --continue 2>&1","description":"Continue the rebase"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":146,"cache_read_input_tokens":53868,"output_tokens":92,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":146,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXwy97Skra3iwuT3fp1sY","type":"assistant","uuid":"4ee61239-f923-4dfc-b32e-c133ed031838","timestamp":"2026-02-09T05:48:07.859Z"}
{"parentUuid":"4ee61239-f923-4dfc-b32e-c133ed031838","isSidechain":false,"userType":"external","cwd":"/Users/paul/src/entireio/cli-completion-updater","sessionId":"cfd57c28-f61a-42df-8ddf-d99b94586ea3","version":"2.1.37","gitBranch":"HEAD","slug":"goofy-rolling-wind","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EhRMGLgPS6ajvPtspbKxNt","type":"tool_result","content":"[detached HEAD e1a0f76] Add versioned stanza management for shell completion\n 2 files changed, 522 insertions(+), 32 deletions(-)\nSuccessfully rebased and updated refs/heads/cli-completion-updater.","is_error":false}]},"uuid":"3f2a8ef9-70dc-45ee-acfa-5f4a5cc76d90","timestamp":"2026-02-09T05:52:09.996Z","toolUseResult":{"stdout":"[detached HEAD e1a0f76] Add versioned stanza management for shell completion\n 2 files changed, 522 insertions(+), 32 deletions(-)\nSuccessfully rebased and updated refs/heads/cli-completion-updater.","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"4ee61239-f923-4dfc-b32e-c133ed031838"}